<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
    <!--
      Poniżej znajdują się zoptymalizowane pod SEO meta tagi dla strony vildaclinic.pl.
      Zmieniono tytuł strony i dodano meta tagi opisowe, słowa kluczowe, Open Graph,
      kanoniczny oraz robots.  Pamiętaj, że atrybuty „og:image” powinny wskazywać na
      obraz dostępny pod domeną vildaclinic.pl; domyślnie wykorzystujemy
      przygotowany plik vildaclinic-og.jpg umieszczony w katalogu images.
    -->
    <title>Vilda Clinic – BMI, centyle, odchudzanie, testy hormonalne</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Vilda Clinic - kalkulator BMI i centyli, kalkulator kalorii, plan diety odchudzającej, testy hormonalne oraz terapia hormonem wzrostu. Zadbaj o zdrowie online">
    <meta name="keywords" content="kalkulator BMI, kalkulator centyli, siatki centylowe, zdrowie dzieci, wzrost dziecka, niedowaga, nadwaga, otyłość, plan odchudzania, dieta redukcyjna, kalkulator kalorii, analiza WHR, zapotrzebowanie kaloryczne, testy hormonalne, testy endokrynologiczne, hormon wzrostu, terapia hormonem wzrostu, IGF-1">
    <!-- Open Graph tags for social sharing -->
    <meta property="og:title" content="Vilda Clinic – BMI, centyle, odchudzanie, testy hormonalne">
    <meta property="og:description" content="Vilda Clinic - kalkulator BMI i centyli, kalkulator kalorii, plan diety odchudzającej, testy hormonalne oraz terapia hormonem wzrostu. Zadbaj o zdrowie online">
    <meta property="og:image" content="https://vildaclinic.pl/images/vildaclinic-og.jpg">
    <meta property="og:url" content="https://vildaclinic.pl/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Vilda Clinic">
    <!-- Canonical URL ensures search engines treat the root domain as the main page -->
    <link rel="canonical" href="https://vildaclinic.pl/">
    <!-- Robots directive instructs crawlers to index and follow links -->
    <meta name="robots" content="index, follow">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet"/>
<!-- Zmieniamy nazwę pliku stylów na style_PWZ.css -->
<link href="style.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Progressive Web App meta tags and manifest -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#00838d">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Kalkulator kalorii">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="msapplication-TileColor" content="#00838d">
  <meta name="msapplication-TileImage" content="icons/icon-144x144.png">
  <!-- iOS touch icons -->
  <link rel="apple-touch-icon" sizes="120x120" href="icons/icon-120x120.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
  <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-167x167.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180x180.png">
</head>
<body>

<header>
  <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">
    <img src="logo_vilda.jpeg" alt="Vilda Clinic – strona główna"
         style="max-width:160px;margin-bottom:10px; border-radius:var(--radius);">
  </a>
  <h1>Kalkulator Centyli, BMI &amp; Spalania kalorii</h1>
</header>
<div class="container">
<form id="calcForm" onsubmit="return false;">
  <div class="half">
    <fieldset class="user-card"><legend>Dane użytkownika</legend>
      <!-- Zmodyfikowane pole wieku: lata oraz opcjonalnie miesiące -->
      <!-- Nowe pole imię i nazwisko -->
      <label>Imię i&nbsp;Nazwisko:
        <input type="text" id="name">
      </label>
      <label>Wiek (lata):
        <!-- Pozwalamy podać wiek w latach od 0 do 130; lata są wymagane -->
        <input type="number" id="age" min="0" max="130" oninput="debouncedUpdate()" required></label>
      <!-- Nowe pole na wiek w miesiącach; zakres 0–11, opcjonalne -->
      <label>Wiek (miesiące – opcjonalnie):
        <input type="number" id="ageMonths" min="0" max="11" oninput="debouncedUpdate()"></label>
      <label>Płeć:
        <select id="sex" onchange="debouncedUpdate()">
          <option value="M">Mężczyzna</option>
          <option value="F">Kobieta</option>
        </select></label>
      <label>Waga (kg):
        <!-- Dostosowujemy zakres do niemowląt: mniejsza waga i możliwość wpisywania wartości z dokładnością do 0.1 kg -->
        <input type="number" id="weight" min="2" max="300" step="0.1" oninput="debouncedUpdate()" required></label>
      <label>Wzrost (cm):
        <!-- Dostosowujemy zakres do niemowląt: niższy wzrost i możliwość wpisywania wartości z dokładnością do 0.1 cm -->
        <input type="number" id="height" min="45" max="250" step="0.1" oninput="debouncedUpdate()" required></label>
        <!-- Komunikat informujący o wczytaniu danych. Jest domyślnie ukryty, a pojawia się dopiero po
             prawidłowym wczytaniu pliku JSON. Umieszczamy go tuż pod polem wzrostu,
             zgodnie z wymaganiami użytkownika, aby znajdował się pomiędzy polem wzrost
             a przyciskiem „Wczytaj dane”. Kolor i pogrubienie odpowiadają palecie motywu. -->
        <div id="loadDataMessage" style="display:none;color:var(--primary);font-weight:600;text-align:center;margin-top:0.5rem;">
          Dane zostały wczytane prawidłowo. Wprowadź nowe dane, aby zobaczyć najnowsze wyniki.
        </div>
        <!-- Przyciski usuwające wszystkie dane użytkownika umieszczamy pod ostatnim polem formularza. -->
        <div style="text-align:center; margin-top:1rem;">
          <button type="button" id="loadDataBtn">Wczytaj dane</button>
          <input type="file" id="fileInput" accept=".json,application/json" style="display:none;">
          <button type="button" id="saveDataBtn" disabled>Zapisz dane</button>
          <button type="button" id="clearAllDataBtn">Wyczyść wszystkie pola</button>
        </div>
        <!-- Przełącznik sposobu animacji ostrzeżeń (ciągły vs. jednorazowy puls) -->
        <div class="text-center" style="margin:.25rem 0 .75rem 0; display:none;">
          <label style="font-weight:600;">
            <input type="checkbox" id="pulseOnce"> Jednorazowa animacja ostrzeżeń (2&nbsp;s)
          </label>
        </div>
    </fieldset>
  </div>

  <!-- Pole dla lekarzy: kontrolka wejścia do modułu lekarskiego oraz weryfikacja numeru PWZ -->
  <div class="half">
    <!-- Przeniesione podsumowanie poprzednich pomiarów nad sekcję modułu lekarskiego.
         Karta jest domyślnie ukryta, a jej elementy są uporządkowane tutaj,
         dzięki czemu pojawia się przed przyciskiem „Przejdź do modułu lekarskiego”. -->
    <div id="prevSummaryWrap" aria-live="polite" style="display:none; width:100%;">
      <div id="prevSummaryCard" class="card summary-card" style="display:none;">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <h3 style="margin:0;">Ostatni pomiar</h3>
          <!-- przycisk ukrywania karty pozostaje w DOM, ale jest domyślnie niewidoczny,
               aby karta nie zwijała się automatycznie -->
          <button type="button" id="hidePrevSummary" class="secondary-btn" style="font-size:0.9rem; display:none;">Ukryj tę kartę</button>
        </div>
        <div id="prevSummaryContent" class="summary-grid" style="margin-top:0.6rem;"></div>
      </div>
      <!-- Przycisk rozwijający podsumowanie. Ukrywamy go na stałe, ponieważ karta jest zawsze widoczna. -->
      <button type="button" id="togglePrevSummary" class="primary-btn" style="display:none; margin-top:0.5rem; width:100%;">
        Podsumowanie poprzednich pomiarów
      </button>
    </div>

    <!-- Dedykowany kontener na część przeznaczoną do przełączenia się w tryb lekarski.
         Używamy oddzielnego identyfikatora, aby w JS można było łatwo przenosić
         tę sekcję między kolumnami i widokiem mobilnym. -->
    <div id="doctorContainer">
      <div class="doctor-wrapper" id="doctorWrapper">
        <!-- Tytuł zachęcający do przejścia do modułu lekarskiego. Kliknięcie etykiety
             przełącza checkbox poniżej dzięki atrybutowi for. -->
        <label for="isDoctor" class="doctor-label">Przejdź do modułu lekarskiego</label>
        <!-- Podtytuł objaśniający przeznaczenie sekcji. Mniejszy o 0,25 rem względem
             głównego hasła. -->
        <div class="doctor-subtitle">Sekcja wyłącznie dla osób z numerem PWZ</div>
        <!-- Niestandardowy checkbox. Ustawiony poniżej tekstów, dzięki czemu
             wszystkie elementy są wyśrodkowane jeden pod drugim. -->
        <input type="checkbox" id="isDoctor" class="doctor-checkbox" />
      </div>
    </div>
    <!-- Kontener na pole z numerem PWZ, ukryty do momentu zaznaczenia checkboxa -->
    <div id="pwzContainer" style="display:none; margin-top:0.7rem;">
      <label style="display:block; font-size:0.95rem;">
        Wpisz numer prawa wykonywania zawodu:
        <!--
          Zmieniono placeholder pola numeru PWZ tak, aby nie wyświetlał przykładowego
          numeru „5425740”. Użytkownik wprowadza tu 7‑cyfrowy numer prawa
          wykonywania zawodu, dlatego pozostawiamy pusty placeholder. Jeśli w
          przyszłości chcesz ponownie dodać opis, użyj neutralnego tekstu
          (np. „Wpisz numer PWZ”).
        -->
        <input type="text" id="pwzNumber" placeholder="" maxlength="7" pattern="\d{7}" autocomplete="off" style="margin-top:0.4rem;">
      </label>
      <div id="pwzError" style="color: var(--danger); margin-top:0.5rem; display:none; font-size:0.95rem;">
        Nieprawidłowy numer PWZ
      </div>
    </div>
    <!-- Moduł profesjonalny dostępny po pozytywnej weryfikacji numeru PWZ -->
    <div id="professionalModule" class="card" style="margin-top:1rem; display:none;">
      <h3 style="margin-top:0;">Moduł profesjonalny</h3>
      <!-- W tym akapicie umieszczamy informację dla lekarzy o charakterze edukacyjnym modułu. -->
      <!-- Do komunikatu w module profesjonalnym dodajemy klasę, która pozwala wygodnie sterować stylem z poziomu CSS. -->
      <p class="professional-message">Informacje prezentowane w tym module mają charakter wyłącznie edukacyjny i są przeznaczone dla lekarzy. Nie powinny one stanowić podstawy do podejmowania decyzji diagnostycznych ani terapeutycznych.</p>

      <!-- Sekcja testów stymulacyjnych GH została przeniesiona poza moduł profesjonalny. -->
    </div>
  </div>
  <!-- Główne przyciski modułu lekarskiego – pojawiają się po pozytywnej weryfikacji numeru PWZ.
       Przycisk „Testy w endokrynologii” będzie służyć do rozwijania listy testów GH/OGTT/ACTH,
       a przycisk „Leczenie hormonem wzrostu / IGF-1” otworzy listę dodatkowych opcji IGF-1.
       Domyślnie oba przyciski są ukryte. -->
  <div id="endoButtonWrapper" style="display:none;">
    <button type="button" id="toggleEndoTests">Testy w endokrynologii</button>
  </div>
  <!-- Przyciski testów GH/OGTT/ACTH znajdują się poniżej i będą pokazywane po kliknięciu w powyższy przycisk. -->
  <!-- Kontener na przycisk uruchamiający testy stymulacyjne GH. Domyślnie ukryty;
       jest pokazywany dopiero po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ghButtonWrapper" style="display:none;">
    <button type="button" id="toggleGhTests">Testy stymulacyjne oceniające wydzielanie GH</button>
  </div>
  <!-- Dodatkowe kolumny z testami GH. Są ukryte, dopóki użytkownik nie kliknie przycisku. -->
  <div class="half gh-tests-left" id="ghTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z klonidyną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z glukagonem</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half gh-tests-right" id="ghTestsRight">
    <div class="card gh-test-card">
      <strong>Test z insuliną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z argininą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z L‑Dopą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- === NOWE TESTY: OGTT / GnRH i ACTH / TRH === -->
  <!-- Kontener na przycisk uruchamiający testy OGTT / GnRH. Domyślnie ukryty;
       pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ogttButtonWrapper" style="display:none;">
    <button type="button" id="toggleOgttTests">Test OGTT / Test z GnRH/LHRH</button>
  </div>
  <!-- Kolumny dla testów OGTT i GnRH/LHRH -->
  <div class="half ogtt-tests-left" id="ogttTestsLeft">
    <div class="card gh-test-card">
      <strong>Test OGTT</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half ogtt-tests-right" id="ogttTestsRight">
    <div class="card gh-test-card">
      <strong>Test z GnRH/LHRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Kontener na przycisk uruchamiający testy ACTH / TRH. Domyślnie ukryty
       i pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="acthButtonWrapper" style="display:none;">
    <button type="button" id="toggleActhTests">Test z dużą dawką ACTH / Test z TRH</button>
  </div>
  <!-- Kolumny dla testów ACTH i TRH -->
  <div class="half acth-tests-left" id="acthTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z dużą dawką ACTH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Podaj wiek i wagę, aby obliczyć dawkę ACTH.</p>
    </div>
  </div>
  <div class="half acth-tests-right" id="acthTestsRight">
    <div class="card gh-test-card">
      <strong>Test z TRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Przycisk otwierający listę leczenia hormonem wzrostu / IGF-1.  
       Domyślnie ukryty; pojawi się po pozytywnej weryfikacji numeru PWZ i pozostanie pod testami GH/OGTT/ACTH. -->
  <div id="igfButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgfTests" class="igf-btn">Leczenie hormonem wzrostu / IGF-1</button>
  </div>
  <!-- Podprzyciski IGF-1 (domyślnie ukryte; pokazują się po kliknięciu w „Leczenie hormonem wzrostu / IGF-1”). -->
  <div id="snpButtonWrapper" style="display:none;">
    <button type="button" id="toggleSnp" class="igf-btn">SNP</button>
  </div>
  <div id="turnerButtonWrapper" style="display:none;">
    <button type="button" id="toggleTurner" class="igf-btn">Zespół Turnera</button>
  </div>
  <div id="pwsButtonWrapper" style="display:none;">
    <button type="button" id="togglePws" class="igf-btn">Zespół PWS</button>
  </div>
  <div id="sgaButtonWrapper" style="display:none;">
    <button type="button" id="toggleSga" class="igf-btn">SGA</button>
  </div>
  <div id="igf1ButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgf1" class="igf-btn">IGF-1</button>
  </div>
</form>
<div id="errorBox"></div>
<!-- Kontener na mobilne umiejscowienie przycisku przejścia do modułu lekarskiego.
     Ten element pozostaje pusty w widoku dwukolumnowym i jest używany
     wyłącznie przy wąskim oknie, gdy formularz zajmuje całą szerokość.
     Wówczas sekcja z napisem „Przejdź do modułu lekarskiego” wraz z
     podtytułem i checkboxem zostanie tutaj przeniesiona. -->
<div id="doctorMobileContainer"></div>
  <div id="results" class="grid-two">
    <!-- Lewa kolumna: karta BMI oraz sekcja obliczeń dla dzieci z zespołem Downa
         Opakowujemy kartę BMI i blok DS wspólnym kontenerem, aby w układzie
         dwukolumnowym oba te elementy trafiły do tej samej kolumny. W układzie
         jednokolumnowym zachowana jest kolejność DOM: najpierw karta BMI,
         następnie sekcja DS. -->
    <div id="leftColumnWrap" class="left-column">
      <div class="card" id="bmiCard">
    <h2 style="text-align:center;">Centyle, BMI &amp; Basal Metabolic Rate</h2>
    <!-- Adnotacja informująca, że dla dzieci <2 lat preferowanym wskaźnikiem jest waga/długość.  
         Umieszczamy ją bezpośrednio pod nagłówkiem karty tak, aby pojawiała się pomiędzy etykietą a wynikami.
         Właściwości wyglądu (kolor i rozmiar) są definiowane w pliku CSS; w stylu pozostawiamy jedynie display.
    -->
    <div id="wflReminderBMI" class="wfl-reminder" style="display:none;"></div>
    <div id="bmrInfo"></div>
    <!-- OLAF / WHO Toggle (poprawiony) -->
    <div id="dataToggleContainer" class="toggle-wrap">
      <span class="label-left">OLAF 2010 Polska</span>
      <label class="switch">
        <!-- Domyślnie nie zaznaczaj suwaka; po podaniu wieku <3 lat skrypt ustawi go w pozycji odpowiadającej danym Palczewskiej.
             Atrybut "checked" powoduje start w pozycji WHO, co koliduje z domyślnym wyborem polskich norm dla dzieci 0–3 lat.
             Dlatego usuwamy ten atrybut, aby przełącznik startował jako nieaktywny (Palczewska/OLAF). -->
        <input type="checkbox" id="dataToggle">
        <span class="slider"></span>
      </label>
      <span class="label-right">WHO 2007 - standard globalny</span>
    </div>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMI</strong> (Body Mass Index) to wskaźnik masy ciała obliczany jako
      stosunek masy (kg) do kwadratu wzrostu (m²). Pomaga ocenić, czy Twoja masa
      ciała jest prawidłowa, z niedowagą, nadwagą czy otyłością.
    </p>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMR</strong> (Basal Metabolic Rate) to ilość energii, jaką Twoje ciało zużywa w spoczynku
      – kalorie niezbędne na podstawowe procesy życiowe (oddychanie, krążenie, termoregulacja).
    </p>

    <!-- Wyśrodkowany przycisk do wygenerowania siatek centylowych wzrostu i wagi.  -->
    <div style="text-align:center;margin-top:1.2rem;">
      <button type="button" id="generateCentileChart" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;">
        Generuj siatkę centylową
      </button>
    </div>

    <!-- Ukryty kontener na elementy generowane podczas tworzenia siatki centylowej.  
         Canvasy są tworzone dynamicznie w JS, a następnie konwertowane do obrazu.
         Kontener jest ukryty, aby nie wpływać na layout strony. -->
    <div id="centileCanvasContainer" style="display:none;"></div>
  </div>

      <!-- Placeholder usuniętego kontenera zaawansowanych obliczeń wzrostowych – zostanie on wstawiony w innym miejscu. -->
      <!-- Sekcja obliczeń DS: przycisk oraz karta z wynikami. Umieszczamy ją w
           kontenerze lewej kolumny pod kartą BMI. Sekcja jest początkowo
           ukryta; jej widoczność kontroluje JS w zależności od wieku. -->
      <div id="downSyndromeSection" style="display:none;">
        <button type="button" id="toggleDownSyndrome" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
          Obliczenia dla dzieci z zespołem Downa
        </button>
        <div id="downSyndromeCard" class="card" style="display:none; margin-top:1rem;">
          <h2 style="text-align:center;">Obliczenia dla dzieci z&nbsp;zespołem Downa</h2>
          <div id="dsPercentiles" class="result-box"></div>
          <!-- Przyciski generowania siatki DS: umieszczamy go bezpośrednio pod sekcją wyników,
               zanim pojawi się pole obwodu głowy. Przyjemny układ z wyśrodkowaniem oraz
               odstępem górnym spójny z innymi przyciskami w aplikacji. -->
          <div class="text-center" style="margin-top:.6rem;">
            <button type="button" id="generateDsCentileChart">Generuj siatkę DS</button>
          </div>
          <label style="display:block;margin-top:.6rem;">Obwód głowy (cm):
            <input type="number" id="headCircumDS" min="25" max="60" step="0.1">
          </label>
          <div id="headCircumResultDS" class="result-box" style="display:none;margin-top:.5rem;"></div>
        </div>
      </div>
    </div><!-- /#leftColumnWrap -->


  <!-- Kontener grupujący kartę Wskaźnika Cole'a i drogę do normy BMI -->
    <!-- Prawa kolumna: kontener z kartami WFL, Cole'a, WHR, itp. Pozostaje
         niezmieniona. -->
    <div id="normWrapper" class="norm-wrapper">
    <!-- Nowa karta: wskaźnik waga do długości/wzrostu (WFL).  
         W układzie jednokolumnowym pojawia się nad kartą wskaźnika Cole’a,  
         w układzie dwukolumnowym po prawej stronie również nad kartą Cole’a.  
         Elementy w środku są wypełniane dynamicznie w JS. -->
    <div class="card" id="wflCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik waga do długości/wzrostu (WFL)</h2>
      <!-- W tej sekcji JS wstawia obliczony Z‑score oraz krótką informację o wyniku. -->
      <div id="wflInfo" class="result-box"></div>
      <!-- Krótkie wyjaśnienie lub interpretacja wyniku wskaźnika WFL.  
           Używamy tej samej klasy co w przypadku wskaźnika Cole’a, aby zachować spójny wygląd. -->
      <p id="wflExplanation" class="cole-explanation"></p>
      <!-- Tabela norm dla wskaźnika waga/wzrost; wypełniana w JS. -->
      <div id="wflNormTable" style="display:none;"></div>
    </div>
    <!-- Karta Wskaźnika Cole'a – wypełniana dynamicznie w JS -->
    <div class="card" id="coleCard" style="display:none;">
      <!-- Wyśrodkowujemy nagłówek karty wskaźnika Cole'a poprzez style inline -->
      <h2 style="text-align:center;">Wskaźnik Cole'a</h2>
      <!-- Adnotacja Amerykańskiej Akademii Pediatrii; ukryta domyślnie.  
           Umieszczamy ją bezpośrednio pod nagłówkiem, dzięki czemu pojawi się
           pod etykietą karty, a przed właściwymi wynikami. Wygląd jest
           zdefiniowany w klasie .wfl-reminder w CSS; tutaj ograniczamy się
           do controlowania widoczności za pomocą display. -->
      <div id="wflReminderCole" class="wfl-reminder" style="display:none;"></div>
      <div id="coleInfo" class="result-box"></div>
      <p id="coleExplanation" class="cole-explanation"></p>
      <!-- Tabela norm wskaźnika Cole'a; wypełniana i wyświetlana przez JS -->
      <div id="coleNormTable" style="display:none;"></div>
    </div>
    <!-- ===== WHR: Wskaźnik talia-biodra ===== -->
    <div class="card" id="whrCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik talia-biodra (WHR)</h2>
    
      <!-- Sugestia kontekstowa (pokazywana, gdy spełnione warunki) -->
      <div id="whrSuggest" class="plan-warning-card notice-orange" style="display:none;">
        Sugerujemy ocenę <strong>WHR</strong>, aby sprawdzić rozmieszczenie tkanki tłuszczowej.</div>
      <div class="flex" style="gap:0.75rem;margin-top:0.5rem;">
        <label style="flex:1 1 160px;">Obwód talii (cm):
          <input type="number" id="waistCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
        <label style="flex:1 1 160px;">Obwód bioder (cm):
          <input type="number" id="hipCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
      </div>
    
      <div id="whrInfo" class="result-box" style="display:none;"></div>
      <p id="whrInterpret" class="cole-explanation" style="display:none;"></p>
    
      <!-- Krótka tabela centyli talii/bioder (dzieci) -->
      <div id="whrChildTable" class="data-card" style="display:none;margin-top:.6rem;"></div>
    
      <!-- Źródła do modułu WHR (skrócone) -->
      <small class="muted">
        Dorośli: WHO 2008/2011 cut-offs (M&gt;0,90 / K&gt;0,85). Dzieci: polskie siatki talii/bioder OLAF/OLA.
      </small>
    </div>
    <!-- ===== /WHR ===== -->
    <!-- Zaawansowane obliczenia wzrostowe – wstawione między kartę Cole'a a kartę Droga do normy BMI -->
    <div id="advancedGrowthSection" style="margin-top:1rem; display:none;">
      <button type="button" id="toggleAdvancedGrowth" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
        Zaawansowane obliczenia wzrostowe
      </button>
      <div id="advancedGrowthForm" class="card" style="display:none;margin-top:1rem;">
        <h2 style="text-align:center;">Zaawansowane obliczenia wzrostowe</h2>
        <label>Imię i&nbsp;Nazwisko (opcjonalnie):
          <input type="text" id="advName"></label>
        <label>Wiek kostny (lata):
          <input type="number" id="advBoneAge" min="0" max="18" step="0.1"></label>
        <label>Wzrost Mamy (cm):
          <input type="number" id="advMotherHeight" min="100" max="250"></label>
        <label>Wzrost Taty (cm):
          <input type="number" id="advFatherHeight" min="100" max="250"></label>
        <p style="font-weight:600;margin-top:0.8rem;">Wprowadź poprzednie pomiary</p>
        <div id="advMeasurements"></div>
        <button type="button" id="advAddMeasurementBtn" style="margin-top:0.8rem;display:block;margin-left:auto;margin-right:auto;">Dodaj kolejny pomiar</button>
        <div id="advResults" style="margin-top:1rem;"></div>
        <!-- Dodatkowe przyciski u dołu karty: generowanie siatki centylowej i czyszczenie danych tej karty. -->
        <div id="advButtons" class="adv-buttons">
          <button type="button" id="generateCentileChartAdv">Generuj siatkę centylową</button>
          <button type="button" id="advClearBtn">Wyczyść dane tej karty</button>
        </div>
      </div>
    </div>
    <!-- Karta „Droga do normy BMI” – zachowana oryginalna struktura -->
    <div class="card" id="toNormCard" style="display:none;">
      <h2>Droga do normy BMI</h2>
      <div id="toNormInfo"></div>
      <!-- Kontener na przycisk i wynik idealnej wagi. Pokazywany tylko, gdy BMI jest w normie. -->
      <div id="idealWeightWrap" style="display:none; margin-top:0.5rem; text-align:center;">
        <button type="button" id="idealWeightBtn">
          Chcesz zobaczyć jaka jest idealna waga przy twoim wzroście? Kliknij
        </button>
        <p id="idealWeightInfo" style="display:none; margin-top:0.5rem;"></p>
      </div>
      <!-- Mały napis pokazujący się tylko, gdy BMI nie jest w normie -->
      <small id="toNormNote">
        *Szacunkowa liczba km/metrów i czasu do przejścia/przejechania/przebiegnięcia, by BMI osiągnęło normę.
      </small>
    </div>
  </div>
  <div style="flex:1 1 300px;">
    <fieldset class="food-field">
      <legend>Przekąski</legend>
      <div id="snackList"></div>
      <button type="button" class="add-row" onclick="addSnackRow()">+ dodaj przekąskę</button>
    </fieldset>
    <fieldset class="food-field">
      <legend>Dania obiadowe</legend>
      <div id="mealList"></div>
      <button type="button" class="add-row" onclick="addMealRow()">+ dodaj danie</button>
    </fieldset>
    <!-- Karta sumy kalorii -->
    <div id="totalCard" class="card total-card" style="display:none;">
      <h2>Łączna kaloryczność
        <span class="subhead">(tego co wybrałeś powyżej)</span>
      </h2>
    
      <!-- Całkowite kcal – wypełnia JS -->
      <div id="totalKcal" style="font-size:1.2rem;text-align:center;margin-top:4px;"></div>
    
      <!-- Lista pozycji – wypełnia JS -->
      <div id="totalList"></div>
    </div>
  </div>
  <div class="card" id="timesCard">
    <h2 style="text-align:center;">Spalanie kalorii<span class="subhead">(czyli ile czasu zajmie mi<br>spalenie tego, co wybrałam/em)</span>
</h2>
    <div id="times"></div>
    <small>*Obliczenia oparte na wartościach MET – wyniki orientacyjne.</small>
  </div>
</div>
<!-- ======== Szacowane spożycie energii (toggle + karta) ======== -->
<div class="text-center intake-toggle-wrap">
  <button type="button" id="toggleIntakeCard" class="primary-btn" style="display:none;">
    Szacowane spożycie energii
  </button>
</div>

<section id="intakeCard" class="result-card" style="display:none;">
  <h2 class="intake-title">Szacowane spożycie energii</h2>

  <!-- PAL -->
  <div class="flex">
    <div style="flex:1 1 260px;min-width:240px;">
      <label for="intakePal">Poziom aktywności (PAL)</label>
      <select id="intakePal">
        <option value="1.2">1.2 – bardzo niska</option>
        <option value="1.4" selected>1.4 – niska</option>
        <option value="1.6">1.6 – umiarkowana</option>
        <option value="1.8">1.8 – wysoka</option>
        <option value="2.0">2.0 – bardzo wysoka</option>
      </select>
      <div id="intakePalDesc" class="muted" style="margin-top:.5rem;"></div>
    </div>
  </div>

  <!-- Wiersze pomiarów – styl jak w „Zaawansowanych obliczeniach wzrostowych” -->
  <div id="intakeMeasurements"></div>
  <div class="intake-actions">
    <button type="button" id="intakeAddRow" class="add-row">+ dodaj wiersz</button>
    <span class="muted">Uzupełnij co najmniej dwa wiersze, aby wyliczyć spożycie na podstawie zmiany masy.</span>
  </div>

  <!-- Wyniki (na desktop tabela, na mobile – wariant A: pionowe karty) -->
  <div id="intakeResults" class="result-box" style="margin-top:1rem;"></div>

  <!-- Legenda -->
  <div id="intakeLegend" class="muted" style="margin-top:.75rem;text-align:left;">
    <strong>Legenda:</strong>
    Δ masa – różnica masy (kg) między końcem i początkiem okresu;
    Oczekiwany przyrost – przyrost masy oszacowany na podstawie medianowych (50 c) przyrostów dla wieku oraz rzeczywistego wzrostu dziecka;
    Δ vs norma – różnica między rzeczywistym a oczekiwanym przyrostem;
    Nadmiar/deficyt (kcal/d) – dzienny nadmiar lub deficyt energii względem zapotrzebowania.
  </div>
</section>
<!-- ======== /Szacowane spożycie energii ======== -->
  <!-- 6. Plan odchudzania – formularz i wyniki -->
  <div id="planCard" class="plan-card" style="display:none;">
  <h2 style="text-align:center;">Plan odchudzania</h2>
  <!-- ostrzeżenie dla dzieci <10 lat z nadwagą/otyłością (wyświetlane w planie) -->
  <div id="planWarning" class="plan-warning-card" style="display:none;"></div>
  <!-- WYŚRODKOWANE POLA FORMULARZA -->
  <!--
    Zmieniono strukturę formularza planu odchudzania na dwie wyraźne sekcje.
    Każdy krok (wybór poziomu aktywności i wybór diety) posiada własny nagłówek,
    co ułatwia orientację osobom korzystającym z kalkulatora po raz pierwszy.
    Elementy opisowe (PAL oraz dieta) zostały przeniesione do dedykowanych kontenerów
    wewnątrz sekcji kroków. Dodatkowe style przypisane klasom `.plan-steps`,
    `.plan-step`, `.plan-desc` oraz `.calorie-info` są definiowane w pliku CSS.
  -->
  <div id="planInputs" class="plan-steps" style="margin-bottom:1rem;">
    <!-- Krok pierwszy: wybór poziomu aktywności -->
    <div class="plan-step">
      <h3>Krok 1: Wybierz poziom aktywności&nbsp;(PAL)</h3>
      <select id="palFactor" onchange="debouncedUpdate()">
        <option value="1.2">1.2 – bardzo niska (osoby unieruchomione)</option>
        <option value="1.4" selected>1.4 – niska (praca siedząca, brak ćwiczeń)</option>
        <option value="1.6">
          1.6 – umiarkowana (siedząca praca + 1‑3 treningi/tydz.)
        </option>
        <option value="1.8">1.8 – wysoka (fizyczna praca / sport 4‑5×/tydz.)</option>
        <option value="2.0">2.0 – bardzo wysoka (wyczynowi sportowcy)</option>
      </select>
      <!-- Opis wybranego poziomu aktywności PAL – wypełniany przez JS -->
      <div id="palDesc" class="plan-desc" style="display:none;"></div>
    </div>
    <!-- Krok drugi: wybór diety -->
    <div class="plan-step" id="dietChoiceWrap" style="display:none;">
      <h3>Krok 2: Wybierz rodzaj diety lub pozostaw rekomendowany</h3>
      <select id="dietLevel" onchange="updatePlanFromDiet()">
        <!-- opcje wypełnia JS -->
      </select>
      <!-- Opis wybranej diety – wypełniany przez JS -->
      <div id="dietDesc" class="plan-desc" style="display:none;"></div>
      <!-- Informacja o kaloryczności wybranej diety (zaokrąglona do 100 kcal) -->
      <div id="dietCalorieInfo" class="calorie-info" style="display:none;"></div>
    </div>
  </div>
  <div id="planResults"></div>
</div>
  <!-- karta dla dzieci <5 lat z nadwagą/otyłością – komunikat o konsultacji -->
  <div id="childConsultCard" class="plan-card" style="display:none;"></div>
  <!-- koniec Plan odchudzania -->
  <!--
    Nowy blok źródeł i zastrzeżeń (2025‑07‑24)
    Ten fieldset jest domyślnie ukryty i pojawia się dopiero po wykonaniu obliczeń.
    Umieszczamy go wewnątrz kontenera, aby zachować spójny układ z innymi kartami.
  -->
  <fieldset id="sourceFieldset" style="display:none;">
    <legend>O aplikacji: źródła, metodologia i zastrzeżenia</legend>
    <p>
      <strong>Przeznaczenie i sposób działania</strong><br />
      Aplikacja wykorzystuje algorytmy dopasowujące obliczenia do wieku, wzrostu i masy ciała, aby wyniki były możliwie najlepiej dostosowane do indywidualnych parametrów użytkownika. Ma charakter informacyjny i edukacyjny — nie zastępuje porady lekarskiej ani profesjonalnej diagnostyki. Wyniki nie stanowią rozpoznania, zaleceń terapeutycznych ani planu leczenia. W przypadku wątpliwości należy skonsultować się z odpowiednim specjalistą.
    </p>
    <p>
      <strong>Moduł Profesjonalny</strong><br />
      Moduł Profesjonalny jest przeznaczony wyłącznie dla lekarzy. Zawiera m.in. kalkulatory dawek leków wykorzystywanych w testach farmakologicznych.
    </p>
    <ul style="margin-left:1.25rem;margin-top:0;margin-bottom:0.5rem;">
      <li>Obliczenia mają charakter pomocniczy i wymagają niezależnej weryfikacji klinicznej.</li>
      <li>Przed zastosowaniem należy każdorazowo odnieść się do aktualnej Charakterystyki Produktu Leczniczego (ChPL), obowiązujących wytycznych, maksymalnych dawek, przeciwwskazań oraz stanu klinicznego pacjenta.</li>
      <li>Jednostki i zaokrąglenia dawek należy sprawdzać przed podaniem.</li>
      <li>Odpowiedzialność za decyzje kliniczne spoczywa na użytkowniku profesjonalnym.</li>
    </ul>
    <div style="text-align:center;margin-top:1rem;">
      <!-- Przyciski togglujący widoczność listy źródeł. Dodano aria-expanded dla dostępności -->
      <button type="button" id="toggleSources" aria-expanded="false">Źródła</button>
    </div>
    <ol id="sourceList" style="display:none;padding-left:1.25rem;margin-top:0.5rem;">
      <li>Chen LM, Chen YC, Hsiao HP, Chen BH, Chao MC. Role of thyrotropin‑releasing hormone test in re‑evaluation of congenital hypothyroidism. <em>Kaohsiung J Med Sci.</em> 2014 Aug;30(8):383‑9. doi: 10.1016/j.kjms.2014.04.005. Epub 2014 May 28. PMID: 25002375; PMCID: PMC11916237.</li>
      <li>Fröhlich E, Wahl R. The forgotten effects of thyrotropin‑releasing hormone: Metabolic functions and medical applications. <em>Front Neuroendocrinol.</em> 2019 Jan;52:29‑43. doi: 10.1016/j.yfrne.2018.06.006. Epub 2018 Jun 22. PMID: 29935915.</li>
      <li>PETER J. SNYDER, ROBERT D. UTIGER. Response to Thyrotropin Releasing Hormone (TRH) in Normal Man. <em>The Journal of Clinical Endocrinology &amp; Metabolism.</em> 1972 Feb;34(2):380–385. doi: 10.1210/jcem-34-2-380.</li>
      <li>Özsu E, Şıklar Z, Bilici E, Ceran A, Uyanık R, Çetin T, Aycan Z, Berberoğlu M. Intramuscular Short‑term ACTH Test for the Determination of Adrenal Function in Children: Safe, Effective and Reliable. <em>J Clin Res Pediatr Endocrinol.</em> 2020 Sep 2;12(3):241‑247. doi: 10.4274/jcrpe.galenos.2019.2019.0099. Epub 2019 Dec 17. PMID: 31842523; PMCID: PMC7499132.</li>
      <li>Gutierrez CE, De Beritto T. Relative Adrenal Insufficiency in the Preterm Infant. <em>Neoreviews.</em> 2022 May 1;23(5):e328‑e334. doi: 10.1542/neo.23-5-e328. PMID: 35490186.</li>
      <li>Buonocore F, McGlacken‑Byrne SM, Del Valle I, Achermann JC. Current Insights Into Adrenal Insufficiency in the Newborn and Young Infant. <em>Front Pediatr.</em> 2020 Dec 14;8:619041. doi: 10.3389/fped.2020.619041. PMID: 33381483; PMCID: PMC7767829.</li>
      <li>Pyrżak B, Walczak M, red. <em>Endokrynologia wieku rozwojowego.</em> Wyd. 2. Warszawa: PZWL Wydawnictwo Lekarskie; 2023.</li>
      <li>Dudek A, Niedziela M. Test z insuliną, z glukagonem oraz z argininą/insuliną na wydzielanie hormonu wzrostu – wykonanie testów i ich interpretacja. <em>Endokrynol. Ped.</em> 2009;9(Suppl 1):40–44.</li>
      <li>Ginalska‑Malinowska M, Malinowska A. Test z argininą, z klonidyną oraz z L‑Dopa na wydzielanie hormonu wzrostu (GH) – wykonanie testów i ich interpretacja. <em>Endokrynol. Ped.</em> 2009;9(Suppl 1):23–28.</li>
      <li>Kułaga Z, Litwin M, Tkaczyk M, Palczewska I, Zajączkowska M, Zwolińska D, Krynicki T, Wasilewska A, Moczulska A, Morawiec-Knysak A, Barwicka K, Grajda A, Gurzkowska B, Napieralska E, Pan H. Polish 2010 growth references for school‑aged children and adolescents. <em>Eur J Pediatr.</em> 2011 May;170(5):599‑609. doi: 10.1007/s00431-010-1329-x. Epub 2010 Oct 23. PMID: 20972688; PMCID: PMC3078309.</li>
      <li>WHO Multicentre Growth Reference Study Group. <em>WHO Child Growth Standards based on length/height, weight and age.</em> <em>Acta Paediatr Suppl.</em> 2006 Apr;450:76‑85. doi: 10.1111/j.1651-2227.2006.tb02378.x. PMID: 16817681.</li>
      <li>Kułaga Z, Grajda A, Gurzkowska B, Góźdź M, Wojtyło M, Swiąder A, Różdżyńska‑Świątkowska A, Litwin M. Polish 2012 growth references for preschool children. <em>Eur J Pediatr.</em> 2013 Jun;172(6):753‑61. doi: 10.1007/s00431-013-1954-2. Epub 2013 Feb 1. PMID: 23371392; PMCID: PMC3663205.</li>
      <li>Bloem M. The 2006 WHO child growth standards. <em>BMJ.</em> 2007 Apr 7;334(7596):705‑6. doi: 10.1136/bmj.39155.658843.BE. PMID: 17413142; PMCID: PMC1847861.</li>
      <li>Boguszewski MCS. Growth hormone deficiency and replacement in children. <em>Rev Endocr Metab Disord.</em> 2021 Mar;22(1):101‑108. doi: 10.1007/s11154-020-09604-2. Epub 2020 Oct 8. PMID: 33029711.</li>
    </ol>
    <!-- Skrypt do rozwijania listy źródeł. Funkcja toggluje widoczność listy po kliknięciu przycisku. -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggleButton = document.getElementById('toggleSources');
        const sourceList = document.getElementById('sourceList');
        if (toggleButton && sourceList) {
          toggleButton.addEventListener('click', function() {
            const isHidden = sourceList.style.display === 'none' || sourceList.style.display === '';
            sourceList.style.display = isHidden ? 'block' : 'none';
            // Aktualizuj atrybut aria-expanded dla lepszej dostępności
            toggleButton.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
          });
        }
      });
    </script>
  </fieldset>
</div>
<button id="downloadPDF" style="margin-top:16px;" hidden>Pobierz raport PDF</button>
<footer>
  <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">© Vilda Clinic sp. z o.o.</a>
</footer>
<!-- Uruchamiamy update() po pełnym załadowaniu strony -->
<!-- === UI ENHANCEMENT SCRIPT 2025‑06‑29 === -->
<!-- WHO patch merged automatically -->
<!-- === WHO 2006 BMI-for-age (0–60 mies.) tables inserted 2025‑06‑30 === -->
<!-- === BMI 50th percentile info patch – 2025‑06‑30 === -->
<!-- === ENHANCEMENTS: bigger/animated plan time, bold kg reduction, bigger 50th centyl info === -->
<!-- === PATCH 2025‑07‑01 – Small 50 and full time animation === -->

<!-- Load Down syndrome growth tables before app.js; these define DS datasets as global variables -->
<script src="ds_lms.js"></script>
<script src="app.js" defer></script>
<!-- po app.js -->
<script src="gh_igf_therapy.js" defer></script>


<!-- Skrypt generujący siatki centylowe wagi i wzrostu w formacie PDF.
     Kod ten korzysta z globalnych tablic LMS (zdefiniowanych w app.js) oraz bibliotek jsPDF i Canvas.
     Po kliknięciu przycisku „Generuj siatkę centylową” tworzy dwa wykresy (wzrostu i wagi),
     łączy je na jednej stronie A4 i wyświetla jako PDF w nowym oknie. -->
<script>
/* Definicje z‑score dla wybranych centyli (3., 10., 25., 50., 75., 90., 97.). */
const CENTILE_ZSCORES = { 3: -1.8808, 10: -1.281552, 25: -0.67448975, 50: 0, 75: 0.67448975, 90: 1.281552, 97: 1.8808 };

/* Interpoluje wartości LMS dla dowolnego miesiąca w danych OLAF. */
function getLMSFromDataset(dataset, m) {
  const keys = Object.keys(dataset).map(k => parseInt(k, 10)).sort((a, b) => a - b);
  if (dataset[m]) return dataset[m];
  let lo = keys[0], hi = keys[keys.length - 1];
  for (let i = 0; i < keys.length; i++) {
    if (keys[i] <= m) lo = keys[i];
    if (keys[i] >= m) { hi = keys[i]; break; }
  }
  const vLo = dataset[lo], vHi = dataset[hi];
  if (!vLo || !vHi) return vLo || vHi;
  if (lo === hi) return vLo;
  const t = (m - lo) / (hi - lo);
  const L = vLo[0] + t * (vHi[0] - vLo[0]);
  const M = vLo[1] + t * (vHi[1] - vLo[1]);
  const S = vLo[2] + t * (vHi[2] - vLo[2]);
  return [L, M, S];
}
/* Oblicza wartość z parametrów LMS i z‑score. */
function valueFromLMS(L, M, S, z) {
  if (L !== 0) {
    return M * Math.pow(1 + L * S * z, 1 / L);
  }
  return M * Math.exp(S * z);
}
/* Pobiera LMS dla wagi wg płci. */
function getLMSWeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_WEIGHT_BOYS, m) : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}
/* Pobiera LMS dla wzrostu wg płci. */
function getLMSHeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_HEIGHT_BOYS, m) : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}

/* Hybrydowa wersja LMS – dla wieku <36 mies. (0–3 lata) korzysta z danych WHO,
   natomiast dla wieku ≥36 mies. korzysta z badań OLAF (domyślne). */
function getLMSWeightHybrid(sex, m) {
  // m – miesiące (całkowite lub ułamkowe). Dla wartości ułamkowych funkcja
  // getLMSFromDataset wykona interpolację między sąsiednimi miesiącami.
  // Dane WHO obejmują okres od urodzenia do 36 mies. włącznie. Aby uniknąć
  // skoków przy przejściu z WHO do OLAF, korzystamy z WHO tylko dla m < 36 (0–35);
  // dla m ≥ 36 przechodzimy na OLAF.  Takie rozdzielenie zapobiega
  // „zagięciu” krzywych w okolicach trzeciego roku życia.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_WEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_WEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_WEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}

function getLMSHeightHybrid(sex, m) {
  // Analogicznie jak w przypadku masy: korzystamy z WHO wyłącznie dla m < 36
  // (okres 0–35 miesięcy), natomiast dla m ≥ 36 przechodzimy na OLAF.  Dzięki temu
  // unikamy gwałtownej zmiany źródła danych dla 36. miesiąca i starszych.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_HEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_HEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_HEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}
/* Rysuje pojedynczy wykres siatki centylowej. */
function drawCentileGrid(ctx, cfg) {
  const { x, y, w, h, curves, minY, maxY, userVal, userAgeMonths, title, units, percentiles, highlightBandIdx, cutoffVal, minX, maxX } = cfg;
  // Determine the horizontal range (in months) for the chart.  If minX/maxX are not
  // provided, default to the historical 3–18 lata range (36–216 mies.).  The variables
  // minXVal and maxXVal ensure we always have defined numeric values for computations.
  const minXVal = (typeof minX === 'number') ? minX : 36;
  const maxXVal = (typeof maxX === 'number') ? maxX : 216;
  const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
  const px = x + leftMargin, py = y + topMargin;
  const pw = w - leftMargin - rightMargin, ph = h - topMargin - bottomMargin;
  // Scale factors.  X‑axis is scaled according to the selected range (maxXVal – minXVal).
  const xScale = pw / (maxXVal - minXVal);
  const yScale = ph / (maxY - minY);
  ctx.save();
  ctx.lineCap = 'butt';
  // Pionowe linie siatki.  Zakres lat (startYear..endYear) zależy od zdefiniowanego zakresu mies. (minXVal..maxXVal).
  const startYear = Math.ceil(minXVal / 12);
  const endYear   = Math.floor(maxXVal / 12);
  for (let age = startYear; age <= endYear; age++) {
    const m = age * 12;
    const cx = px + (m - minXVal) * xScale;
    ctx.beginPath();
    ctx.strokeStyle = '#bbbbbb';
    ctx.lineWidth = 2.5;
    ctx.moveTo(cx, py);
    ctx.lineTo(cx, py + ph);
    ctx.stroke();
    // Połówkowe linie (co 6 mies.)
    if (age < endYear) {
      const halfM = m + 6;
      if (halfM <= maxXVal) {
        const halfX = px + (halfM - minXVal) * xScale;
        ctx.beginPath();
        ctx.strokeStyle = '#dddddd';
        ctx.lineWidth = 1.75;
        ctx.moveTo(halfX, py);
        ctx.lineTo(halfX, py + ph);
        ctx.stroke();
      }
    }
    ctx.font = '35px sans-serif';
    ctx.fillStyle = '#333333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(String(age), cx, py + ph + 8);
  }
  // Poziome linie siatki
  for (let val = minY; val <= maxY; val++) {
    const cy = py + ph - (val - minY) * yScale;
    ctx.beginPath();
    if (val % 5 === 0) {
      ctx.strokeStyle = '#bbbbbb';
      ctx.lineWidth = 2.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#333333';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(val), px - 6, cy);
    } else {
      ctx.strokeStyle = '#eeeeee';
      ctx.lineWidth = 1.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
    }
  }
  // Osie
  ctx.beginPath();
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.moveTo(px, py);
  ctx.lineTo(px, py + ph);
  ctx.moveTo(px, py + ph);
  ctx.lineTo(px + pw, py + ph);
  ctx.stroke();
  
  // Podświetlenie kanału centylowego i dwie poziome linie na poziomach 18 r.ż.
  if (typeof highlightBandIdx === 'number' && highlightBandIdx >= 0 && highlightBandIdx < percentiles.length - 1) {
    const pA = percentiles[highlightBandIdx];
    const pB = percentiles[highlightBandIdx + 1];
    const valsA = curves[pA];
    const valsB = curves[pB];
    const n = valsA.length;

    // Wypełnienie obszaru kanału (delikatny turkus)
    (function shadeBand() {
      const path = new Path2D();
      for (let i = 0; i < n; i++) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yTop = py + ph - (Math.max(valsA[i], valsB[i]) - minY) * yScale;
        if (i === 0) path.moveTo(cx, yTop); else path.lineTo(cx, yTop);
      }
      for (let i = n - 1; i >= 0; i--) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yBot = py + ph - (Math.min(valsA[i], valsB[i]) - minY) * yScale;
        path.lineTo(cx, yBot);
      }
      path.closePath();
      ctx.save();
      ctx.fillStyle = 'rgba(0,131,141,0.10)';
      ctx.fill(path);
      ctx.restore();
    })();

    // Poziome linie na wartościach 18 r.ż. (216 mies.) – przez całą szerokość siatki.
    // Wyznacz indeks w tablicach wartości, przesuwając o minXVal.  Jeżeli zakres
    // osi X nie obejmuje 18 lat (216 mies.), pomijamy te linie.
    const idx18 = 216 - minXVal;
    if (maxXVal >= 216 && idx18 >= 0 && idx18 < n) {
      const v1 = valsA[idx18];
      const v2 = valsB[idx18];
      const valLow18 = Math.min(v1, v2);
      const valHigh18 = Math.max(v1, v2);
      const yLow18 = py + ph - (valLow18 - minY) * yScale;
      const yHigh18 = py + ph - (valHigh18 - minY) * yScale;

      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = 'rgba(0,131,141,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(px, yLow18); ctx.lineTo(px + pw, yLow18); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px, yHigh18); ctx.lineTo(px + pw, yHigh18); ctx.stroke();
      ctx.setLineDash([]);

      // Etykiety wartości wewnątrz siatki, tuż przy lewym brzegu (ale nie na zewnątrz).
      // Numeryczne wartości są zaokrąglane do 0,5 jednostki (np. 174,5 cm) i
      // wyświetlane powyżej przerywanych linii, aby linie nie przechodziły przez tekst.
      function fmtToHalf(n) {
        // Zaokrąglij do połowy jednostki i zwróć z przecinkiem jako separator dziesiętny
        const rounded = Math.round(n * 2) / 2;
        return rounded.toFixed(1).replace('.', ',');
      }
      const cLow = Math.min(pA, pB);
      const cHigh = Math.max(pA, pB);
      const labelLow = `${fmtToHalf(valLow18)} ${units} (${cLow} c)`;
      const labelHigh = `${fmtToHalf(valHigh18)} ${units} (${cHigh} c)`;

      // Wyznacz pionowe pozycje dla etykiet. Odsuń je lekko w górę względem linii,
      // aby uniknąć kolizji z kreskowanymi liniami. Jeżeli linie są blisko siebie,
      // dodatkowo zwiększ odstęp.
      let y1 = yHigh18 - 18;
      let y2 = yLow18 - 18;
      // Jeśli odległość między dwoma etykietami jest zbyt mała, rozsuń je
      if (Math.abs(y2 - y1) < 32) {
        const shift = (32 - Math.abs(y2 - y1)) / 2 + 2;
        y1 -= shift;
        y2 += shift;
      }
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#004f54';
      ctx.textAlign = 'left';
      // Ustaw baseline na 'middle' tak, aby podany y oznaczał środek tekstu
      ctx.textBaseline = 'middle';
      ctx.fillText(labelHigh, px + 10, y1);
      ctx.fillText(labelLow,  px + 10, y2);
      ctx.restore();
    }
  }

  // Linie centylowe
  const colors = { 3: '#d32f2f', 10: '#f57c00', 25: '#fbc02d', 50: '#388e3c', 75: '#1976d2', 90: '#7b1fa2', 97: '#c2185b' };
  const labelPos = [];
  for (const p of percentiles) {
    const vals = curves[p];
    ctx.beginPath();
    ctx.strokeStyle = colors[p] || '#000000';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    const pts = [];
    for (let i = 0; i < vals.length; i++) {
      const mVal = minXVal + i;
      const pxVal = px + (mVal - minXVal) * xScale;
      const pyVal = py + ph - (vals[i] - minY) * yScale;
      pts.push({ x: pxVal, y: pyVal });
    }
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 0; i < pts.length - 1; i++) {
      const cpX = pts[i].x, cpY = pts[i].y;
      const midX = (pts[i].x + pts[i + 1].x) / 2;
      const midY = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(cpX, cpY, midX, midY);
    }
    ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
    ctx.stroke();
    const lastPt = pts[pts.length - 1];
    labelPos.push({ centile: p, x: lastPt.x, y: lastPt.y, color: colors[p] });
  }
  // Unikanie nakładania etykiet centyli
  labelPos.sort((a, b) => a.y - b.y);
  const minSpacing = 32;
  for (let i = 1; i < labelPos.length; i++) {
    if (labelPos[i].y - labelPos[i - 1].y < minSpacing) {
      labelPos[i].y = labelPos[i - 1].y + minSpacing;
    }
  }
  const bottom = py + ph;
  const overflow = labelPos[labelPos.length - 1].y - bottom;
  if (overflow > -16) {
    const shift = overflow + 16;
    for (const item of labelPos) {
      item.y -= shift;
    }
  }
  ctx.font = '26px sans-serif';
  ctx.textBaseline = 'middle';
  for (const item of labelPos) {
    ctx.fillStyle = item.color;
    ctx.textAlign = 'left';
    ctx.fillText(String(item.centile), px + pw + 10, item.y);
  }
  // Tytuły osi
  ctx.save();
  ctx.translate(x + 40, y + topMargin + ph / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.fillText(title, 0, 0);
  ctx.restore();
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('Wiek (lata)', px + pw / 2, py + ph + 50);
  // Ostrzeżenie w przypadku rozszerzenia zakresu wagi
  // Jeśli zdefiniowano cutoffVal (np. górną granicę oficjalnej siatki), narysuj grubą linię
  // oraz ostrzeżenie, aby zaznaczyć koniec referencyjnego zakresu.  Umieszczamy
  // go przed rysowaniem punktu użytkownika, aby punkt pozostał na wierzchu.
  if (typeof cutoffVal === 'number' && cutoffVal >= minY && cutoffVal < maxY) {
    const cyWarn = py + ph - (cutoffVal - minY) * yScale;
    ctx.save();
    ctx.strokeStyle = '#c62828';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(px, cyWarn);
    ctx.lineTo(px + pw, cyWarn);
    ctx.stroke();
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Uwaga! koniec oficjalnej siatki centylowej', px + pw / 2, cyWarn - 8);
    ctx.restore();
  }

  // Punkt użytkownika
  if (typeof userVal === 'number' && !isNaN(userVal) && typeof userAgeMonths === 'number' && userAgeMonths >= minXVal && userAgeMonths <= maxXVal) {
    const pxU = px + (userAgeMonths - minXVal) * xScale;
    const pyU = py + ph - (userVal - minY) * yScale;
    ctx.beginPath();
    ctx.fillStyle = '#000000';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.arc(pxU, pyU, 10, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.font = '33px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.textAlign = pxU > px + pw / 2 ? 'right' : 'left';
    ctx.textBaseline = 'bottom';
    const lbl = userVal.toFixed(1) + ' ' + units;
    const labelX = pxU > px + pw / 2 ? pxU - 12 : pxU + 12;
    ctx.fillText(lbl, labelX, pyU - 12);
  }
  ctx.restore();
}
/* Główna funkcja generująca PDF z siatkami centylowymi. */

async function generateCentileChart() {
  // Funkcja pomocnicza: wyznacza, między którymi centylami (indeks w tablicy percentiles)
  // znajduje się wartość użytkownika przy zadanym wieku (mIdx = miesiące - 36).
  function findHighlightBand(userVal, curves, percentiles, mIdx) {
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i = 0; i < vals.length - 1; i++) {
      const lo = Math.min(vals[i], vals[i + 1]);
      const hi = Math.max(vals[i], vals[i + 1]);
      // włączamy górną granicę, aby nie zostawiać "szczeliny"
      if (userVal >= lo && userVal <= hi) return i;
    }
    // Jeżeli wynik znajduje się poniżej najniższego centyla (3 c.) lub powyżej najwyższego (97 c.),
    // nie wyróżniaj żadnego kanału centylowego. Zwrócenie -1 powoduje brak podświetlenia
    // w przypadku wartości < 3. centyla lub > 97. centyla.
    if (userVal < Math.min(vals[0], vals[1])) return -1;
    if (userVal > Math.max(vals[vals.length - 2], vals[vals.length - 1])) return -1;
    return -1;
  }

  const ageEl = document.getElementById('age');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  if (!ageEl || !weightEl || !heightEl || !sexEl) {
    alert('Wprowadź wiek, wagę, wzrost i płeć, aby wygenerować siatkę centylową.');
    return;
  }
  // Odczytaj wiek zarówno w latach, jak i w miesiącach. Pole wieku w latach (#age) jest obowiązkowe,
  // natomiast pole miesięcy (#ageMonths) jest opcjonalne. Jeśli pole miesięcy jest puste lub
  // nie istnieje (w przypadku, gdy skrypt jest używany w kontekście bez miesiąców), przyjmujemy 0.
  const yearsVal  = parseFloat(ageEl.value) || 0;
  const ageMonthsEl = document.getElementById('ageMonths');
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  // Połącz lata i miesiące w bardziej precyzyjny wiek (np. 11 lat 6 miesięcy = 11.5).
  const ageYears = yearsVal + (monthsVal / 12);
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = sexEl.value === 'M' ? 'M' : 'F';
  // Jeżeli którakolwiek z wartości jest nieprawidłowa (NaN), przerwij generowanie wykresu.
  if (isNaN(ageYears) || isNaN(weight) || isNaN(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  // Zamień dokładny wiek (z uwzględnieniem miesięcy) na liczbę pełnych miesięcy do dalszych obliczeń.
  const ageMonths = Math.round(ageYears * 12);
  // Pozwalamy na zakres 0–18 lat (0–216 mies.). Sprawdź, czy wiek mieści się w tym zakresie.
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  // Wyznacz zakres osi X w zależności od wieku użytkownika.  Dla wieku <36 mies. używamy
  // danych Palczewska & Niedźwiecka (0–36 mies.), a dla wieku ≥36 mies. danych OLAF (36–216 mies.).
  let minXVal, maxXVal;
  // Określ, czy należy użyć danych Palczewska (wiek poniżej 3 lat) czy OLAF (wiek ≥ 3 lata).
  const usePalczewska = ageMonths < 36;
  if (usePalczewska) {
    minXVal = 0;
    maxXVal = 36;
  } else {
    minXVal = 36;
    maxXVal = 216;
  }
  const months = [];
  for (let m = minXVal; m <= maxXVal; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n)).sort((a, b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  // Wypełnij krzywe centylowe dla wybranego zakresu miesięcy. Dla wieku <3 lat (0–35 miesięcy)
  // korzystamy z siatek Palczewskiej i Niedźwieckiej (polska populacja).  Dla wieku ≥ 3 lat
  // (36–18 lat) używamy wyłącznie danych OLAF/WHO. Dzięki temu unikamy łączenia dwóch
  // różnych źródeł przy wartościach 36 miesięcy i zapewniamy spójność wykresu.
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        // pobierz wartości z siatki polskiej (Palczewska & Niedźwiecka)
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        // użyj funkcji LMS dla wieku ≥ 3 lat (OLAF/WHO)
        const [Lw, Mw, Sw] = getLMSWeightHybrid(sex, m);
        const [Lh, Mh, Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }

  /*
   * Krótkie wygładzanie krzywych centylowych (optional smoothing)
   * Aby poprawić wizualną jakość wykresów, zastosujmy prosty filtr
   * średniej kroczącej do każdej tablicy wartości wagi i wzrostu.  Używamy
   * okna o szerokości 3 i wykonujemy sześć przebiegów.  Większa liczba
   * przebiegów mocniej wygładza krzywe, redukując ostre załamania
   * wynikające z dyskretnych danych, jednocześnie minimalnie zmieniając
   * wartości referencyjne.
   */
  function smoothCurve(arr, passes = 1) {
    let out = arr.slice();
    const n = arr.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      // dla brzegów nie możemy użyć pełnego okna; pozostawiamy oryginalne wartości
      // można także przyjąć średnią z sąsiada, ale zachowujemy źródłową wartość
      out = tmp;
    }
    return out;
  }
  // Zastosuj wygładzanie do wszystkich krzywych przed obliczeniem zakresów
  for (const p of percentiles) {
    // Zwiększamy liczbę przebiegów do 6, aby osiągnąć jeszcze mocniejsze wygładzenie krzywych.
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  let minW = Infinity, maxW = -Infinity, minH = Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  minW = Math.floor(minW / 5) * 5; maxW = Math.ceil(maxW / 5) * 5;
  minH = Math.floor(minH / 5) * 5; maxH = Math.ceil(maxH / 5) * 5;

  // --- DYNAMICZNE SKALOWANIE osi Y (wzrost + waga, góra i dół) ---
  // 0) Pomocnicze zaokrąglenia do 5, żeby linie siatki były czytelne:
  const roundDown5 = v => Math.floor(v / 5) * 5;
  const roundUp5 = v => Math.ceil(v / 5) * 5;

  // 1) Zbierz skrajne pomiary z bieżących pól i z karty zaawansowanej
  let minMeasuredW = weight, maxMeasuredW = weight;
  let minMeasuredH = height, maxMeasuredH = height;

  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        if (typeof m.weight === 'number') {
          if (m.weight < minMeasuredW) minMeasuredW = m.weight;
          if (m.weight > maxMeasuredW) maxMeasuredW = m.weight;
        }
        if (typeof m.height === 'number') {
          if (m.height < minMeasuredH) minMeasuredH = m.height;
          if (m.height > maxMeasuredH) maxMeasuredH = m.height;
        }
      });
    }
    if (typeof adv.currentWeight === 'number') {
      if (adv.currentWeight < minMeasuredW) minMeasuredW = adv.currentWeight;
      if (adv.currentWeight > maxMeasuredW) maxMeasuredW = adv.currentWeight;
    }
    if (typeof adv.currentHeight === 'number') {
      if (adv.currentHeight < minMeasuredH) minMeasuredH = adv.currentHeight;
      if (adv.currentHeight > maxMeasuredH) maxMeasuredH = adv.currentHeight;
    }
  }

  // 2) Wyznacz dynamiczne granice (zaokrąglone do „piątek”)
  let dynamicMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynamicMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;

  let dynamicMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynamicMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;

  // 3) Zakresy przed/po zmianach (potrzebne do proporcjonowania wysokości wykresów)
  const origWRange = maxW - minW;
  const origHRange = maxH - minH;
  const newWRange = dynamicMaxW - dynamicMinW;
  const newHRange = dynamicMaxH - dynamicMinH;

  // 4) Flagi ułatwiające decyzje dalej
  const scaledW = (dynamicMinW !== minW) || (dynamicMaxW !== maxW);
  const scaledH = (dynamicMinH !== minH) || (dynamicMaxH !== maxH);
  const useDynamicScaling = scaledW || scaledH;
  
  // Indeks miesiąca użytkownika (0..180) i kanały do podświetlenia dla wzrostu i wagi
  // Indeks miesiąca użytkownika wewnątrz tablicy months.  Odejmiemy początek zakresu osi X.
  const mIdx = ageMonths - minXVal;
  const hBandIdx = findHighlightBand(height, heightCurves, percentiles, mIdx);
  const wBandIdx = findHighlightBand(weight, weightCurves, percentiles, mIdx);
const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw;
  canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, pw, ph);
  const header = sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki';
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(header, pw / 2, 60);
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  /*
   * Użytkownik poprosił o obniżenie napisu „Imię i nazwisko” względem nagłówka o 1 rem.
   * Ponieważ płótno jest tworzone w wysokiej rozdzielczości (~300 dpi), 1 rem (16 px w CSS)
   * odpowiada ok. 50 pikselom na płótnie. Dlatego dodajemy 50 pikseli do pozycji Y,
   * aby uzyskać bardziej wyraźny odstęp między nagłówkiem a etykietą imienia i nazwiska.
   */
  // Obniżenie etykiety „Imię i nazwisko” o 1,75 rem względem nagłówka (1,25 rem z poprzedniej wersji + 0,5 rem dodatkowo).
  // --- DYNAMICZNY napis "Imię i nazwisko" (z karty Zaawansowane) ---
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');

  const nameLabel = nameFromState
    ? `Imię i nazwisko: ${nameFromState}`
    : 'Imię i nazwisko: _________________________________';

  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // --- koniec wstawki ---
  const chartW = pw - 200;
  // Oblicz dostępną przestrzeń na siatki dopiero w momencie rysowania, gdy znamy wysokość strony.
  const availH = ph - 300;
  // Margines pomiędzy dwoma wykresami (jak w oryginalnym projekcie).
  const interChartMargin = 100;
  // Przestrzeń dostępna wyłącznie na dwie siatki (wysokość płótna minus margines).
  const chartsAreaH = availH - interChartMargin;
  // Dynamicznie przydziel wysokość dla wzrostu i wagi w zależności od tego,
  // czy zmienił się zakres którejkolwiek osi Y (waga lub wzrost).
  let heightGridH, weightGridH;
  if (useDynamicScaling) {
    // Proporcja przestrzeni ~ proporcji aktualnych zakresów Y
    let tmpHeight = chartsAreaH * (newHRange / (newHRange + newWRange || 1));
    let tmpWeight = chartsAreaH - tmpHeight;
    // Zadbaj o minimalną wysokość górnego wykresu (wzrostu), aby nie był za niski
    const minHeightChartH = chartsAreaH * 0.30;
    if (tmpHeight < minHeightChartH) {
      tmpHeight = minHeightChartH;
      tmpWeight = chartsAreaH - tmpHeight;
    }
    heightGridH = tmpHeight;
    weightGridH = tmpWeight;
  } else {
    // Bez zmian zakresów – po połowie miejsca
    heightGridH = chartsAreaH / 2;
    weightGridH = chartsAreaH / 2;
  }
  // Pozycje Y dla obu wykresów. Górny wykres zaczyna się w ustalonej pozycji, a dolny jest przesunięty
  // o wysokość pierwszego wykresu plus margines minus małe przesunięcie (0,5 rem) kompensujące podpisy osi.
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Pierwszy wykres – wzrost
  drawCentileGrid(ctx, {
    x: 100,
    y: yHeightGrid,
    w: chartW,
    h: heightGridH,
    curves: heightCurves,
    minY: dynamicMinH,
    maxY: dynamicMaxH,
    userVal: height,
    userAgeMonths: ageMonths,
    title: 'Wzrost (cm)',
    units: 'cm',
    percentiles,
    highlightBandIdx: hBandIdx,
    // Przekazujemy początek i koniec osi X, aby rysunek obsługiwał wiek 0–3 lub 3–18 lat.
    minX: minXVal,
    maxX: maxXVal,
    cutoffVal: (dynamicMaxH > maxH) ? maxH : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wzrostu ---
  // Jeżeli użytkownik wprowadził dodatkowe dane (historia pomiarów,
  // potencjał wzrostowy, wiek kostny), wyświetlamy je na siatce
  // centylowej wzrostu. Elementy te rysujemy po narysowaniu
  // standardowych krzywych, aby były widoczne na wierzchu.
  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    // Obliczenia współczynników skalowania odpowiadające tym w
    // drawCentileGrid(). Marginesy muszą być zgodne z tymi użytymi
    // w funkcji rysującej, aby punkty były prawidłowo rozmieszczone.
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yHeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = heightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYh = dynamicMinH;
      const maxYh = dynamicMaxH;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYh - minYh);
      ctx.save();
      // Rysowanie linii łączących historyczne pomiary wzrostu
      if (adv.measurements && adv.measurements.length) {
        // Do listy punktów dodajemy również aktualny pomiar wzrostu, tak aby
        // linia łączyła historię z bieżącym wzrostem dziecka.
        let pts = adv.measurements.filter(m => m.height !== null).slice();
        if (typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
          pts.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Linie łączące kolejne pomiary
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.height - minYh) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Punkty pomiarowe
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.height - minYh) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      // Rysowanie markeru docelowego wzrostu (Target Height).
      // Do etykiety dodajemy przewidywany ostateczny wzrost w centymetrach, np. „TH 166.0 cm”.
      if (typeof adv.targetHeight === 'number' && !isNaN(adv.targetHeight)) {
        const mAgeTH = 216; // 18 lat w miesiącach
        if (mAgeTH >= minX && mAgeTH <= maxX) {
          const cx = pxBase + (mAgeTH - minX) * xScale;
          const cy = pyBase + phBase - (adv.targetHeight - minYh) * yScale;
          ctx.beginPath();
          ctx.fillStyle = '#c62828';
          ctx.moveTo(cx - 8, cy);
          ctx.lineTo(cx, cy - 8);
          ctx.lineTo(cx + 8, cy);
          ctx.lineTo(cx, cy + 8);
          ctx.closePath();
          ctx.fill();
          // Etykieta „TH” wraz z wartością docelowego wzrostu w cm.
          const thLabel = adv.targetHeight.toFixed(1) + ' cm';
          ctx.font = 'bold 28px sans-serif';
          ctx.fillStyle = '#c62828';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText('TH ' + thLabel, cx + 14, cy);
        }
      }
      // Rysowanie markera wieku kostnego (jeśli podano)
      if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths)) {
        const boneXAge = adv.boneAgeMonths;
        // Zaznacz punkt na osi czasu odpowiadający wiekowi kostnemu
        if (boneXAge >= minX && boneXAge <= maxX && typeof adv.currentHeight === 'number') {
          const cxBone = pxBase + (boneXAge - minX) * xScale;
          const cyBone = pyBase + phBase - (adv.currentHeight - minYh) * yScale;
          const cxCurrent = pxBase + (adv.currentAgeMonths - minX) * xScale;
          // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
          ctx.beginPath();
          ctx.strokeStyle = '#00838d';
          ctx.lineWidth = 2;
          ctx.moveTo(cxBone, cyBone);
          ctx.lineTo(cxCurrent, cyBone);
          ctx.stroke();
          // Zaznacz kropkę z pierścieniem
          ctx.beginPath();
          ctx.fillStyle = '#00838d';
          ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
          ctx.strokeStyle = '#00838d';
          ctx.stroke();
        }
      }
      // Rysowanie WSZYSTKICH historycznych wieków kostnych (jak aktualny: kropka z pierścieniem)
      try {
        if (adv && Array.isArray(adv.measurements)) {
          adv.measurements.forEach(m => {
            if (!m) return;
            // Toleruj wartość wieku kostnego przechowywaną jako napis lub liczba
            const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string')
              ? parseFloat(m.boneAgeYears) : NaN;
            const hVal = (typeof m.height === 'number' || typeof m.height === 'string')
              ? parseFloat(m.height) : NaN;
            const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string')
              ? parseFloat(m.ageMonths) : NaN;
            if (!isNaN(bVal) && !isNaN(hVal) && !isNaN(ageM)) {
              const mBoneMonths = Math.round(bVal * 12);
              // Sprawdź czy mieści się w zakresie osi
              if (mBoneMonths >= minX && mBoneMonths <= maxX && hVal >= minYh && hVal <= maxYh) {
                const cxB = pxBase + (mBoneMonths - minX) * xScale;
                const cyB = pyBase + phBase - (hVal - minYh) * yScale;
                const cxCurrentM = pxBase + (ageM - minX) * xScale;
                // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
                ctx.beginPath();
                ctx.strokeStyle = '#00838d';
                ctx.lineWidth = 2;
                ctx.moveTo(cxB, cyB);
                ctx.lineTo(cxCurrentM, cyB);
                ctx.stroke();
                // Zaznacz kropkę z pierścieniem
                ctx.beginPath();
                ctx.fillStyle = '#00838d';
                ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00838d';
                ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
                ctx.stroke();
              }
            }
          });
        }
      } catch(_){}
      ctx.restore();
    })();
  }
  /*
   * Aby uniknąć ucinania dolnych podpisów osi X na wydruku, podnosimy siatkę centylową wagi
   * o 1 rem (ok. 50 pikseli) względem pierwotnej pozycji. Odejmujemy więc 50 pikseli
   * od wartości Y drugiego wykresu.
   */
  // Drugi wykres – waga. Używamy dynamicznie dobranych wymiarów i osi, jeśli zakres wagi został rozszerzony.
  drawCentileGrid(ctx, {
    x: 100,
    y: yWeightGrid,
    w: chartW,
    h: weightGridH,
    curves: weightCurves,
    // Użyj dynamicMaxW jako górnej granicy osi wagi, jeśli rozszerzono zakres.
    minY: dynamicMinW,
    maxY: dynamicMaxW,
    userVal: weight,
    userAgeMonths: ageMonths,
    title: 'Waga (kg)',
    units: 'kg',
    percentiles,
    highlightBandIdx: wBandIdx
    ,
    // Zakres osi X oraz ewentualne ostrzeżenie o końcu oficjalnej siatki wagi.
    minX: minXVal,
    maxX: maxXVal,
    // Przekazujemy oryginalne maksimum jako cutoffVal w przypadku przekroczenia, aby narysować linię ostrzegawczą.
    cutoffVal: (dynamicMaxW > maxW) ? maxW : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wagi ---
  // Po narysowaniu wykresu wagi możemy nanieść historię pomiarów wagi
  // wprowadzone przez użytkownika. Użytkownicy mogą wpisywać
  // dowolną liczbę pomiarów; rysujemy linie łączące kolejne punkty i
  // same punkty. Pozostałe elementy (potencjał wzrostowy, wiek kostny)
  // nie dotyczą wagi i dlatego nie są tu rysowane.
  if (window.advancedGrowthData) {
    const advW = window.advancedGrowthData;
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yWeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = weightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYw = dynamicMinW;
      const maxYwLocal = dynamicMaxW;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYwLocal - minYw);
      ctx.save();
      if (advW.measurements && advW.measurements.length) {
        // Dodaj aktualny pomiar wagi, aby linia łączyła historię z bieżącą wagą dziecka.
        let pts = advW.measurements.filter(m => m.weight !== null).slice();
        if (typeof advW.currentWeight === 'number' && typeof advW.currentAgeMonths === 'number') {
          pts.push({ ageMonths: advW.currentAgeMonths, weight: advW.currentWeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Rysuj linie łączące kolejne pomiary wagi
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.weight - minYw) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Rysuj punkty wagi
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.weight - minYw) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      ctx.restore();
    })();
  }

  // Dodaj informację źródłową w prawym dolnym rogu. Informujemy użytkownika,
  // że dane użyte do wygenerowania siatek centylowych pochodzą z badania OLAF.
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  // Uaktualnij informację o źródle danych: siatki 0–3 lata opierają się na standardach WHO,
  // a dla wieku 3–18 lat na badaniu OLAF. Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Aktualizujemy informację o źródle danych: siatki 0–3 lata oparte są na polskim
  // badaniu Palczewskiej i Niedźwieckiej (Warszawa 1999), natomiast siatki 3–18 lat
  // korzystają z badań OLAF (2007–2012).  Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Obniżamy podpis w dolnej części strony o około 1 rem (~50 px) względem oryginalnej pozycji.
  const footerY = ph - 60 + 50;
  // Tekst po prawej stronie z informacją o źródłach danych
  ctx.fillText('Dane do siatek centylowych: Palczewska & Niedźwiecka (0–3 lata) i OLAF (3–18 lat)', pw - 120, footerY);
  // Tekst po lewej z nazwą kliniki na tej samej wysokości
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
document.addEventListener('DOMContentLoaded', function() {
  const btn = document.getElementById('generateCentileChart');
  if (btn) {
    btn.addEventListener('click', generateCentileChart);
  }
  // Dodaj obsługę przycisku generowania siatki centylowej z karty zaawansowanej
  const btnAdv = document.getElementById('generateCentileChartAdv');
  if (btnAdv) {
    btnAdv.addEventListener('click', generateCentileChart);
  }
  // Obsługa czyszczenia danych karty zaawansowanej
  const advClear = document.getElementById('advClearBtn');
  if (advClear) {
    advClear.addEventListener('click', () => {
      if (typeof clearAdvancedGrowthCard === 'function') {
        clearAdvancedGrowthCard();
      }
    });
  }
  // Obsługa usuwania wszystkich danych – przywraca aplikację do stanu początkowego
  const clearAll = document.getElementById('clearAllDataBtn');
  if (clearAll) {
    clearAll.addEventListener('click', () => {
      location.reload();
    });
  }
});

</script>

<!-- Now override the default growth chart implementation to support infants (0–<3 lata) and older children (3–18 lat).  -->
<script>
/*
 * Poniższy blok zastępuje standardową funkcję generateCentileChart() oraz dodaje szereg funkcji
 * pomocniczych umożliwiających generowanie dwóch oddzielnych wykresów PDF: jeden dla dzieci
 * młodszych niż 3 lata (0–35 miesięcy) w oparciu o siatki Palczewskiej i Niedźwieckiej, oraz
 * drugi dla wieku 3–18 lat (36–216 miesięcy) oparty na projekcie OLAF.  W przypadku gdy
 * przedział wiekowy przekracza 3. rok życia (minAll <36 i maxAll >36), generowane są dwie
 * strony PDF.  Wszystkie funkcje są deklaracjami funkcyjnymi, dzięki czemu nadpisują wcześniejsze
 * deklaracje o tej samej nazwie w pierwszym skrypcie.
 */

// Bezpiecznie znajdź kanał centylowy dla podanej wartości.  Zwraca indeks kanału (0..len-2) lub -1.
function findHighlightBandSafe(userVal, curves, percentiles, mIdx) {
  if (!Number.isFinite(mIdx)) return -1;
  const anyP = percentiles[0];
  if (!curves[anyP]) return -1;
  const n = curves[anyP].length;
  if (mIdx < 0 || mIdx >= n) return -1;
  const vals = percentiles.map(p => curves[p][mIdx]);
  for (let i = 0; i < vals.length - 1; i++) {
    const a = vals[i], b = vals[i + 1];
    if (a == null || b == null) continue;
    const lo = Math.min(a, b), hi = Math.max(a, b);
    if (userVal >= lo && userVal <= hi) return i;
  }
  return -1;
}

// Zbierz wszystkie wieki (miesiące) z danych podstawowych i zaawansowanych.
function collectAllAgesMonths(ageMonths, adv) {
  const ages = [ageMonths];
  if (adv) {
    if (Number.isFinite(adv.currentAgeMonths)) ages.push(adv.currentAgeMonths);
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const am = Number(m.ageMonths);
        if (Number.isFinite(am)) ages.push(am);
      });
    }
  }
  const minAll = Math.min(...ages);
  const maxAll = Math.max(...ages);
  return { ages, minAll, maxAll };
}

// Filtruj i sortuj pomiary mieszczące się w określonym zakresie stron (wieku).
function collectPageMeasurementsInRange(rangeMinX, rangeMaxX, { currentAgeMonths, currentWeight, currentHeight, adv }) {
  const ptsH = [];
  const ptsW = [];
  if (adv && Array.isArray(adv.measurements)) {
    adv.measurements.forEach(m => {
      const am = Number(m.ageMonths);
      if (!Number.isFinite(am) || am < rangeMinX || am > rangeMaxX) return;
      // Nie używaj Number() dla wartości wzrostu i wagi w pomiarach historycznych,
      // ponieważ Number(null) zamienia null na 0, co powoduje błędne rysowanie punktu 0.
      // Zamiast tego, zastosuj parseFloat() i obsłuż null/undefined/puste pola jako NaN.
      const hRaw = m.height;
      const wRaw = m.weight;
      // Użyj parseFloat() do konwersji tylko wtedy, gdy pole nie jest puste
      const h = (hRaw !== null && hRaw !== undefined && hRaw !== '') ? parseFloat(hRaw) : NaN;
      const w = (wRaw !== null && wRaw !== undefined && wRaw !== '') ? parseFloat(wRaw) : NaN;
      // Jeśli wzrost lub waga są NaN lub nie dodatnie, pomiń je. W rzeczywistości 0 oznacza brak danych,
      // dlatego traktujemy 0 lub wartości ujemne jako brakujące i nie rysujemy takich punktów.
      if (Number.isFinite(h) && h > 0) ptsH.push({ ageMonths: am, height: h });
      if (Number.isFinite(w) && w > 0) ptsW.push({ ageMonths: am, weight: w });
    });
  }
  if (Number.isFinite(currentAgeMonths) && currentAgeMonths >= rangeMinX && currentAgeMonths <= rangeMaxX) {
    // Dodaj bieżący pomiar tylko, gdy waga/wzrost są dodatnie
    if (Number.isFinite(currentHeight) && currentHeight > 0) ptsH.push({ ageMonths: currentAgeMonths, height: currentHeight });
    if (Number.isFinite(currentWeight) && currentWeight > 0) ptsW.push({ ageMonths: currentAgeMonths, weight: currentWeight });
  }
  if (adv && Number.isFinite(adv.currentAgeMonths) && adv.currentAgeMonths >= rangeMinX && adv.currentAgeMonths <= rangeMaxX) {
    if (Number.isFinite(adv.currentHeight) && adv.currentHeight > 0) ptsH.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
    if (Number.isFinite(adv.currentWeight) && adv.currentWeight > 0) ptsW.push({ ageMonths: adv.currentAgeMonths, weight: adv.currentWeight });
  }
  ptsH.sort((a,b) => a.ageMonths - b.ageMonths);
  ptsW.sort((a,b) => a.ageMonths - b.ageMonths);
  return { ptsH, ptsW };
}

// Zbuduj jedną stronę (0–35 miesięcy Palczewska lub 36–216 miesięcy OLAF) jako canvas.
function buildCentilePageCanvas({
  rangeMinX, rangeMaxX, sex, userAgeMonths, userWeight, userHeight,
  headerTitle, headerSubtitle, footerText
}) {
  // Przygotuj dane centylowe
  const months = [];
  for (let m = rangeMinX; m <= rangeMaxX; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n,10)).sort((a,b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  const usePalczewska = rangeMaxX <= 35;
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        const [Lw,Mw,Sw] = getLMSWeightHybrid(sex, m);
        const [Lh,Mh,Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }
  // Gładzenie krzywych
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice(); const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) tmp[i] = (out[i-1] + out[i] + out[i+1]) / 3;
      out = tmp;
    }
    return out;
  }
  for (const p of percentiles) {
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  // Ustal pierwotne zakresy Y
  let minW = +Infinity, maxW = -Infinity, minH = +Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  const roundDown5 = v => Math.floor(v/5)*5;
  const roundUp5   = v => Math.ceil(v/5)*5;
  minW = roundDown5(minW); maxW = roundUp5(maxW);
  minH = roundDown5(minH); maxH = roundUp5(maxH);
  // Dynamika – dostosuj zakresy Y do aktualnych pomiarów na tej stronie
  const adv = window.advancedGrowthData || null;
  const { ptsH, ptsW } = collectPageMeasurementsInRange(rangeMinX, rangeMaxX, {
    currentAgeMonths: userAgeMonths,
    currentWeight: userWeight,
    currentHeight: userHeight,
    adv
  });
  // Zainicjuj zakresy pomiarów na podstawie bieżących danych tylko wtedy,
  // gdy waga/wzrost są dodatnie. Zero lub ujemne wartości oznaczają brak danych.
  let minMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : +Infinity;
  let maxMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : -Infinity;
  let minMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : +Infinity;
  let maxMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : -Infinity;
  ptsW.forEach(p => { if (p.weight < minMeasuredW) minMeasuredW = p.weight; if (p.weight > maxMeasuredW) maxMeasuredW = p.weight; });
  ptsH.forEach(p => { if (p.height < minMeasuredH) minMeasuredH = p.height; if (p.height > maxMeasuredH) maxMeasuredH = p.height; });
  let dynMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;
  let dynMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;
  const scaledW = (dynMinW !== minW) || (dynMaxW !== maxW);
  const scaledH = (dynMinH !== minH) || (dynMaxH !== maxH);
  // Tworzenie płótna
  const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw; canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, pw, ph);
  // Nagłówek
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(headerTitle, pw/2, 60);
  if (headerSubtitle) {
    ctx.font = '40px sans-serif';
    ctx.fillStyle = '#444';
    ctx.fillText(headerSubtitle, pw/2, 60 + 72 + 8);
  }
  // Imię i nazwisko
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'left';
  const nameLabel = nameFromState ? `Imię i nazwisko: ${nameFromState}` : 'Imię i nazwisko: _________________________________';
  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // Wymiary wykresów
  const chartW = pw - 200;
  const availH = ph - 300;
  const interChartMargin = 100;
  const chartsAreaH = availH - interChartMargin;
  let heightGridH, weightGridH;
  if (scaledW || scaledH) {
    const hRange = dynMaxH - dynMinH;
    const wRange = dynMaxW - dynMinW;
    let tmpH = chartsAreaH * (hRange / (hRange + wRange || 1));
    let tmpW = chartsAreaH - tmpH;
    const minHFrac = chartsAreaH * 0.30;
    if (tmpH < minHFrac) { tmpH = minHFrac; tmpW = chartsAreaH - tmpH; }
    heightGridH = tmpH; weightGridH = tmpW;
  } else {
    heightGridH = chartsAreaH / 2; weightGridH = chartsAreaH / 2;
  }
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Podświetlenie kanałów
  // Ustal „efektywne” dane do podświetlenia: jeśli użytkownik korzysta
  // z sekcji Zaawansowane, bieżący wiek/wzrost/masa mogą być wprowadzone
  // właśnie tam (np. uzupełniono tylko w formularzu zaawansowanym).
  const advForHighlight = window.advancedGrowthData || {};
  // Weź wiek z sekcji zaawansowanej, jeśli istnieje i jest liczbą
  const effectiveAgeMonths = (typeof advForHighlight.currentAgeMonths === 'number' && !isNaN(advForHighlight.currentAgeMonths))
    ? advForHighlight.currentAgeMonths
    : userAgeMonths;
  const effectiveHeight = (typeof advForHighlight.currentHeight === 'number' && !isNaN(advForHighlight.currentHeight))
    ? advForHighlight.currentHeight
    : userHeight;
  const effectiveWeight = (typeof advForHighlight.currentWeight === 'number' && !isNaN(advForHighlight.currentWeight))
    ? advForHighlight.currentWeight
    : userWeight;
  const mIdxForPage = effectiveAgeMonths - rangeMinX;
  const hBandIdx = findHighlightBandSafe(effectiveHeight, heightCurves, percentiles, mIdxForPage);
  const wBandIdx = findHighlightBandSafe(effectiveWeight, weightCurves, percentiles, mIdxForPage);
  // Rysuj wzrost
  drawCentileGrid(ctx, {
    x: 100, y: yHeightGrid, w: chartW, h: heightGridH,
    curves: heightCurves,
    minY: dynMinH, maxY: dynMaxH,
    // Do rysowania punktu użytkownika korzystaj z efektywnych wartości (z sekcji
    // Zaawansowane, jeśli tam zostały podane), tak aby marker odzwierciedlał
    // aktualne dane niezależnie od formularza głównego.
    userVal: effectiveHeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Wzrost (cm)', units: 'cm',
    percentiles, highlightBandIdx: hBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxH > maxH) ? maxH : undefined
  });
  // Linie i punkty historii wzrostu
  (function drawHeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    if (ptsH.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsH.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsH.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();
  // Rysowanie markerów wieku kostnego (aktualny i historyczne) na wykresie wzrostu
  (function drawBoneAgeMarkers() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    // Skopiuj marginesy i obliczenia skali z rysowania historii wzrostu
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    // Aktualny wiek kostny
    if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths) &&
        typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
      const boneAgeM = adv.boneAgeMonths;
      if (boneAgeM >= rangeMinX && boneAgeM <= rangeMaxX) {
        const cxBone = pxBase + (boneAgeM - rangeMinX) * xScale;
        const cyBone = pyBase + phBase - (adv.currentHeight - dynMinH) * yScale;
        const cxCurrent = pxBase + (adv.currentAgeMonths - rangeMinX) * xScale;
        // pozioma linia
        ctx.beginPath();
        ctx.strokeStyle = '#00838d';
        ctx.lineWidth = 2;
        ctx.moveTo(cxBone, cyBone);
        ctx.lineTo(cxCurrent, cyBone);
        ctx.stroke();
        // kropka z pierścieniem
        ctx.beginPath();
        ctx.fillStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
        ctx.stroke();
      }
    }
    // Historyczne wieki kostne
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const hVal = (typeof m.height === 'number' || typeof m.height === 'string') ? parseFloat(m.height) : NaN;
        const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string') ? parseFloat(m.ageMonths) : NaN;
        const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string') ? parseFloat(m.boneAgeYears) : NaN;
        if (!isNaN(hVal) && !isNaN(ageM) && !isNaN(bVal)) {
          const mBoneMonths = Math.round(bVal * 12);
          if (mBoneMonths >= rangeMinX && mBoneMonths <= rangeMaxX && hVal >= dynMinH && hVal <= dynMaxH) {
            const cxB = pxBase + (mBoneMonths - rangeMinX) * xScale;
            const cyB = pyBase + phBase - (hVal - dynMinH) * yScale;
            const cxCurrM = pxBase + (ageM - rangeMinX) * xScale;
            // linia pozioma
            ctx.beginPath();
            ctx.strokeStyle = '#00838d';
            ctx.lineWidth = 2;
            ctx.moveTo(cxB, cyB);
            ctx.lineTo(cxCurrM, cyB);
            ctx.stroke();
            // kropka z pierścieniem
            ctx.beginPath();
            ctx.fillStyle = '#00838d';
            ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00838d';
            ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
      });
    }
    ctx.restore();
  })();

  // Rysowanie markera docelowego wzrostu (Target Height) na wykresie wzrostu.
  // Marker jest rysowany jako czerwony romb w wieku 18 lat (216 mies.) z etykietą „TH xx,x cm”.
  (function drawTargetHeightMarker() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    const th = adv.targetHeight;
    // Sprawdź, czy docelowy wzrost jest liczbą.
    if (typeof th !== 'number' || isNaN(th)) return;
    // Umieszczamy znacznik w wieku 18 lat (216 mies.).  Rysuj tylko na stronach
    // obejmujących ten wiek (np. 3–18 lat); dla zakresu 0–3 lat znacznik nie jest wyświetlany.
    const mAgeTH = 216;
    if (mAgeTH < rangeMinX || mAgeTH > rangeMaxX) return;
    // Wymiary wykresu wzrostu (ponownie wykorzystujemy marginesy jak w drawHeightHistory).
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    // Oblicz współrzędne rombu.
    const cx = pxBase + (mAgeTH - rangeMinX) * xScale;
    const cy = pyBase + phBase - (th - dynMinH) * yScale;
    // Tylko rysuj, jeśli punkt mieści się w zakresie osi Y.
    if (th < dynMinH || th > dynMaxH) return;
    ctx.save();
    // Rysuj romb w kolorze czerwonym (#c62828)
    ctx.beginPath();
    ctx.fillStyle = '#c62828';
    ctx.moveTo(cx - 10, cy);
    ctx.lineTo(cx, cy - 10);
    ctx.lineTo(cx + 10, cy);
    ctx.lineTo(cx, cy + 10);
    ctx.closePath();
    ctx.fill();
    // Etykieta z wartością docelowego wzrostu (TH)
    const label = 'TH ' + th.toFixed(1) + ' cm';
    ctx.font = 'bold 40px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, cx + 14, cy);
    ctx.restore();
  })();
  // Rysuj wagę
  drawCentileGrid(ctx, {
    x: 100, y: yWeightGrid, w: chartW, h: weightGridH,
    curves: weightCurves,
    minY: dynMinW, maxY: dynMaxW,
    // Analogicznie jak dla wzrostu, dla punktu użytkownika używamy wartości
    // efektywnych (z sekcji zaawansowanej, jeśli podano).
    userVal: effectiveWeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Waga (kg)', units: 'kg',
    percentiles, highlightBandIdx: wBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxW > maxW) ? maxW : undefined
  });
  // Linie i punkty historii wagi
  (function drawWeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yWeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = weightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxW - dynMinW);
    ctx.save();
    if (ptsW.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsW.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsW.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();
  // Stopka (źródło danych)
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  const footerY = ph - 60 + 50;
  ctx.fillText(footerText, pw - 120, footerY);
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  return canvas;
}

// Główna funkcja generująca PDF.  Tworzy jedną lub dwie strony w zależności od tego,
// czy dane przekraczają próg 3 lat.
async function generateCentileChart() {
  const ageEl = document.getElementById('age');
  const ageMonthsEl = document.getElementById('ageMonths');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  const yearsVal = parseFloat(ageEl.value) || 0;
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  const ageYears = yearsVal + monthsVal/12;
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = (sexEl.value === 'M') ? 'M' : 'F';
  if (!Number.isFinite(ageYears) || !Number.isFinite(weight) || !Number.isFinite(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  const ageMonths = Math.round(ageYears * 12);
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  const adv = window.advancedGrowthData || null;
  const { minAll, maxAll } = collectAllAgesMonths(ageMonths, adv);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  function addPage({ minX, maxX, subtitle, footer }) {
    const canvas = buildCentilePageCanvas({
      rangeMinX: minX, rangeMaxX: maxX, sex,
      userAgeMonths: ageMonths, userWeight: weight, userHeight: height,
      headerTitle: (sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki'),
      headerSubtitle: subtitle,
      footerText: footer
    });
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  }
  const spansAcross3yo = (minAll < 36) && (maxAll > 36);
  if (spansAcross3yo) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
    pdf.addPage();
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  } else if (maxAll <= 35) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
  } else {
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  }
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
// === KONIEC NOWEJ IMPLEMENTACJI SIATKI CENTYLOWEJ ===
</script>

<!-- Skrypt generujący siatkę centylową DS (wzrost i waga) w formacie PDF -->
<script>
// === DOWN SYNDROME (DS) GROWTH CHARTS → PDF (0–20 lat) ==================
// Wymaga: ds_lms.js (window.DS), drawCentileGrid(), valueFromLMS(), getLMSFromDataset(),
// CENTILE_ZSCORES oraz biblioteki jsPDF (już są w tej stronie).
(function(){
  const ZS = (typeof CENTILE_ZSCORES === 'object' && CENTILE_ZSCORES) || {3:-1.8808,10:-1.281552,25:-0.67448975,50:0,75:0.67448975,90:1.281552,97:1.8808};
  const hasGetLMS = (typeof getLMSFromDataset === 'function');
  const hasValLMS = (typeof valueFromLMS === 'function');
  function getLMSFromDatasetSafe(dataset, m){
    if (hasGetLMS) return getLMSFromDataset(dataset, m);
    const keys = Object.keys(dataset).map(k=>parseInt(k,10)).sort((a,b)=>a-b);
    if (dataset[m]) return dataset[m];
    let lo = keys[0], hi = keys[keys.length-1];
    for (let i=0;i<keys.length;i++){ if (keys[i] <= m) lo = keys[i]; if (keys[i] >= m){ hi = keys[i]; break; } }
    const vLo = dataset[lo], vHi = dataset[hi];
    if (!vLo || !vHi) return vLo || vHi;
    if (lo === hi) return vLo;
    const t = (m-lo)/(hi-lo);
    return [ vLo[0]+t*(vHi[0]-vLo[0]), vLo[1]+t*(vHi[1]-vLo[1]), vLo[2]+t*(vHi[2]-vLo[2]) ];
  }
  function valueFromLMSSafe(L,M,S,z){
    if (hasValLMS) return valueFromLMS(L,M,S,z);
    return (L !== 0) ? (M * Math.pow(1 + L*S*z, 1/L)) : (M * Math.exp(S*z));
  }
  function yearsToMonthsMap(objYears){
    const out = {};
    Object.keys(objYears || {}).forEach(k=>{
      const m = Math.round(parseFloat(k)*12);
      out[m] = objYears[k];
    });
    return out;
  }
  const DS_DATA = (typeof window !== 'undefined' && window.DS) ? window.DS : null;
  const CHILD_W_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_GIRLS)  : {};
  const CHILD_W_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_BOYS)   : {};
  const CHILD_H_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_GIRLS)  : {};
  const CHILD_H_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_BOYS)   : {};
  function dsGetLMSWeight(sex, m){
    if (!DS_DATA) return null;
    if (m <= 36){
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_WEIGHT_BOYS : DS_DATA.DS_INFANT_WEIGHT_GIRLS, m);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_W_B : CHILD_W_G, m);
    }
  }
  function dsGetLMSHeight(sex, m){
    if (!DS_DATA) return null;
    if (m < 36){
      const mm = Math.max(1, m);
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_LENGTH_BOYS : DS_DATA.DS_INFANT_LENGTH_GIRLS, mm);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_H_B : CHILD_H_G, m);
    }
  }
  const DS_PERCENTILES = [3,10,25,50,75,90,97];
  /*
   * Krótkie wygładzanie krzywych centylowych dla dzieci z zespołem Downa.
   * Zastosowano prosty filtr średniej kroczącej (okno 3, 6 przebiegów),
   * podobnie jak w siatkach centylowych OLAF.  Dzięki temu linie krzywych
   * DS są bardziej płynne i pozbawione ostrych załamań.
   *
   * @param {number[]} arr  Tablica wartości centylowych do wygładzenia
   * @param {number}   passes Liczba przebiegów wygładzania (domyślnie 6)
   * @returns {number[]} Wygładzona tablica
   */
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice();
    const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      out = tmp;
    }
    return out;
  }
  function buildCurves(minX, maxX, sex, lmsGetter){
    const curves = {};
    DS_PERCENTILES.forEach(p=>{
      const z = ZS[p];
      const arr = [];
      for (let m=minX; m<=maxX; m++){
        const lms = lmsGetter(sex, m);
        arr.push(lms ? valueFromLMSSafe(lms[0], lms[1], lms[2], z) : null);
      }
      curves[p] = arr;
    });
    return curves;
  }
  function rangeFromCurves(curves){
    let lo = +Infinity, hi = -Infinity;
    Object.values(curves).forEach(arr=>{
      arr.forEach(v=>{ if (v==null) return; if (v<lo) lo=v; if (v>hi) hi=v; });
    });
    if (!isFinite(lo) || !isFinite(hi)){ lo = 0; hi = 1; }
    const pad = 0.05*(hi-lo);
    lo = Math.floor((lo - pad)/5)*5;
    hi = Math.ceil ((hi + pad)/5)*5;
    return [lo, hi];
  }
  function findHighlightBandLocal(userVal, curves, percentiles, mIdx){
    if (!Number.isFinite(mIdx)) return -1;
    const anyP = percentiles[0];
    if (!curves[anyP]) return -1;
    const n = curves[anyP].length;
    if (mIdx < 0 || mIdx >= n) return -1;
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i=0;i<vals.length-1;i++){
      const a = vals[i], b = vals[i+1];
      if (a==null || b==null) continue;
      const lo = Math.min(a,b), hi = Math.max(a,b);
      if (userVal >= lo && userVal <= hi) return i;
    }
    return -1;
  }
  function findBand(userVal, curves, percentiles, mIdx){
    if (typeof findHighlightBandSafe === 'function'){
      return findHighlightBandSafe(userVal, curves, percentiles, mIdx);
    }
    return findHighlightBandLocal(userVal, curves, percentiles, mIdx);
  }
  function generateDsCentileChart(){
    const ageEl    = document.getElementById('age');
    const ageMEl   = document.getElementById('ageMonths');
    const sexEl    = document.getElementById('sex');
    const weightEl = document.getElementById('weight');
    const heightEl = document.getElementById('height');
    if (!ageEl || !sexEl || !weightEl || !heightEl){
      alert('Wprowadź wiek, płeć, wagę i wzrost.');
      return;
    }
    const years  = parseFloat(ageEl.value)   || 0;
    const months = ageMEl ? (parseFloat(ageMEl.value) || 0) : 0;
    const ageMonths = Math.round(years*12 + months);
    if (!(ageMonths >= 0 && ageMonths <= 240)){
      alert('Siatka DS dostępna dla wieku 0–20 lat.');
      return;
    }
    const sex = (sexEl.value === 'M') ? 'M' : 'F';
    const w   = parseFloat(weightEl.value);
    const h   = parseFloat(heightEl.value);
    const minX = 0, maxX = 240;
    const weightCurves = buildCurves(minX, maxX, sex, dsGetLMSWeight);
    const heightCurves = buildCurves(minX, maxX, sex, dsGetLMSHeight);
    // Wygładź krzywe DS przy użyciu tego samego algorytmu co w siatkach OLAF
    for (const p of DS_PERCENTILES) {
      if (Array.isArray(weightCurves[p])) {
        weightCurves[p] = smoothCurve(weightCurves[p], 6);
      }
      if (Array.isArray(heightCurves[p])) {
        heightCurves[p] = smoothCurve(heightCurves[p], 6);
      }
    }
    const [wMin, wMax] = rangeFromCurves(weightCurves);
    const [hMin, hMax] = rangeFromCurves(heightCurves);
    const canvas = document.createElement('canvas');
    canvas.width  = 2480;
    canvas.height = 3508;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const topBox = { x:80, y:40, w:canvas.width-160, h:Math.floor(canvas.height/2) - 100 };
    const botBox = { x:80, y:Math.floor(canvas.height/2)+60, w:canvas.width-160, h:Math.floor(canvas.height/2) - 120 };
    const hiBandH = (Number.isFinite(h) ? findBand(h, heightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: topBox.x, y: topBox.y, w: topBox.w, h: topBox.h,
      curves: heightCurves,
      minY: hMin, maxY: hMax,
      userVal: Number.isFinite(h) ? h : undefined,
      userAgeMonths: ageMonths,
      title: 'Wzrost (cm)',
      units: 'cm',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandH,
      minX, maxX
    });
    const hiBandW = (Number.isFinite(w) ? findBand(w, weightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: botBox.x, y: botBox.y, w: botBox.w, h: botBox.h,
      curves: weightCurves,
      minY: wMin, maxY: wMax,
      userVal: Number.isFinite(w) ? w : undefined,
      userAgeMonths: ageMonths,
      title: 'Waga (kg)',
      units: 'kg',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandW,
      minX, maxX
    });
    ctx.save();
    ctx.font = '30px sans-serif';
    ctx.fillStyle = '#555555';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    // Przesuń napisy w dolnej części siatki o dodatkową jednostkę (1 rem ≈ 50 px)
    // aby uniknąć nałożenia się na etykietę osi wieku. Dzięki temu tekst źródła
    // („Dane DS: Zemel et al., Pediatrics 2015…”) oraz nazwa kliniki („vildaclinic.pl”)
    // znajdują się niżej o ok. 50 px w stosunku do poprzedniej wersji.
    const dsFooterY = canvas.height - 80 + 50;
    ctx.fillText('Dane DS: Zemel et al., Pediatrics 2015 (0–20 lat)', canvas.width - 120, dsFooterY);
    ctx.textAlign = 'left';
    ctx.fillText('vildaclinic.pl', 120, dsFooterY);
    ctx.restore();
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
    const blob = pdf.output('blob');
    const url  = URL.createObjectURL(blob);
    window.open(url, '_blank');
  }
  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('generateDsCentileChart');
    if (btn) {
      btn.addEventListener('click', generateDsCentileChart);
    }
  });
})();
</script>

<!-- Register the service worker for offline support and updates -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('service-worker-kalorii.js')
        .then(function(registration) {
          console.log('Service worker registered with scope:', registration.scope);
        })
        .catch(function(error) {
          console.error('Service worker registration failed:', error);
        });
    });
  }
</script>

</body>
</html>
