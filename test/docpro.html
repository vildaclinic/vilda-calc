<!DOCTYPE html>
<html lang="pl">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EZZTNV8W07"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EZZTNV8W07');
</script>
</head>
<meta charset="utf-8" />
    <!--
      Poniżej znajdują się zoptymalizowane pod SEO meta tagi dla strony vildaclinic.pl.
      Zmieniono tytuł strony i dodano meta tagi opisowe, słowa kluczowe, Open Graph,
      kanoniczny oraz robots.  Pamiętaj, że atrybut „og:image” powinien wskazywać na
      obraz dostępny pod domeną wagaiwzrost.pl.  W tym projekcie korzystamy z
      przygotowanego pliku wagaiwzrost‑og.jpg umieszczonego w katalogu images.
    -->
    <title>DocPro – Waga i wzrost</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <!-- Zaktualizowany opis: akcentujemy markę Waga i wzrost oraz kluczowe funkcje aplikacji -->
    <meta name="description" content="Waga i wzrost – kompleksowy kalkulator BMI, siatek centylowych, WHR, BMR oraz zapotrzebowania kalorycznego. Zawiera moduł lekarski z testami hormonalnymi i terapią GH/IGF‑1. Darmowe narzędzie edukacyjne Vilda Clinic">
    <meta name="keywords" content="kalkulator BMI, niskorosłość, zespół Downa, siatki centylowe, zdrowie dzieci, wzrost dziecka, niedowaga, nadwaga, otyłość, plan odchudzania, dieta redukcyjna, kalkulator kalorii, analiza WHR, zapotrzebowanie kaloryczne, testy hormonalne, testy endokrynologiczne, hormon wzrostu, terapia hormonem wzrostu, IGF-1">
    <!-- Open Graph tags for social sharing -->
    <meta property="og:title" content="Waga i wzrost">
    <meta property="og:description" content="Waga i wzrost – kompleksowy kalkulator BMI, siatek centylowych, WHR, BMR oraz zapotrzebowania kalorycznego. Zawiera moduł lekarski z testami hormonalnymi i terapią GH/IGF‑1. Darmowe narzędzie edukacyjne Vilda Clinic">
    <meta property="og:url" content="https://wagaiwzrost.pl/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Waga i wzrost">
    <!-- Dodajemy znacznik og:image wraz z rozmiarami. Grafika powinna znajdować się w katalogu images/ -->
    <meta property="og:image" content="images/wagaiwzrost-og.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <!-- Canonical URL ensures search engines treat the root domain as the main page -->
    <link rel="canonical" href="https://wagaiwzrost.pl/">
    <!-- Robots directive instructs crawlers to index and follow links -->
    <meta name="robots" content="index, follow">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet"/>
<!-- Zmieniamy nazwę pliku stylów na style_PWZ.css -->
<link href="style.css" rel="stylesheet" />
<link href="ios26-v2.css" rel="stylesheet" />
<link href="sidebar.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js" defer></script>

  <!-- Progressive Web App meta tags and manifest -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#00838d">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Waga i wzrost">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="msapplication-TileColor" content="#00838d">
  <meta name="msapplication-TileImage" content="pwa-icons/icon-144x144.png">
  <!-- iOS touch icons -->
  <link rel="apple-touch-icon" sizes="120x120" href="pwa-icons/icon-120x120.png">
  <link rel="apple-touch-icon" sizes="152x152" href="pwa-icons/icon-152x152.png">
  <link rel="apple-touch-icon" sizes="167x167" href="pwa-icons/icon-167x167.png">
  <link rel="apple-touch-icon" sizes="180x180" href="pwa-icons/icon-180x180.png">
  <!-- Place these in your <head> -->
<link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="144x144" href="/favicon-144x144.png">
<link rel="icon" type="image/png" sizes="512x512" href="/favicon-512x512.png">
<link rel="shortcut icon" href="/favicon.ico">
    <!-- Lottie player script for showing animations (used in Z‑score batch loading overlay) -->
    <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js" defer></script>
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@graph": [
          {
            "@type": "Organization",
            "@id": "https://wagaiwzrost.pl/#org",
            "name": "Vilda Clinic sp. z o.o.",
            "legalName": "Vilda Clinic sp. z o.o.",
            "url": "https://vildaclinic.pl",
            "logo": {
              "@type": "ImageObject",
              "url": "https://wagaiwzrost.pl/logo_vilda.jpeg"
            },
            "address": {
              "@type": "PostalAddress",
              "streetAddress": "ul. 28 Czerwca 1956 r. 261",
              "postalCode": "61‑485",
              "addressLocality": "Poznań",
              "addressCountry": "PL"
            },
            "contactPoint": [
              { "@type": "ContactPoint", "contactType": "customer support", "telephone": "+48 692 109 156", "email": "biuro@vildaclinic.pl" },
              { "@type": "ContactPoint", "contactType": "customer support", "telephone": "+48 888 555 045" }
            ],
            "identifier": [
              { "@type": "PropertyValue", "propertyID": "PL-NIP", "value": "7831823044" },
              { "@type": "PropertyValue", "propertyID": "REGON", "value": "38684406100000" },
              { "@type": "PropertyValue", "propertyID": "KRS", "value": "0000856633" }
            ],
            "sameAs": ["https://vildaclinic.pl"]
          },
          {
            "@type": "Person",
            "@id": "https://wagaiwzrost.pl/#dr-flader",
            "name": "dr n. med. Maciej Flader",
            "jobTitle": "Autor merytoryczny",
            "affiliation": { "@id": "https://wagaiwzrost.pl/#org" },
            "identifier": {
              "@type": "PropertyValue",
              "propertyID": "PWZ",
              "value": "2315523"
            }
          },
          {
            "@type": "WebSite",
            "@id": "https://wagaiwzrost.pl/#website",
            "name": "Waga i wzrost",
            "url": "https://wagaiwzrost.pl/",
            "publisher": { "@id": "https://wagaiwzrost.pl/#org" },
            "inLanguage": "pl‑PL"
          },
          {
            "@type": "WebPage",
            "@id": "https://wagaiwzrost.pl/#homepage",
            "name": "Waga i wzrost — kalkulatory BMI, siatki centylowe i więcej",
            "url": "https://wagaiwzrost.pl/",
            "isPartOf": { "@id": "https://wagaiwzrost.pl/#website" },
            "publisher": { "@id": "https://wagaiwzrost.pl/#org" },
            "reviewedBy": { "@id": "https://wagaiwzrost.pl/#dr-flader" },
            "inLanguage": "pl‑PL",
            "isAccessibleForFree": true
          }
        ]
      }
      </script>
      <!-- Style specific to the DocPro subpage.  These rules adjust the layout of the
           user data fields into two columns on larger screens and hide the
           standard results section that is not relevant to the professional
           module. -->
      <style>
        /* By default the user field containers stack vertically */
        .user-fields-row {
          display: flex;
          flex-direction: column;
        }
        .user-col-left,
        .user-col-right {
          flex: 1;
        }
        /* Ułóż elementy wewnątrz każdej kolumny w pionie.  Bez tego
           przycisk „Wyczyść wszystkie pola” mógł ustawiać się obok
           pola wzrostu na szerokich ekranach. */
        .user-col-left,
        .user-col-right {
          display: flex;
          flex-direction: column;
        }
        /* On wider screens (700px and above) arrange the user fields into two
           columns with a gap between them */
        @media (min-width: 700px) {
          .user-fields-row {
            flex-direction: row;
            gap: 1rem;
          }
        }
        /* Hide the general results section and associated cards on the DocPro
           page, since only the professional module is relevant here. */
        #results {
          display: none !important;
        }
        /* Ukryj kontener komunikatów o błędach (np. „Podaj jednocześnie wiek, wagę i wzrost”)
           na podstronie DocPro, ponieważ te komunikaty dotyczą kalkulatorów
           ogólnych, które są tutaj niewidoczne. */
        #errorBox {
          display: none !important;
        }

        /*
         * Zachowaj dwukolumnowy układ formularza (#calcForm) na szerokich ekranach.
         * Globalny arkusz stylów definiuje grid z dwiema kolumnami (1fr 1fr),
         * dlatego poniższa reguła upewnia się, że podstrona DocPro również
         * korzysta z dwóch kolumn – karta użytkownika po lewej, sekcja lekarska po prawej.
         */
        @media (min-width: 700px) {
          #calcForm {
            grid-template-columns: 1fr 1fr !important;
          }
        }

        /* Pełna szerokość karty danych użytkownika na podstronie DocPro.
         * Karta (fieldset.user-card) dziedziczy minimalne marginesy boczne z
         * formularza, ale sama miała automatyczne dopasowanie szerokości,
         * co w połączeniu z niektórymi globalnymi regułami powodowało jej
         * zawężenie.  Ustawiamy szerokość i max-width na 100%, aby
         * wypełniała całą dostępną przestrzeń kontenera.
         */
        #userSection fieldset.user-card {
          /* Pozostaw szerokość karty użytkownika zgodną z układem kolumn siatki.
             Nie wymuszaj pełnej szerokości; pozwól wypełnić przestrzeń kolumny. */
        }

        /* Nie nadpisuj szerokości kontenera sekcji użytkownika – jego rozmiar
           wynika z klasy .half oraz układu siatki formularza. */
        #userSection {
          /* width: 100% !important; */
        }

        /* Na podstronie DocPro całkowicie ukrywamy sekcję „Szacowane spożycie energii”
         * wraz z przyciskiem, który ją rozwija.  Te elementy są przydatne
         * na stronie głównej, ale nie w module profesjonalnym. */
        #toggleIntakeCard,
        #intakeCard {
          display: none !important;
        }

        /* Przywracamy globalne ograniczenie max-width dla kontenera na stronie
         * DocPro (960 px).  Dodatkowa klasa .container-docpro została usunięta
         * z głównego kontenera, więc ta reguła nie jest już potrzebna. */

        /*
         * Sformatuj komunikat informujący o konieczności wpisania numeru PWZ.
         * W stanie początkowym powinien być wyśrodkowany oraz turkusowy,
         * aby przyciągał uwagę użytkownika. Po pozytywnej weryfikacji
         * numeru element .doctor-info jest ukrywany przez skrypt JS.
         */
        .doctor-info {
          text-align: center;
          color: var(--primary);
        }

        /* === Profesjonalny overlay ===
         * Pełnoekranowa warstwa, która przyciemnia stronę i wymaga
         * potwierdzenia od użytkownika, zanim udostępni treści dla lekarzy.
         * W trybie mobilnym i desktopowym wypełnia całe okno i blokuje
         * interakcje z tłem.  Zawiera wewnętrzny kontener z nagłówkiem,
         * opisem i dwoma przyciskami akcji.  Przycisk „Potwierdzam” ma
         * delikatnie turkusowe tło, natomiast „Wychodzę” jest biały. */
        #professionalOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          display: none;
          align-items: center;
          justify-content: center;
          background: rgba(0, 0, 0, 0.6);
          z-index: 10000;
        }
        #professionalOverlay .professional-overlay-inner {
          background: var(--card);
          color: var(--text);
          padding: 1.5rem 1.2rem;
          border-radius: var(--radius);
          max-width: 460px;
          width: 90%;
          box-shadow: 0 4px 20px rgba(0,0,0,0.2);
          text-align: center;
        }
        #professionalOverlay .professional-overlay-inner h3 {
          margin-top: 0;
          margin-bottom: 0.8rem;
          color: var(--primary);
          font-size: 1.4rem;
        }
        #professionalOverlay .professional-overlay-inner p {
          margin: 0 0 1.4rem;
          font-size: 0.95rem;
          line-height: 1.4;
        }
        #professionalOverlay .professional-overlay-buttons {
          display: flex;
          justify-content: center;
          gap: 1rem;
          flex-wrap: wrap;
        }
        #professionalOverlay .professional-confirm-btn {
          background: var(--secondary);
          color: #fff;
          border: none;
          border-radius: var(--radius);
          padding: 0.55rem 1.2rem;
          cursor: pointer;
          font: inherit;
          transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        #professionalOverlay .professional-confirm-btn:hover {
          background: var(--primary);
          box-shadow: var(--shadow);
        }
        #professionalOverlay .professional-exit-btn {
          background: #ffffff;
          color: var(--primary);
          border: 1px solid #d0dede;
          border-radius: var(--radius);
          padding: 0.55rem 1.2rem;
          cursor: pointer;
          font: inherit;
          transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        #professionalOverlay .professional-exit-btn:hover {
          background: #f5f9f9;
          box-shadow: var(--shadow);
        }

        /* === Overlay zapamiętywania numeru PWZ ===
         * Druga pełnoekranowa warstwa służąca do zadania pytania, czy
         * zapamiętać numer prawa wykonywania zawodu w przeglądarce.
         * Wzorowana na overlayu modułu profesjonalnego i zawiera
         * nagłówek, opis oraz dwa przyciski „Tak” i „Nie”. */
        #rememberPwzOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          display: none;
          align-items: center;
          justify-content: center;
          background: rgba(0, 0, 0, 0.6);
          z-index: 10001;
        }
        #rememberPwzOverlay .remember-overlay-inner {
          background: var(--card);
          color: var(--text);
          padding: 1.5rem 1.2rem;
          border-radius: var(--radius);
          max-width: 460px;
          width: 90%;
          box-shadow: 0 4px 20px rgba(0,0,0,0.2);
          text-align: center;
        }
        #rememberPwzOverlay .remember-overlay-inner h3 {
          margin-top: 0;
          margin-bottom: 0.8rem;
          color: var(--primary);
          font-size: 1.4rem;
        }
        #rememberPwzOverlay .remember-overlay-inner p {
          margin: 0 0 1.4rem;
          font-size: 0.95rem;
          line-height: 1.4;
        }
        #rememberPwzOverlay .remember-overlay-buttons {
          display: flex;
          justify-content: center;
          gap: 1rem;
          flex-wrap: wrap;
        }
        #rememberPwzOverlay .remember-yes-btn {
          background: var(--secondary);
          color: #fff;
          border: none;
          border-radius: var(--radius);
          padding: 0.55rem 1.2rem;
          cursor: pointer;
          font: inherit;
          transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        #rememberPwzOverlay .remember-yes-btn:hover {
          background: var(--primary);
          box-shadow: var(--shadow);
        }
        #rememberPwzOverlay .remember-no-btn {
          background: #ffffff;
          color: var(--primary);
          border: 1px solid #d0dede;
          border-radius: var(--radius);
          padding: 0.55rem 1.2rem;
          cursor: pointer;
          font: inherit;
          transition: background 0.2s ease, box-shadow 0.2s ease;
        }
        #rememberPwzOverlay .remember-no-btn:hover {
          background: #f5f9f9;
          box-shadow: var(--shadow);
        }

        /* === Dwukolumnowy układ list testów (GH, OGTT/GnRH, ACTH/TRH) ===
         *
         * Kontenery z testami (np. #ghTestsLeft/#ghTestsRight) mają klasę
         * .half, która nadaje im szerokość 50%.  Jednak domyślnie elementy
         * te są blokowe, przez co układają się pionowo jeden pod drugim.
         * W widoku dwukolumnowym (szerokość ≥ 700 px) ustawiamy dla
         * #modulesWrapper wyświetlanie flex i pozwalamy na zawijanie wierszy.
         * Dzięki temu przyciski modułów (o szerokości 100%) zajmują pełną
         * szerokość, a dwa kontenery testów ustawiają się obok siebie.
         * gap zapewnia odstęp między kolumnami oraz wierszami.  Poszczególne
         * kontenery testów zachowują szerokość 50%, co gwarantuje równe
         * rozdzielenie dostępnej przestrzeni między kolumny. */
        @media (min-width: 700px) {
          #modulesWrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
          }
          /* Upewnij się, że przyciski modułów zajmują pełną szerokość także w
             układzie flex.  Bez tego reguła flex może powodować ich
             zawężenie. */
          #modulesWrapper > div[id$="ButtonWrapper"] {
            flex: 0 0 100%;
            max-width: 100%;
          }
          /* Testy GH/OGTT/ACTH umieszczone w kolumnach powinny zajmować
             połowę szerokości w wierszu.  Używamy calc, aby uwzględnić
             odstęp (gap) pomiędzy kolumnami. */
          #modulesWrapper .gh-tests-left,
          #modulesWrapper .gh-tests-right,
          #modulesWrapper .ogtt-tests-left,
          #modulesWrapper .ogtt-tests-right,
          #modulesWrapper .acth-tests-left,
          #modulesWrapper .acth-tests-right {
            flex: 0 0 calc(50% - 0.5rem);
            max-width: calc(50% - 0.5rem);
          }

          /*
           * W układzie dwukolumnowym przenosimy główne przyciski modułu
           * profesjonalnego do osobnych kolumn: przycisk „Testy w endokrynologii”
           * trafia do lewej kolumny, a przycisk „Leczenie hormonem wzrostu / IGF‑1”
           * do prawej.  Domyślnie style globalne nadają wszystkim przyciskom
           * pełną szerokość (grid‑column: 1 / ‑1).  Poniższa reguła nadpisuje
           * te ustawienia dla konkretnych kontenerów w ramach #modulesWrapper,
           * ustawiając szerokość na 50% z uwzględnieniem odstępu (gap).
           */
          #modulesWrapper #endoButtonWrapper,
          #modulesWrapper #igfButtonWrapper {
            flex: 0 0 calc(50% - 0.5rem);
            max-width: calc(50% - 0.5rem);
          }
          /* Umieść przyciski „Antybiotykoterapia” i „Leczenie bisfosfonianami” w jednym wierszu
             poniżej wiersza głównych przycisków modułu (Endo i IGF‑1).  Nadaj im po 50 % szerokości
             (z uwzględnieniem odstępu) i ustaw kolejność na 2, aby były renderowane razem.
             Dzięki temu w pierwszym wierszu pozostaną przyciski Endo/IGF‑1, a w drugim
             Antybiotykoterapia i Leczenie bisfosfonianami. */
          /*
           * Przyciski „Antybiotykoterapia” i „Leczenie bisfosfonianami” zajmują połowę
           * szerokości wiersza (uwzględniając odstęp) i są renderowane jako drugi
           * wiersz modułu lekarskiego.  Aby móc niezależnie sterować każdym
           * przyciskiem, definiujemy reguły osobno dla każdego kontenera.  Dzięki
           * temu łatwiej jest dostosować wygląd przycisku leczenia bisfosfonianami
           * bez dotykania ustawień przycisku antybiotykoterapii.
           */
          #modulesWrapper #abxButtonWrapper {
            flex: 0 0 calc(50% - 0.5rem);
            max-width: calc(50% - 0.5rem);
            order: 2;
          }
          #modulesWrapper #bisphosButtonWrapper {
            flex: 0 0 calc(50% - 0.5rem);
            max-width: calc(50% - 0.5rem);
            order: 2;
            /* Ustawienia spójne z pozostałymi przyciskami: wycentrowanie
               przycisku i jednakowy margines pionowy */
            justify-content: center;
            margin: 1rem 0;
          }

          /* Domyślnie globalny arkusz stylów ukrywa przycisk Antybiotykoterapia
             (#abxButtonWrapper { display: none !important; }).  Na podstronie DocPro
             przycisk ten powinien być widoczny po pozytywnej weryfikacji numeru PWZ.
             Nadpisujemy więc globalną regułę i wymuszamy jego wyświetlanie.
             Używamy !important, aby przebić wcześniejsze deklaracje. */
          #modulesWrapper #abxButtonWrapper {
            display: flex !important;
          }

          /*
           * Przycisk „Leczenie bisfosfonianami” powinien zachowywać się
           * tak samo jak pozostałe przyciski modułu lekarskiego.  Globalne
           * style nadają elementom w #modulesWrapper pełną szerokość i
           * przypisują im kolumnę grid 1/-1, co w układzie dwukolumnowym
           * sprawia, że przycisk bisfosfonianów wypełnia cały wiersz.
           * Aby uzyskać symetryczny układ 2×2 (Antybiotykoterapia obok
           * Leczenia bisfosfonianami), nadpisujemy te właściwości i
           * dostosowujemy zachowanie do flexboxa.  Ustawiamy display:flex,
           * aby kontener przycisku korzystał z modelu flex i mógł być
           * umieszczany obok innych przycisków.  W media query resetujemy
           * kolumnę grid na auto, dzięki czemu szerokość kontroluje flex,
           * a przycisk zajmuje połowę wiersza podobnie jak pozostałe.
           */
          #modulesWrapper #bisphosButtonWrapper {
            display: flex;
          }
          @media (min-width: 700px) {
            #modulesWrapper #bisphosButtonWrapper {
              grid-column: auto;
            }
          }

          /* Globalny arkusz stylów ustawia kolumnę siatki dla #abxButtonWrapper na 1 / -1,
             co powoduje, że przycisk zajmuje całą szerokość w układzie grid.  Ponieważ
             w tym projekcie korzystamy z flexboxa wewnątrz modulesWrapper, ustawiamy
             grid-column na auto, aby element zachowywał się jak pozostałe przyciski
             i mógł być umieszczany w jednej linii z przyciskiem bisfosfonianów. */
          @media (min-width: 700px) {
            #modulesWrapper #abxButtonWrapper {
              grid-column: auto;
            }
          }

          /* Umieść kalkulator Z‑score w kolejności po przyciskach abx/bisfos, aby
             nie rozdzielał ich na osobne rzędy.  Nadaj mu kolejność 3, dzięki czemu
             pojawi się w kolejnym wierszu. */
          #modulesWrapper #zscoreButtonWrapper {
            order: 3;
          }

          /* Zachowaj naturalną kolejność przycisków w DOM.  Nie
           * modyfikujemy ich właściwości order, ale definiujemy reguły
           * eksplicytnie dla czytelności. */
          #modulesWrapper #endoButtonWrapper { order: 0; }
          #modulesWrapper #igfButtonWrapper  { order: 0; }

          /* When the endocrine test list is toggled, ensure that the
             “Leczenie hormonem wzrostu / IGF‑1” button stays in the same
             row alongside the “Testy w endokrynologii” button.  Without
             an explicit order the new test buttons (GH/OGTT/ACTH) appear
             before the IGF button in the flex flow, pushing it down.  By
             assigning a higher order (1) to all endocrine test wrappers and
             test panels, they are rendered after the main buttons,
             preventing the IGF button from shifting position when the
             endocrine list is expanded. */
          #modulesWrapper #ghButtonWrapper,
          #modulesWrapper #ghTestsLeft,
          #modulesWrapper #ghTestsRight,
          #modulesWrapper #ogttButtonWrapper,
          #modulesWrapper #ogttTestsLeft,
          #modulesWrapper #ogttTestsRight,
          #modulesWrapper #acthButtonWrapper,
          #modulesWrapper #acthTestsLeft,
          #modulesWrapper #acthTestsRight {
            order: 1;
          }
        }
        /*
         * Style dla przycisków wyboru źródła danych w kalkulatorze Z‑score (batch).
         * W kontenerze .zscore-source-buttons nadajemy delikatną ramkę i
         * zaokrąglone narożniki.  Gdy przycisk jest aktywny (klasa .active-toggle),
         * ramka zmienia kolor na turkusowy (zmienna --primary).
         */
        .zscore-source-buttons button {
          /* Neutral wygląd dla przycisków – usuń domyślne wypełnienie
             i kolor tła. Używamy !important, aby nadpisać reguły z innych
             arkuszy (np. motywu Liquid Glass). */
          border: 1px solid var(--lg-border) !important;
          background: transparent !important;
          padding: 0.45rem 1rem;
          border-radius: var(--radius);
          cursor: pointer;
        }
        .zscore-source-buttons button.active-toggle {
          border-color: var(--primary);
        }

        /* === Z‑score batch loading overlay ===
         * This overlay appears when the user starts the Z‑score (batch) calculation.  It dims
         * the page and centers a Lottie animation to give the impression of ongoing
         * processing.  The overlay is hidden by default and shown via JavaScript when
         * the calculation begins. */
        #zscoreLoadingOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          display: none;
          align-items: center;
          justify-content: center;
          background-color: rgba(255, 255, 255, 0.8);
          z-index: 20000;
        }
      </style>
</head>
<!-- Dodajemy klasę "liquid-ios26" bezpośrednio na element <body>,
     aby motyw Liquid Glass był stosowany od samego początku ładowania strony.
     Dzięki temu unikamy krótkiego błysku podstawowych stylów zanim skrypt
     ios26-ui.js dołączy klasę dynamicznie. -->
<body class="liquid-ios26">

<header>
<div class="container">
  <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">
    <img src="logo_vilda.jpeg" alt="Vilda Clinic – strona główna"
         style="max-width:160px;margin-bottom:10px; border-radius:var(--radius);">
  </a>
  <h1>Waga i wzrost</h1>
</div>
  <!-- Nawigacja ułatwiająca przejście do podstrony opisującej aplikację.
       Dodajemy ją przed zamknięciem nagłówka, aby była dostępna zarówno
       dla użytkowników, jak i robotów wyszukiwarek. -->
  <nav class="main-nav" aria-label="Główna nawigacja">
  <ul>
    <!-- Przycisk hamburgera zastępujący link „Strona główna”.
         Po kliknięciu rozwija dodatkowe menu z sekcjami informacyjnymi.
         Składa się z trzech poziomych linii. -->
    <li class="menu-toggle">
      <!-- Ukryty checkbox sterujący otwieraniem i zamykaniem menu.  
           Po zaznaczeniu rozwija pionową listę z linkami. -->
      <input type="checkbox" id="navToggle" class="nav-toggle">
      <label for="navToggle" aria-label="Otwórz menu">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
      </label>
      <!-- Pionowe menu przeniesione wewnątrz elementu li, aby  
           można było sterować jego widocznością za pomocą checkboxa. -->
      <ul id="verticalMenu" class="vertical-menu">
        <!--
          Dodajemy dwie pierwsze pozycje do menu hamburgera: „Zapisz dane” oraz
          „Wczytaj dane”.  Oba elementy zostały przeniesione z sekcji formularza.
          Przyciski mają atrybut title, który zawiera krótkie wyjaśnienie
          kiedy opcja jest aktywna.  Tekst podpowiedzi pojawia się na
          hover/dotknięcie przycisku, gdy jest on wyłączony.
        -->
        <li>
          <!--
            Używamy elementu <a> z rolą „button” zamiast tradycyjnego <button>,
            ponieważ globalne style motywu Liquid Glass modyfikują wszystkie
            przyciski.  Link zachowuje się jak przycisk dzięki atrybutowi
            role="button" oraz zdarzeniom obsługiwanym w JavaScript.  Atrybut
            title podpowiada, dlaczego opcja jest nieaktywna.  Atrybut disabled
            (niestandardowy dla <a>) służy do oznaczania stanu i jest
            wykorzystywany w skryptach i stylach.
          -->
          <a id="saveDataBtn" role="button" disabled href="#"
             data-tip="Aby zapisać dane, wprowadź imię, wiek, wzrost i wagę.">
            Zapisz dane
          </a>
        </li>
        <li>
          <!--
            Link „Wczytaj dane” działa jak przycisk.  Jest dostępny tylko na
            początku sesji; gdy formularz zawiera już informacje, zostaje
            dezaktywowany w JavaScript.  Atrybut title informuje, kiedy
            opcja staje się nieaktywna.
          -->
          <a id="loadDataBtn" role="button" href="#"
             data-tip="Wczytywanie danych jest możliwe tylko na początku sesji, zanim wprowadzisz nowe dane.">
            Wczytaj dane
          </a>
          <!-- Ukryty input obsługujący wybór pliku do wczytania danych -->
          <input type="file" id="fileInput" accept=".json,application/json" style="display:none;">
        </li>
        <!-- Istniejące pozycje informacyjne pozostają bez zmian -->
        <li><a href="/o-aplikacji.html">O aplikacji</a></li>
        <li><a href="/instrukcja.html">Instrukcja</a></li>
        <li><a href="https://www.vildaclinic.pl/kontakt" target="_blank" rel="noopener noreferrer">Kontakt</a></li>
      </ul>
    </li>
    <li><a href="/">Strona główna</a></li>
    <!-- Nowy odnośnik do kalkulatora klirensu. Umieszczamy go w głównej nawigacji,
         aby użytkownicy mieli do niego bezpośredni dostęp. -->
    <li><a href="/kalkulator-klirens.html">Klirens</a></li>
    <!-- Dodatkowa sekcja: kalkulator steroidów. Link prowadzi do strony sterydów,
         umieszczamy go pomiędzy klirensem a materiałami edukacyjnymi, aby
         zachować logiczny porządek nawigacji. -->
    <li><a href="/steroidy.html">Steroidy</a></li>
    <!-- Dotychczasowa zakładka Materiały edukacyjne pozostaje bez zmian -->
    <li><a href="/materialy-edukacyjne.html">Materiały edukacyjne</a></li>
  </ul>
</nav>
</header>

<div class="desktop-layout">
  <!-- Lewy sidebar – menu DocPro na desktopie -->
  <aside class="sidebar">
    <nav class="sidebar-nav" aria-label="Nawigacja boczna">
      <ul>
        <!-- 1. Zapisz dane -->
        <li>
          <a id="saveDataBtnSidebar" href="#" role="button" data-tip="Aby zapisać dane, wprowadź imię, wiek, wzrost i wagę."
            aria-disabled="true">
            <span class="sidebar-icon" data-lucide="save"></span>
            <span class="sidebar-label">Zapisz dane</span>
          </a>
        </li>
      
        <!-- 2. Wczytaj dane -->
        <li>
          <a id="loadDataBtnSidebar" href="#" role="button"
            data-tip="Wczytywanie danych jest możliwe tylko na początku sesji, zanim wprowadzisz nowe dane.">
            <span class="sidebar-icon" data-lucide="folder-open"></span>
            <span class="sidebar-label">Wczytaj dane</span>
          </a>
          <input type="file" id="fileInputSidebar" accept=".json,application/json" style="display:none;">
        </li>
      
        <!-- 3. Strona główna -->
        <li>
          <a href="/">
            <span class="sidebar-icon" data-lucide="home"></span>
            <span class="sidebar-label">Strona główna</span>
          </a>
        </li>
      
        <!-- 4. DocPro -->
        <li>
          <a href="/docpro.html">
            <span class="sidebar-icon" data-lucide="stethoscope"></span>
            <span class="sidebar-label">DocPro</span>
          </a>
        </li>
      
        <!-- 5. Klirens -->
        <li>
          <a href="/kalkulator-klirens.html">
            <span class="sidebar-icon" data-lucide="droplets"></span>
            <span class="sidebar-label">Klirens</span>
          </a>
        </li>
      
        <!-- 6. Steroidy -->
        <li>
          <a href="/steroidy.html">
            <span class="sidebar-icon" data-lucide="pill"></span>
            <span class="sidebar-label">Steroidy</span>
          </a>
        </li>
      
        <!-- 7. Materiały edukacyjne -->
        <li>
          <a href="/materialy-edukacyjne.html">
            <span class="sidebar-icon" data-lucide="book-open"></span>
            <span class="sidebar-label">Materiały edukacyjne</span>
          </a>
        </li>
      
        <!-- 8. Instrukcja -->
        <li>
          <a href="/instrukcja.html">
            <span class="sidebar-icon" data-lucide="file-text"></span>
            <span class="sidebar-label">Instrukcja</span>
          </a>
        </li>
      
        <!-- 9. O aplikacji -->
        <li>
          <a href="/o-aplikacji.html">
            <span class="sidebar-icon" data-lucide="info"></span>
            <span class="sidebar-label">O aplikacji</span>
          </a>
        </li>
      
        <!-- 10. Kontakt -->
        <li>
          <a href="https://www.vildaclinic.pl/kontakt" target="_blank" rel="noopener noreferrer">
            <span class="sidebar-icon" data-lucide="mail"></span>
            <span class="sidebar-label">Kontakt</span>
          </a>
        </li> </ul>
    </nav>
  </aside>

  <!-- Prawa kolumna: treść strony DocPro -->
  <div class="main-content">
    <!-- Główny kontener treści.  Pozostawiamy globalne ograniczenie max-width:960 px,
         aby zawartość nie wychodziła poza obszar menu. -->
    <div class="container">
<form id="calcForm" onsubmit="return false;">
  <!-- Sekcja danych użytkownika: w module DocPro karta powinna zajmować lewą kolumnę
       w układzie dwukolumnowym, identycznie jak na stronie głównej. -->
  <div id="userSection" class="half">
    <!-- Karta „Dane użytkownika” ma identyczny układ jak na stronie głównej serwisu.
         Zachowujemy legendę i pole na imię i nazwisko oraz używamy tych samych identyfikatorów,
         aby dane były synchronizowane pomiędzy stronami. -->
    <fieldset class="user-card"><legend>Dane użytkownika</legend>
      <!-- Zmodyfikowane pole wieku: lata oraz opcjonalnie miesiące -->
      <!-- Nowe pole imię i nazwisko -->
      <label>Imię i&nbsp;Nazwisko:
        <input type="text" id="name">
      </label>
      <label>Wiek (lata):
        <!-- Pozwalamy podać wiek w latach od 0 do 130; lata są wymagane -->
        <input type="number" id="age" min="0" max="130" oninput="debouncedUpdate()" required></label>
      <!-- Nowe pole na wiek w miesiącach; zakres 1–11, opcjonalne -->
      <label>Wiek (miesiące – opcjonalnie):
        <!--
          Umożliwiamy wpisywanie jedynie wartości od 1 do 11 (pełne miesiące).
          Pole pozostawione puste jest interpretowane jako brak dodatkowych miesięcy.
          Ustawiamy atrybut step="1" aby wymusić podawanie tylko liczb całkowitych.
        -->
        <input type="number" id="ageMonths" min="1" max="11" step="1" oninput="debouncedUpdate()"></label>
      <label>Płeć:
        <select id="sex" onchange="debouncedUpdate()">
          <option value="M">Mężczyzna</option>
          <option value="F">Kobieta</option>
        </select></label>
      <label>Waga (kg):
        <!-- Dostosowujemy zakres do niemowląt: mniejsza waga i możliwość wpisywania wartości z dokładnością do 0.1 kg -->
        <input type="number" id="weight" min="2" max="300" step="0.1" oninput="debouncedUpdate()" required></label>
      <label>Wzrost (cm):
        <!-- Dostosowujemy zakres do niemowląt: niższy wzrost i możliwość wpisywania wartości z dokładnością do 0.1 cm -->
        <input type="number" id="height" min="45" max="250" step="0.1" oninput="debouncedUpdate()" required></label>
        <!-- Komunikat informujący o wczytaniu danych. Jest domyślnie ukryty, a pojawia się dopiero po
             prawidłowym wczytaniu pliku JSON. Umieszczamy go tuż pod polem wzrostu,
             zgodnie z wymaganiami użytkownika, aby znajdował się pomiędzy polem wzrost
             a przyciskiem „Wczytaj dane”. Kolor i pogrubienie odpowiadają palecie motywu. -->
        <div id="loadDataMessage" style="display:none;color:var(--primary);font-weight:600;text-align:center;margin-top:0.5rem;">
          Dane zostały wczytane prawidłowo. Wprowadź nowe dane, aby zobaczyć najnowsze wyniki.
        </div>
        <!-- Przyciski usuwające wszystkie dane użytkownika umieszczamy pod ostatnim polem formularza. -->
        <div style="text-align:center; margin-top:1rem;">
          <!-- Pozostawiamy tylko przycisk czyszczący pola w tej sekcji.  Opcje
               zapisywania i wczytywania danych są przeniesione do menu hamburgera powyżej. -->
          <button type="button" id="clearAllDataBtn">Wyczyść wszystkie pola</button>
        </div>
        <!-- Przełącznik sposobu animacji ostrzeżeń (ciągły vs. jednorazowy puls) -->
        <div class="text-center" style="margin:.25rem 0 .75rem 0; display:none;">
          <label style="font-weight:600;">
            <input type="checkbox" id="pulseOnce"> Jednorazowa animacja ostrzeżeń (2&nbsp;s)
          </label>
        </div>
    </fieldset>
  </div>

  <!-- Pole dla lekarzy: kontrolka wejścia do modułu lekarskiego oraz weryfikacja numeru PWZ
       Umieszczamy sekcję lekarską w prawej kolumnie układu dwukolumnowego, tak jak na stronie głównej. -->
  <div id="doctorSection" class="half">
    <!-- Przeniesione podsumowanie poprzednich pomiarów nad sekcję modułu lekarskiego.
         Karta jest domyślnie ukryta, a jej elementy są uporządkowane tutaj,
         dzięki czemu pojawia się przed przyciskiem „Przejdź do modułu lekarskiego”. -->
    <div id="prevSummaryWrap" aria-live="polite" style="display:none; width:100%;">
      <div id="prevSummaryCard" class="card summary-card" style="display:none;">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <h3 style="margin:0;">Ostatni pomiar</h3>
          <!-- przycisk ukrywania karty pozostaje w DOM, ale jest domyślnie niewidoczny,
               aby karta nie zwijała się automatycznie -->
          <button type="button" id="hidePrevSummary" class="secondary-btn" style="font-size:0.9rem; display:none;">Ukryj tę kartę</button>
        </div>
        <div id="prevSummaryContent" class="summary-grid" style="margin-top:0.6rem;"></div>
      </div>
      <!-- Przycisk rozwijający podsumowanie. Ukrywamy go na stałe, ponieważ karta jest zawsze widoczna. -->
      <button type="button" id="togglePrevSummary" class="primary-btn" style="display:none; margin-top:0.5rem; width:100%;">
        Podsumowanie poprzednich pomiarów
      </button>
    </div>

    <!-- Karta „Podsumowanie wyników” – generowana dynamicznie w JS.
         W normalnym trybie (gdy nie wczytano poprzedniego pomiaru) karta
         pojawia się w prawej kolumnie obok danych użytkownika. Gdy wczytano
         poprzedni pomiar, karta zostanie przeniesiona pod obie kolumny i
         podzielona na dwie kolumny o równej szerokości. -->
    <div id="currentSummaryWrap" style="display:none;">
      <div id="currentSummaryCard" class="card summary-card current-summary-card" style="display:none;">
        <h3 style="margin:0;">Podsumowanie wyników</h3>
        <div id="currentSummaryContent" class="summary-content"></div>
      </div>
    </div>

    <!-- Dedykowany kontener na część lekarską. Na podstronie DocPro nie wyświetlamy
         zachęty do przejścia do modułu, lecz od razu prosimy o wpisanie numeru PWZ. -->
    <div id="doctorContainer">
      <!-- Ukryty checkbox oznaczający, że użytkownik jest lekarzem. Jest zaznaczony domyślnie
           i ukryty, aby moduł lekarski został aktywowany automatycznie po załadowaniu strony. -->
      <input type="checkbox" id="isDoctor" class="doctor-checkbox" checked style="display:none;" />
      <!-- Komunikat informujący użytkownika, że aby uzyskać dostęp do zawartości serwisu,
           musi wpisać numer prawa wykonywania zawodu lekarza. -->
      <p class="doctor-info" style="font-size:0.95rem; margin-top:0.7rem;">
        Aby zobaczyć zawartość serwisu wpisz numer prawa wykonywania zawodu lekarza
      </p>
    </div>
    <!-- Kontener na pole z numerem PWZ, ukryty do momentu zaznaczenia checkboxa -->
    <div id="pwzContainer" style="display:none; margin-top:0.7rem;">
      <label style="display:block; font-size:0.95rem;">
        Wpisz numer prawa wykonywania zawodu:
        <!--
          Zmieniono placeholder pola numeru PWZ tak, aby nie wyświetlał przykładowego
          numeru „5425740”. Użytkownik wprowadza tu 7‑cyfrowy numer prawa
          wykonywania zawodu, dlatego pozostawiamy pusty placeholder. Jeśli w
          przyszłości chcesz ponownie dodać opis, użyj neutralnego tekstu
          (np. „Wpisz numer PWZ”).
        -->
        <input type="text" id="pwzNumber" placeholder="" maxlength="7" pattern="\d{7}" autocomplete="off" style="margin-top:0.4rem;">
      </label>
      <div id="pwzError" style="color: var(--danger); margin-top:0.5rem; display:none; font-size:0.95rem;">
        Nieprawidłowy numer PWZ
      </div>
    </div>
    <!-- Moduł profesjonalny dostępny po pozytywnej weryfikacji numeru PWZ -->
    <div id="professionalModule" class="card" style="margin-top:1rem; display:none;">
      <h3 style="margin-top:0;">Moduł profesjonalny</h3>
      <!-- W tym akapicie umieszczamy informację dla lekarzy o charakterze edukacyjnym modułu. -->
      <!-- Do komunikatu w module profesjonalnym dodajemy klasę, która pozwala wygodnie sterować stylem z poziomu CSS. -->
      <p class="professional-message">Informacje prezentowane w tym module mają charakter wyłącznie edukacyjny i są przeznaczone dla lekarzy. Nie powinny one stanowić podstawy do podejmowania decyzji diagnostycznych ani terapeutycznych.</p>

      <!-- Sekcja testów stymulacyjnych GH została przeniesiona poza moduł profesjonalny. -->
    </div>
  </div>

  <!-- Pełno-szerokościowy pojemnik na kartę podsumowania wyników.  
       Używany w sytuacji, gdy widoczna jest karta „Ostatni pomiar”. -->
  <div id="currentSummaryFullWrap" style="display:none;"></div>
  <!-- Główne przyciski modułu lekarskiego – pojawiają się po pozytywnej weryfikacji numeru PWZ.
       Przycisk „Testy w endokrynologii” będzie służyć do rozwijania listy testów GH/OGTT/ACTH,
       a przycisk „Leczenie hormonem wzrostu / IGF-1” otworzy listę dodatkowych opcji IGF-1.
       Domyślnie oba przyciski są ukryte. -->
  <!-- Nowy przycisk: Antybiotykoterapia – sekcja kalkulatora dawek antybiotyków.
       Przycisk ten powinien pojawiać się wyłącznie po pozytywnej weryfikacji numeru PWZ
       (użytkownicy z prawem wykonywania zawodu). Sekcja ta zostanie osadzona nad
       przyciskiem „Testy w endokrynologii”.
       Domyślnie przycisk jest ukryty. -->
  <!-- Na stronie DocPro przycisk Antybiotykoterapia jest domyślnie widoczny,
       dzięki czemu lekarz ma bezpośredni dostęp do kalkulatora dawek po weryfikacji numeru PWZ. -->
  <!-- Kontener na przyciski modułów lekarskich i listy testów.  W widoku dwukolumnowym
       zajmuje całą szerokość formularza (grid-column:1 / -1), dzięki czemu wszystkie
       elementy pojawiają się w jednym bloku pod sekcją lekarską. -->
  <div id="modulesWrapper" style="grid-column:1 / -1;">
  <!-- Po pozytywnej weryfikacji numeru PWZ przycisk Antybiotykoterapia powinien być widoczny.
       Usuwamy domyślne ukrycie (display:none) w HTML, aby przycisk mógł zostać
       pokazany po włączeniu modułu. Widoczność nadal będzie kontrolowana w JS. -->
  <div id="abxButtonWrapper">
    <button type="button" id="toggleAbxTherapy">Antybiotykoterapia</button>
  </div>
  <div id="endoButtonWrapper" style="display:none;">
    <button type="button" id="toggleEndoTests">Testy w endokrynologii</button>
  </div>
  <!-- Przyciski testów GH/OGTT/ACTH znajdują się poniżej i będą pokazywane po kliknięciu w powyższy przycisk. -->
  <!-- Kontener na przycisk uruchamiający testy stymulacyjne GH. Domyślnie ukryty;
       jest pokazywany dopiero po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ghButtonWrapper" style="display:none;">
    <button type="button" id="toggleGhTests">Testy stymulacyjne oceniające wydzielanie GH</button>
  </div>
  <!-- Dodatkowe kolumny z testami GH. Są ukryte, dopóki użytkownik nie kliknie przycisku. -->
  <div class="half gh-tests-left" id="ghTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z klonidyną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z glukagonem</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half gh-tests-right" id="ghTestsRight">
    <div class="card gh-test-card">
      <strong>Test z insuliną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z argininą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z L‑Dopą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- === NOWE TESTY: OGTT / GnRH i ACTH / TRH === -->
  <!-- Kontener na przycisk uruchamiający testy OGTT / GnRH. Domyślnie ukryty;
       pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ogttButtonWrapper" style="display:none;">
    <button type="button" id="toggleOgttTests">Test OGTT / Test z GnRH/LHRH</button>
  </div>
  <!-- Kolumny dla testów OGTT i GnRH/LHRH -->
  <div class="half ogtt-tests-left" id="ogttTestsLeft">
    <div class="card gh-test-card">
      <strong>Test OGTT</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half ogtt-tests-right" id="ogttTestsRight">
    <div class="card gh-test-card">
      <strong>Test z GnRH/LHRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Kontener na przycisk uruchamiający testy ACTH / TRH. Domyślnie ukryty
       i pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="acthButtonWrapper" style="display:none;">
    <button type="button" id="toggleActhTests">Test z dużą dawką ACTH / Test z TRH</button>
  </div>
  <!-- Kolumny dla testów ACTH i TRH -->
  <div class="half acth-tests-left" id="acthTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z dużą dawką ACTH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Podaj wiek i wagę, aby obliczyć dawkę ACTH.</p>
    </div>
  </div>
  <div class="half acth-tests-right" id="acthTestsRight">
    <div class="card gh-test-card">
      <strong>Test z TRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Przycisk otwierający listę leczenia hormonem wzrostu / IGF-1.  
       Domyślnie ukryty; pojawi się po pozytywnej weryfikacji numeru PWZ i pozostanie pod testami GH/OGTT/ACTH. -->
  <div id="igfButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgfTests" class="igf-btn">Leczenie hormonem wzrostu / IGF-1</button>
  </div>
  <!-- Podprzyciski IGF-1 (domyślnie ukryte; pokazują się po kliknięciu w „Leczenie hormonem wzrostu / IGF-1”). -->
  <div id="snpButtonWrapper" style="display:none;">
    <button type="button" id="toggleSnp" class="igf-btn">SNP</button>
  </div>
  <div id="turnerButtonWrapper" style="display:none;">
    <button type="button" id="toggleTurner" class="igf-btn">Zespół Turnera</button>
  </div>


  <!-- Przycisk otwierający moduł leczenia bisfosfonianami.
       Umieszczony bezpośrednio po przycisku Turnera, aby w układzie dwukolumnowym
       wyświetlał się w prawej kolumnie pod przyciskiem „Leczenie hormonem wzrostu / IGF‑1”. -->
  <div id="bisphosButtonWrapper" style="display:none;">
    <button type="button" id="toggleBisphos" class="igf-btn">Leczenie bisfosfonianami</button>
  </div>
  <!-- Karta leczenia bisfosfonianami w obrębie modulesWrapper.
       Umieszczamy ją bezpośrednio po przycisku bisfosfonianów, aby
       rozwijana karta pojawiała się tuż pod przyciskiem, a przycisk
       kalkulatora Z‑score został przesunięty poniżej tej karty. -->
  <div id="bisphosCard" class="card" style="display:none;">
    <h2 style="text-align:center;">Leczenie bisfosfonianami</h2>
    <p style="text-align:center; font-size:0.9rem; margin-top:0.4rem;">Wprowadź wagę w sekcji „Dane użytkownika”, a następnie wybierz poniższe parametry, aby obliczyć dawkę bisfosfonianu.</p>
    <div style="display:flex;flex-wrap:wrap;gap:1rem;justify-content:center;margin-top:0.8rem;">
      <!-- Dodajemy pole wyboru wskazania, aby lekarz mógł określić powód leczenia.
           Wybór wskazania wpływa na proponowaną dawkę i schemat podawania. -->
      <label>Wskazanie:<br>
        <select id="bisphosIndication">
          <option value="oi">Osteogenesis imperfecta (OI)</option>
          <option value="osteoporoza">Osteoporoza (idiopatyczna/wtórna)</option>
          <option value="crmo">CRMO (nawracające zapalenie kości)</option>
        </select>
      </label>
      <label>Preparat:<br>
        <select id="bisphosDrug">
          <option value="">– Wybierz lek –</option>
          <option value="pamifos">Pamifos (pamidronian)</option>
          <option value="zomikos">Zomikos (kwas zoledronowy)</option>
        </select>
      </label>
      <label>Nr podania:<br>
        <select id="bisphosDoseNumber">
          <option value="first">Pierwsza dawka</option>
          <option value="subsequent">Kolejna dawka</option>
          <option value="maintenance">Terapia podtrzymująca</option>
        </select>
      </label>
      <!-- Pole czasu terapii (w miesiącach) wykorzystywane jest dla leków o długim
           okresie działania (np. zoledronian), aby ustalić zmianę odstępu w dawkowaniu.
           Zostanie ukryte, gdy nie jest potrzebne. -->
      <label>Złamania od ostatniej dawki:<br>
        <select id="bisphosFracture">
          <option value="no">Nie</option>
          <option value="yes">Tak</option>
        </select>
      </label>
    </div>
    <!-- Wyniki bisfosfonianów wyświetlane są wyrównane do lewej. -->
    <div id="bisphosResult" class="result-box" style="margin-top:1rem; font-size:1.2rem; text-align:left;"></div>
  </div>
  <div id="pwsButtonWrapper" style="display:none;">
    <button type="button" id="togglePws" class="igf-btn">Zespół PWS</button>
  </div>
  <div id="sgaButtonWrapper" style="display:none;">
    <button type="button" id="toggleSga" class="igf-btn">SGA</button>
  </div>
  <div id="igf1ButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgf1" class="igf-btn">IGF-1</button>
  </div>
  <!-- Nowy przycisk do otwierania kalkulatora Z‑score w trybie profesjonalnym -->
  <div id="zscoreButtonWrapper" style="display:none;">
    <button type="button" id="toggleZscore" class="igf-btn">Kalkulator Z‑score</button>
  </div>
  <!-- Miejsce pozostawione po przeniesionym przycisku leczenia bisfosfonianami -->
  </div><!-- koniec modulesWrapper -->
</form>
<div id="errorBox"></div>
<!-- Kontener na mobilne umiejscowienie przycisku przejścia do modułu lekarskiego.
     Ten element pozostaje pusty w widoku dwukolumnowym i jest używany
     wyłącznie przy wąskim oknie, gdy formularz zajmuje całą szerokość.
     Wówczas sekcja z napisem „Przejdź do modułu lekarskiego” wraz z
     podtytułem i checkboxem zostanie tutaj przeniesiona. -->
<div id="doctorMobileContainer"></div>
    <!-- Kontener dla modułu lekarskiego w widoku desktop – umieszczamy go pod kartami,
         aby sekcja „Przejdź do modułu lekarskiego” i pole numeru PWZ były
         wyśrodkowane poniżej kart.  W trybie mobilnym kontener ten jest
         ukrywany w JS. -->
    <div id="doctorBottom" class="doctor-bottom-container"></div>
    <!-- Nowy kalkulator Z‑score (batch) – umożliwia obliczenie wartości Z‑score dla wielu pacjentów z pliku XLSX -->
    <div id="zscoreCard" class="card" style="display:none;">
      <h2 style="text-align:center;">Kalkulator Z‑score (batch)</h2>
      <!--
        Przykładowe pliki i instrukcja obsługi: użytkownik może pobrać dwa gotowe arkusze
        demonstrujące prawidłowy układ kolumn wymagany przez aplikację.  Kolumny powinny
        nosić nazwy: „Lp.” lub „Pacjent” (numer porządkowy lub imię i nazwisko),
        „Płeć” (M/K), „Data urodzenia” (w formacie YYYY‑MM‑DD), „waga (kg)” oraz „wzrost (cm)”.
      -->
      <!-- Instrukcja dla użytkownika korzystającego z kalkulatora Z‑score (batch).
           Aby była bardziej zrozumiała, dzielimy ją na dwa zdania i zwiększamy
           rozmiar czcionki.  Tekst jest wyśrodkowany, dzięki czemu odróżnia się
           wizualnie od pozostałych elementów formularza. -->
      <p style="text-align:center; font-size:1.15rem; margin-top:0.8rem; line-height:1.4;">
        Przygotuj arkusz Excel (.xlsx) z kolumnami: imię i nazwisko (lub numer porządkowy), płeć (M/K),
        data urodzenia, waga (kg) i wzrost (cm).<br>
        Upewnij się, że liczba wierszy nie przekracza 250. Następnie wybierz odpowiedni zestaw
        danych (Palczewska lub OLAF) i kliknij „Oblicz Z‑score”.
      </p>
      <p style="text-align:center; margin-top:0.5rem;">
        <a href="zscore_przyklad_palczewska.xlsx" download>Przykładowy plik Palczewska (XLSX)</a>
        &nbsp;|&nbsp;
        <a href="zscore_przyklad_olaf.xlsx" download>Przykładowy plik OLAF (XLSX)</a>
      </p>
      <div class="flex zscore-source-buttons" style="gap:1rem; margin-top:0.6rem; justify-content:center;">
        <!-- Przyciski wyboru źródła danych nie dziedziczą stylu .igf-btn.
             Dzięki temu mogą pozostać neutralne (przezroczyste tło) i
             jedynie zmieniać kolor obramowania po wybraniu (klasa .active-toggle). -->
        <button type="button" id="btnZscorePalczewska">Dane Palczewska</button>
        <button type="button" id="btnZscoreOlaf" class="active-toggle">Dane OLAF</button>
      </div>
      <input type="file" id="zscoreFileInput" accept=".xlsx,.xls" style="margin-top:0.8rem;">
      <button type="button" id="computeZscoreBatch" class="igf-btn" style="margin-top:0.8rem;">Oblicz Z‑score</button>
      <div id="zscoreMessage" style="margin-top:0.8rem; color: var(--danger); font-weight:600;"></div>
    </div>

  <div id="results" class="grid-two">
    <!-- Lewa kolumna: karta BMI oraz sekcja obliczeń dla dzieci z zespołem Downa
         Opakowujemy kartę BMI i blok DS wspólnym kontenerem, aby w układzie
         dwukolumnowym oba te elementy trafiły do tej samej kolumny. W układzie
         jednokolumnowym zachowana jest kolejność DOM: najpierw karta BMI,
         następnie sekcja DS. -->
    <div id="leftColumnWrap" class="left-column">
      <div class="card" id="bmiCard">
    <h2 style="text-align:center;">Centyle, BMI &amp; Basal Metabolic Rate</h2>
    <!-- Nowy przełącznik trybu wyników: Wyniki standardowe / Wyniki profesjonalne
         Umieszczamy go bezpośrednio pod nagłówkiem karty, aby użytkownik
         mógł łatwo przełączać się między trybem standardowym (domyślnym)
         a profesjonalnym. W trybie standardowym ukrywane są obliczenia
         Z‑score dla wagi, wzrostu i BMI. W trybie profesjonalnym
         wyświetlane są pełne wyniki wraz z wartościami Z‑score. -->
    <div id="resultsModeToggleContainer" class="toggle-wrap">
      <span class="label-left">Wyniki standardowe</span>
      <label class="switch">
        <input type="checkbox" id="resultsModeToggle">
        <span class="slider"></span>
      </label>
      <span class="label-right">Wyniki profesjonalne</span>
    </div>
    <!-- Adnotacja informująca, że dla dzieci <2 lat preferowanym wskaźnikiem jest waga/długość.  
         Umieszczamy ją bezpośrednio pod nagłówkiem karty tak, aby pojawiała się pomiędzy etykietą a wynikami.
         Właściwości wyglądu (kolor i rozmiar) są definiowane w pliku CSS; w stylu pozostawiamy jedynie display.
    -->
    <div id="wflReminderBMI" class="wfl-reminder" style="display:none;"></div>
    <div id="bmrInfo"></div>
    <!-- OLAF / WHO Toggle (poprawiony) -->
    <!-- Nowy trójpozycyjny suwak wyboru źródła danych (Palczewska/OLAF/WHO).
         Zastępuje dotychczasowy dwupozycyjny przełącznik. Umożliwia użytkownikowi
         wybranie jednego z trzech zestawów danych, przy czym OLAF pozostaje
         domyślnym wyborem dla dzieci ≥3 lat, a Palczewska dla niemowląt.
         Każdy segment jest przyciskiem radiowym; zaznaczony segment jest podświetlony.
    -->
    <div id="dataToggleContainer" class="data-source-toggle">
      <label>
        <input type="radio" name="dataSource" id="sourcePalczewska" value="PALCZEWSKA">
        <span>Palczewska</span>
      </label>
      <label>
        <input type="radio" name="dataSource" id="sourceOlaf" value="OLAF" checked>
        <span>OLAF</span>
      </label>
      <label>
        <input type="radio" name="dataSource" id="sourceWho" value="WHO">
        <span>WHO</span>
      </label>
    </div>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMI</strong> (Body Mass Index) to wskaźnik masy ciała obliczany jako
      stosunek masy (kg) do kwadratu wzrostu (m²). Pomaga ocenić, czy Twoja masa
      ciała jest prawidłowa, z niedowagą, nadwagą czy otyłością.
    </p>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMR</strong> (Basal Metabolic Rate) to ilość energii, jaką Twoje ciało zużywa w spoczynku
      – kalorie niezbędne na podstawowe procesy życiowe (oddychanie, krążenie, termoregulacja).
    </p>

    <!-- Wyśrodkowany przycisk do wygenerowania siatek centylowych wzrostu i wagi.  -->
    <div style="text-align:center;margin-top:1.2rem;">
      <!-- Ukryj przycisk generowania siatki centylowej w karcie "Centyle, BMI & Basal Metabolic Rate" -->
      <button type="button" id="generateCentileChart" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:none;">
        Generuj siatkę centylową
      </button>
    </div>

    <!-- Ukryty kontener na elementy generowane podczas tworzenia siatki centylowej.  
         Canvasy są tworzone dynamicznie w JS, a następnie konwertowane do obrazu.
         Kontener jest ukryty, aby nie wpływać na layout strony. -->
    <div id="centileCanvasContainer" style="display:none;"></div>
  </div>

      <!-- Placeholder usuniętego kontenera zaawansowanych obliczeń wzrostowych – zostanie on wstawiony w innym miejscu. -->
      <!-- Sekcja obliczeń DS: przycisk oraz karta z wynikami. Umieszczamy ją w
           kontenerze lewej kolumny pod kartą BMI. Sekcja jest początkowo
           ukryta; jej widoczność kontroluje JS w zależności od wieku. -->
      <!-- Moduł obliczania ciśnienia tętniczego u dzieci (RR)
           Karta z polami na ciśnienie skurczowe i rozkurczowe oraz wynikiem centylowym.
           Pozycjonujemy ją w lewej kolumnie powyżej sekcji obliczeń dla dzieci z zespołem Downa. -->
      <div id="bpCard" class="card">
        <h2 style="text-align:center;">Ciśnienie tętnicze u&nbsp;dzieci</h2>
        <!-- Przełącznik wyboru normy OLAF/NHBPEP dla ciśnienia. Wyświetlany jest tylko
             dla wieku 7–18 lat. Domyślnie pozycja niezaznaczona oznacza OLAF, zaznaczona – NHBPEP. -->
        <div id="bpToggleContainer" class="toggle-wrap" style="display:none;">
          <span class="label-left">OLAF 2010 Polska</span>
          <label class="switch">
            <input type="checkbox" id="bpDataToggle">
            <span class="slider"></span>
          </label>
          <span class="label-right">NHBPEP 4th Report</span>
        </div>
        <!-- Pola na wprowadzenie ciśnienia skurczowego i rozkurczowego.
             Umieszczamy je obok siebie w układzie elastycznym z niewielkim odstępem. -->
        <div class="bp-inputs" style="display:flex;flex-wrap:wrap;gap:.6rem;justify-content:center;">
          <label>Ciśnienie skurczowe (mm&nbsp;Hg):
            <input type="number" id="bpSystolic" min="40" max="200" step="1">
          </label>
          <label>Ciśnienie rozkurczowe (mm&nbsp;Hg):
            <input type="number" id="bpDiastolic" min="20" max="140" step="1">
          </label>
        </div>
        <!-- Kontener na wynik – wartości centylowe oraz klasyfikację. Początkowo pusty. -->
        <div id="bpResult" class="result-box" style="margin-top:.6rem;"></div>
      </div>

      <!-- Nowy moduł: Obwód głowy i klatki piersiowej.  
           Ta karta umożliwia ocenę centylową obwodu głowy oraz klatki piersiowej na podstawie siatek Instytutu Matki i Dziecka.
           Umieszczamy ją w lewej kolumnie bezpośrednio pod kartą ciśnienia tętniczego,
           ale przed sekcją obliczeń dla dzieci z zespołem Downa.  
           Całość jest ukryta w kartcie, która rozwija się po kliknięciu przycisku. -->
      <div id="circSection" style="margin-top:1rem;">
        <button type="button" id="toggleCircSection"
          style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
          Obwód głowy i klatki piersiowej
        </button>
        <div id="circCard" class="card" style="display:none;margin-top:1rem;">
          <h2 style="text-align:center;">Obwód głowy i klatki piersiowej</h2>
          <!-- Pola do wprowadzenia obwodu głowy i klatki piersiowej.  
               Użytkownik może wpisać jeden lub oba pomiary; wyniki pojawią się odpowiednio poniżej. -->
          <div class="circ-inputs" style="display:flex;flex-wrap:wrap;gap:.6rem;justify-content:center;">
            <label>Obwód głowy (cm):
              <input type="number" id="headCircumference" min="30" max="60" step="0.1">
            </label>
            <label>Obwód klatki piersiowej (cm):
              <input type="number" id="chestCircumference" min="30" max="80" step="0.1">
            </label>
          </div>
          <!-- Wyniki dla obwodu głowy i klatki piersiowej.  
               Elementy są wypełniane dynamicznie przez circumference_module.js. -->
          <div id="circHeadResult" class="result-box"></div>
          <div id="circChestResult" class="result-box"></div>
        </div>
      </div>

      <div id="downSyndromeSection" style="display:none;">
        <button type="button" id="toggleDownSyndrome" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
          Obliczenia dla dzieci z zespołem Downa
        </button>
        <div id="downSyndromeCard" class="card" style="display:none; margin-top:1rem;">
          <h2 style="text-align:center;">Obliczenia dla dzieci z&nbsp;zespołem Downa</h2>
          <div id="dsPercentiles" class="result-box"></div>
          <!-- Przyciski generowania siatki DS: umieszczamy go bezpośrednio pod sekcją wyników,
               zanim pojawi się pole obwodu głowy. Przyjemny układ z wyśrodkowaniem oraz
               odstępem górnym spójny z innymi przyciskami w aplikacji. -->
          <div class="text-center" style="margin-top:.6rem;">
            <button type="button" id="generateDsCentileChart">Generuj siatkę DS</button>
          </div>
          <label style="display:block;margin-top:.6rem;">Obwód głowy (cm):
            <input type="number" id="headCircumDS" min="25" max="60" step="0.1">
          </label>
          <div id="headCircumResultDS" class="result-box" style="display:none;margin-top:.5rem;"></div>
        </div>
      </div>
    </div><!-- /#leftColumnWrap -->


  <!-- Kontener grupujący kartę Wskaźnika Cole'a i drogę do normy BMI -->
    <!-- Prawa kolumna: kontener z kartami WFL, Cole'a, WHR, itp. Pozostaje
         niezmieniona. -->
    <div id="normWrapper" class="norm-wrapper">
    <!-- Nowa karta: wskaźnik waga do długości/wzrostu (WFL).  
         W układzie jednokolumnowym pojawia się nad kartą wskaźnika Cole’a,  
         w układzie dwukolumnowym po prawej stronie również nad kartą Cole’a.  
         Elementy w środku są wypełniane dynamicznie w JS. -->
    <div class="card" id="wflCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik waga do długości/wzrostu (WFL)</h2>
      <!-- W tej sekcji JS wstawia obliczony Z‑score oraz krótką informację o wyniku. -->
      <div id="wflInfo" class="result-box"></div>
      <!-- Krótkie wyjaśnienie lub interpretacja wyniku wskaźnika WFL.  
           Używamy tej samej klasy co w przypadku wskaźnika Cole’a, aby zachować spójny wygląd. -->
      <p id="wflExplanation" class="cole-explanation"></p>
      <!-- Tabela norm dla wskaźnika waga/wzrost; wypełniana w JS. -->
      <div id="wflNormTable" style="display:none;"></div>
    </div>

    <!-- Sekcja podsumowania metabolicznego.  
         Pojawia się, gdy użytkownik uzupełni minimalny zestaw danych (wiek, waga, wzrost).  
         Przycisk stylistycznie odpowiada przyciskowi zaawansowanych obliczeń wzrostowych. -->
    <div id="metabolicSummarySection" style="margin-top:1rem; display:none;">
      <!-- Zmiana etykiety przycisku na bardziej opisową zgodnie z wymaganiem użytkownika.
           Użytkownik może kliknąć przycisk, aby skopiować podsumowanie wyników do schowka. -->
      <button type="button" id="metabolicSummaryBtn" data-metabolic-summary-btn
        style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
        Podsumowanie wyników - kliknij i skopiuj
      </button>
    </div>
    <!-- Karta Wskaźnika Cole'a – wypełniana dynamicznie w JS -->
    <div class="card" id="coleCard" style="display:none;">
      <!-- Wyśrodkowujemy nagłówek karty wskaźnika Cole'a poprzez style inline -->
      <h2 style="text-align:center;">Wskaźnik Cole'a</h2>
      <!-- Adnotacja Amerykańskiej Akademii Pediatrii; ukryta domyślnie.  
           Umieszczamy ją bezpośrednio pod nagłówkiem, dzięki czemu pojawi się
           pod etykietą karty, a przed właściwymi wynikami. Wygląd jest
           zdefiniowany w klasie .wfl-reminder w CSS; tutaj ograniczamy się
           do controlowania widoczności za pomocą display. -->
      <div id="wflReminderCole" class="wfl-reminder" style="display:none;"></div>
      <div id="coleInfo" class="result-box"></div>
      <p id="coleExplanation" class="cole-explanation"></p>
      <!-- Tabela norm wskaźnika Cole'a; wypełniana i wyświetlana przez JS -->
      <div id="coleNormTable" style="display:none;"></div>
    </div>
    <!-- ===== WHR: Wskaźnik talia-biodra ===== -->
    <div class="card" id="whrCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik talia-biodra (WHR)</h2>
    
      <!-- Sugestia kontekstowa (pokazywana, gdy spełnione warunki) -->
      <div id="whrSuggest" class="plan-warning-card notice-orange" style="display:none;">
        Sugerujemy ocenę <strong>WHR</strong>, aby sprawdzić rozmieszczenie tkanki tłuszczowej.</div>
      <div class="flex" style="gap:0.75rem;margin-top:0.5rem;">
        <label style="flex:1 1 160px;">Obwód talii (cm):
          <input type="number" id="waistCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
        <label style="flex:1 1 160px;">Obwód bioder (cm):
          <input type="number" id="hipCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
      </div>
    
      <div id="whrInfo" class="result-box" style="display:none;"></div>
      <p id="whrInterpret" class="cole-explanation" style="display:none;"></p>
    
      <!-- Krótka tabela centyli talii/bioder (dzieci) -->
      <div id="whrChildTable" class="data-card" style="display:none;margin-top:.6rem;"></div>
    
      <!-- Źródła do modułu WHR (skrócone) -->
      <small class="muted">
        Dorośli: WHO 2008/2011 cut-offs (M&gt;0,90 / K&gt;0,85). Dzieci: polskie siatki talii/bioder OLAF/OLA.
      </small>
    </div>
    <!-- ===== /WHR ===== -->
    <!-- Zaawansowane obliczenia wzrostowe – wstawione między kartę Cole'a a kartę Droga do normy BMI -->
    <div id="advancedGrowthSection" style="margin-top:1rem; display:none;">
      <button type="button" id="toggleAdvancedGrowth" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
        Zaawansowane obliczenia wzrostowe
      </button>
      <div id="advancedGrowthForm" class="card" style="display:none;margin-top:1rem;">
        <h2 style="text-align:center;">Zaawansowane obliczenia wzrostowe</h2>
        <label>Imię i&nbsp;Nazwisko (opcjonalnie):
          <input type="text" id="advName"></label>
        <label>Wiek kostny (lata):
          <input type="number" id="advBoneAge" min="0" max="18" step="0.1"></label>
        <label>Wzrost Mamy (cm):
          <input type="number" id="advMotherHeight" min="100" max="250"></label>
        <label>Wzrost Taty (cm):
          <input type="number" id="advFatherHeight" min="100" max="250"></label>
        <p style="font-weight:600;margin-top:0.8rem;">Wprowadź poprzednie pomiary</p>
        <div id="advMeasurements"></div>
        <button type="button" id="advAddMeasurementBtn" style="margin-top:0.8rem;display:block;margin-left:auto;margin-right:auto;">Dodaj kolejny pomiar</button>
        <div id="advResults" style="margin-top:1rem;"></div>
        <!-- Dodatkowe przyciski u dołu karty: generowanie siatki centylowej i czyszczenie danych tej karty. -->
        <div id="advButtons" class="adv-buttons">
          <button type="button" id="generateCentileChartAdv">Generuj siatkę centylową</button>
          <button type="button" id="advClearBtn">Wyczyść dane tej karty</button>
        </div>
      </div>
    </div>
    <!-- Karta „Droga do normy BMI” – zachowana oryginalna struktura -->
    <div class="card" id="toNormCard" style="display:none;">
      <h2>Droga do normy BMI</h2>
      <div id="toNormInfo"></div>
      <!-- Kontener na przycisk i wynik idealnej wagi. Pokazywany tylko, gdy BMI jest w normie. -->
      <div id="idealWeightWrap" style="display:none; margin-top:0.5rem; text-align:center;">
        <button type="button" id="idealWeightBtn">
          Chcesz zobaczyć jaka jest idealna waga przy twoim wzroście? Kliknij
        </button>
        <p id="idealWeightInfo" style="display:none; margin-top:0.5rem;"></p>
      </div>
      <!-- Mały napis pokazujący się tylko, gdy BMI nie jest w normie -->
      <small id="toNormNote">
        *Szacunkowa liczba km/metrów i czasu do przejścia/przejechania/przebiegnięcia, by BMI osiągnęło normę.
      </small>
    </div>
  </div>
  <div style="flex:1 1 300px;">
    <fieldset class="food-field">
      <legend>Przekąski</legend>
      <div id="snackList"></div>
      <button type="button" class="add-row" onclick="addSnackRow()">+ dodaj przekąskę</button>
    </fieldset>
    <fieldset class="food-field">
      <legend>Dania obiadowe</legend>
      <div id="mealList"></div>
      <button type="button" class="add-row" onclick="addMealRow()">+ dodaj danie</button>
    </fieldset>
    <!-- Karta sumy kalorii -->
    <div id="totalCard" class="card total-card" style="display:none;">
      <h2>Łączna kaloryczność
        <span class="subhead">(tego co wybrałeś powyżej)</span>
      </h2>
    
      <!-- Całkowite kcal – wypełnia JS -->
      <div id="totalKcal" style="font-size:1.2rem;text-align:center;margin-top:4px;"></div>
    
      <!-- Lista pozycji – wypełnia JS -->
      <div id="totalList"></div>
    </div>
  </div>
  <div class="card" id="timesCard">
    <h2 style="text-align:center;">Spalanie kalorii<span class="subhead">(czyli ile czasu zajmie mi<br>spalenie tego, co wybrałam/em)</span>
</h2>
    <div id="times"></div>
    <small>*Obliczenia oparte na wartościach MET – wyniki orientacyjne.</small>
  </div>
</div>
<!-- Usunięto sekcję „Szacowane spożycie energii” na stronie DocPro,
     ponieważ ten komponent jest przeznaczony wyłącznie dla strony głównej. -->
  <!-- Usunięto z podstrony DocPro kalkulator „Plan odchudzania”, ponieważ ten moduł
       dotyczy ogólnej kontroli masy ciała i nie jest częścią modułu lekarskiego. -->
  <!-- Usunięto z sekcji DocPro kartę „O aplikacji: źródła, metodologia i zastrzeżenia” wraz z listą źródeł,
       ponieważ te informacje są dostępne w innych częściach serwisu i nie powinny pojawiać się na stronie DocPro. -->
      </div>
      <button id="downloadPDF" style="margin-top:16px;" hidden>Pobierz raport PDF</button>
      </div><!-- /main-content -->
      <!-- Decorative sidebar to visually balance the layout on very wide screens.
           This empty aside has the same look as the left sidebar but contains
           no navigation.  It is hidden on narrower viewports; see sidebar.css
           for the breakpoint at which it appears. -->
      <aside class="decor-sidebar"></aside>
      </div><!-- /desktop-layout -->
      <footer>
        <p><strong>Administrator serwisu:</strong>
          Vilda Clinic sp. z o.o. • 
          <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">vildaclinic.pl</a>
        </p>
        <p><strong>Konsultacja merytoryczna:</strong>
          dr n. med. Maciej Flader
        </p>
        </footer>
<!-- Uruchamiamy update() po pełnym załadowaniu strony -->
<!-- === UI ENHANCEMENT SCRIPT 2025‑06‑29 === -->
<!-- WHO patch merged automatically -->
<!-- === WHO 2006 BMI-for-age (0–60 mies.) tables inserted 2025‑06‑30 === -->
<!-- === BMI 50th percentile info patch – 2025‑06‑30 === -->
<!-- === ENHANCEMENTS: bigger/animated plan time, bold kg reduction, bigger 50th centyl info === -->
<!-- === PATCH 2025‑07‑01 – Small 50 and full time animation === -->

<!-- Load Down syndrome growth tables before app.js; these define DS datasets as global variables -->
<script src="ds_lms.js"></script>
<!-- Palczewska centile data (weight, height, BMI) for 0–18 years. Loaded before app.js so it attaches centileData to window. -->
<script src="centile_data.js"></script>
<!-- Biblioteka XLSX do obsługi plików Excel.  Ładowana przed app.js, aby
     obiekt globalny XLSX był dostępny podczas inicjowania aplikacji. -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="app.js" defer></script>
<!-- po app.js -->
<script src="gh_igf_therapy.js" defer></script>
<script src="gh_therapy_monitor.js" defer></script>
<!-- Skrypt kalkulatora antybiotykoterapii – generuje kartę dawek antybiotyków.
     Ładowany po głównym pliku app.js i module GH/IGF, aby skorzystać z już zainicjowanych
     elementów DOM oraz funkcji (np. pobierania masy ciała). Plik antibiotic_therapy.js
     tworzy kartę kalkulującą dawki najpopularniejszych antybiotyków u dzieci na podstawie
     zaleceń z Rekomendacji 2016 i danych wprowadzonych przez użytkownika w sekcji
     „Dane użytkownika”. -->
<script src="antibiotic_therapy.js" defer></script>

    <!-- Skrypt kalkulatora leczenia bisfosfonianami.  
         Ładowany po głównym pliku app.js i modułach GH/IGF, aby skorzystać z już zainicjowanych 
         elementów DOM oraz funkcji (np. pobierania masy ciała). Skrypt ten oblicza dawki 
         pamidronianu i zoledronianu na podstawie wagi dziecka oraz wybranych parametrów terapii. -->
    <script src="bisphos_therapy.js" defer></script>

    <!-- Skrypt synchronizujący podstawowe dane użytkownika (imię, wiek, płeć, masa i wzrost) pomiędzy
         stronami aplikacji. Plik userData.js zapisuje dane w localStorage i wczytuje je na
         wszystkich podstronach. -->
    <script src="userData.js" defer></script>


<!-- Skrypt generujący siatki centylowe wagi i wzrostu w formacie PDF.
     Kod ten korzysta z globalnych tablic LMS (zdefiniowanych w app.js) oraz bibliotek jsPDF i Canvas.
     Po kliknięciu przycisku „Generuj siatkę centylową” tworzy dwa wykresy (wzrostu i wagi),
     łączy je na jednej stronie A4 i wyświetla jako PDF w nowym oknie. -->
<script>
/* Definicje z‑score dla wybranych centyli (3., 10., 25., 50., 75., 90., 97.). */
const CENTILE_ZSCORES = { 3: -1.8808, 10: -1.281552, 25: -0.67448975, 50: 0, 75: 0.67448975, 90: 1.281552, 97: 1.8808 };

/* Interpoluje wartości LMS dla dowolnego miesiąca w danych OLAF. */
function getLMSFromDataset(dataset, m) {
  const keys = Object.keys(dataset).map(k => parseInt(k, 10)).sort((a, b) => a - b);
  if (dataset[m]) return dataset[m];
  let lo = keys[0], hi = keys[keys.length - 1];
  for (let i = 0; i < keys.length; i++) {
    if (keys[i] <= m) lo = keys[i];
    if (keys[i] >= m) { hi = keys[i]; break; }
  }
  const vLo = dataset[lo], vHi = dataset[hi];
  if (!vLo || !vHi) return vLo || vHi;
  if (lo === hi) return vLo;
  const t = (m - lo) / (hi - lo);
  const L = vLo[0] + t * (vHi[0] - vLo[0]);
  const M = vLo[1] + t * (vHi[1] - vLo[1]);
  const S = vLo[2] + t * (vHi[2] - vLo[2]);
  return [L, M, S];
}
/* Oblicza wartość z parametrów LMS i z‑score. */
function valueFromLMS(L, M, S, z) {
  if (L !== 0) {
    return M * Math.pow(1 + L * S * z, 1 / L);
  }
  return M * Math.exp(S * z);
}
/* Pobiera LMS dla wagi wg płci. */
function getLMSWeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_WEIGHT_BOYS, m) : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}
/* Pobiera LMS dla wzrostu wg płci. */
function getLMSHeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_HEIGHT_BOYS, m) : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}

/* Hybrydowa wersja LMS – dla wieku <36 mies. (0–3 lata) korzysta z danych WHO,
   natomiast dla wieku ≥36 mies. korzysta z badań OLAF (domyślne). */
function getLMSWeightHybrid(sex, m) {
  // m – miesiące (całkowite lub ułamkowe). Dla wartości ułamkowych funkcja
  // getLMSFromDataset wykona interpolację między sąsiednimi miesiącami.
  // Dane WHO obejmują okres od urodzenia do 36 mies. włącznie. Aby uniknąć
  // skoków przy przejściu z WHO do OLAF, korzystamy z WHO tylko dla m < 36 (0–35);
  // dla m ≥ 36 przechodzimy na OLAF.  Takie rozdzielenie zapobiega
  // „zagięciu” krzywych w okolicach trzeciego roku życia.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_WEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_WEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_WEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}

function getLMSHeightHybrid(sex, m) {
  // Analogicznie jak w przypadku masy: korzystamy z WHO wyłącznie dla m < 36
  // (okres 0–35 miesięcy), natomiast dla m ≥ 36 przechodzimy na OLAF.  Dzięki temu
  // unikamy gwałtownej zmiany źródła danych dla 36. miesiąca i starszych.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_HEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_HEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_HEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}
/* Rysuje pojedynczy wykres siatki centylowej. */
function drawCentileGrid(ctx, cfg) {
  const { x, y, w, h, curves, minY, maxY, userVal, userAgeMonths, title, units, percentiles, highlightBandIdx, cutoffVal, minX, maxX } = cfg;
  // Determine the horizontal range (in months) for the chart.  If minX/maxX are not
  // provided, default to the historical 3–18 lata range (36–216 mies.).  The variables
  // minXVal and maxXVal ensure we always have defined numeric values for computations.
  const minXVal = (typeof minX === 'number') ? minX : 36;
  const maxXVal = (typeof maxX === 'number') ? maxX : 216;
  const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
  const px = x + leftMargin, py = y + topMargin;
  const pw = w - leftMargin - rightMargin, ph = h - topMargin - bottomMargin;
  // Scale factors.  X‑axis is scaled according to the selected range (maxXVal – minXVal).
  const xScale = pw / (maxXVal - minXVal);
  const yScale = ph / (maxY - minY);
  ctx.save();
  ctx.lineCap = 'butt';
  // Pionowe linie siatki.  Zakres lat (startYear..endYear) zależy od zdefiniowanego zakresu mies. (minXVal..maxXVal).
  const startYear = Math.ceil(minXVal / 12);
  const endYear   = Math.floor(maxXVal / 12);
  for (let age = startYear; age <= endYear; age++) {
    const m = age * 12;
    const cx = px + (m - minXVal) * xScale;
    ctx.beginPath();
    ctx.strokeStyle = '#bbbbbb';
    ctx.lineWidth = 2.5;
    ctx.moveTo(cx, py);
    ctx.lineTo(cx, py + ph);
    ctx.stroke();
    // Połówkowe linie (co 6 mies.)
    if (age < endYear) {
      const halfM = m + 6;
      if (halfM <= maxXVal) {
        const halfX = px + (halfM - minXVal) * xScale;
        ctx.beginPath();
        ctx.strokeStyle = '#dddddd';
        ctx.lineWidth = 1.75;
        ctx.moveTo(halfX, py);
        ctx.lineTo(halfX, py + ph);
        ctx.stroke();
      }
    }
    ctx.font = '35px sans-serif';
    ctx.fillStyle = '#333333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(String(age), cx, py + ph + 8);
  }
  // Poziome linie siatki
  for (let val = minY; val <= maxY; val++) {
    const cy = py + ph - (val - minY) * yScale;
    ctx.beginPath();
    if (val % 5 === 0) {
      ctx.strokeStyle = '#bbbbbb';
      ctx.lineWidth = 2.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#333333';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(val), px - 6, cy);
    } else {
      ctx.strokeStyle = '#eeeeee';
      ctx.lineWidth = 1.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
    }
  }
  // Osie
  ctx.beginPath();
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.moveTo(px, py);
  ctx.lineTo(px, py + ph);
  ctx.moveTo(px, py + ph);
  ctx.lineTo(px + pw, py + ph);
  ctx.stroke();
  
  // Podświetlenie kanału centylowego i dwie poziome linie na poziomach 18 r.ż.
  if (typeof highlightBandIdx === 'number' && highlightBandIdx >= 0 && highlightBandIdx < percentiles.length - 1) {
    const pA = percentiles[highlightBandIdx];
    const pB = percentiles[highlightBandIdx + 1];
    const valsA = curves[pA];
    const valsB = curves[pB];
    const n = valsA.length;

    // Wypełnienie obszaru kanału (delikatny turkus)
    (function shadeBand() {
      const path = new Path2D();
      for (let i = 0; i < n; i++) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yTop = py + ph - (Math.max(valsA[i], valsB[i]) - minY) * yScale;
        if (i === 0) path.moveTo(cx, yTop); else path.lineTo(cx, yTop);
      }
      for (let i = n - 1; i >= 0; i--) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yBot = py + ph - (Math.min(valsA[i], valsB[i]) - minY) * yScale;
        path.lineTo(cx, yBot);
      }
      path.closePath();
      ctx.save();
      ctx.fillStyle = 'rgba(0,131,141,0.10)';
      ctx.fill(path);
      ctx.restore();
    })();

    // Poziome linie na wartościach 18 r.ż. (216 mies.) – przez całą szerokość siatki.
    // Wyznacz indeks w tablicach wartości, przesuwając o minXVal.  Jeżeli zakres
    // osi X nie obejmuje 18 lat (216 mies.), pomijamy te linie.
    const idx18 = 216 - minXVal;
    if (maxXVal >= 216 && idx18 >= 0 && idx18 < n) {
      const v1 = valsA[idx18];
      const v2 = valsB[idx18];
      const valLow18 = Math.min(v1, v2);
      const valHigh18 = Math.max(v1, v2);
      const yLow18 = py + ph - (valLow18 - minY) * yScale;
      const yHigh18 = py + ph - (valHigh18 - minY) * yScale;

      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = 'rgba(0,131,141,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(px, yLow18); ctx.lineTo(px + pw, yLow18); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px, yHigh18); ctx.lineTo(px + pw, yHigh18); ctx.stroke();
      ctx.setLineDash([]);

      // Etykiety wartości wewnątrz siatki, tuż przy lewym brzegu (ale nie na zewnątrz).
      // Numeryczne wartości są zaokrąglane do 0,5 jednostki (np. 174,5 cm) i
      // wyświetlane powyżej przerywanych linii, aby linie nie przechodziły przez tekst.
      function fmtToHalf(n) {
        // Zaokrąglij do połowy jednostki i zwróć z przecinkiem jako separator dziesiętny
        const rounded = Math.round(n * 2) / 2;
        return rounded.toFixed(1).replace('.', ',');
      }
      const cLow = Math.min(pA, pB);
      const cHigh = Math.max(pA, pB);
      const labelLow = `${fmtToHalf(valLow18)} ${units} (${cLow} c)`;
      const labelHigh = `${fmtToHalf(valHigh18)} ${units} (${cHigh} c)`;

      // Wyznacz pionowe pozycje dla etykiet. Odsuń je lekko w górę względem linii,
      // aby uniknąć kolizji z kreskowanymi liniami. Jeżeli linie są blisko siebie,
      // dodatkowo zwiększ odstęp.
      let y1 = yHigh18 - 18;
      let y2 = yLow18 - 18;
      // Jeśli odległość między dwoma etykietami jest zbyt mała, rozsuń je
      if (Math.abs(y2 - y1) < 32) {
        const shift = (32 - Math.abs(y2 - y1)) / 2 + 2;
        y1 -= shift;
        y2 += shift;
      }
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#004f54';
      ctx.textAlign = 'left';
      // Ustaw baseline na 'middle' tak, aby podany y oznaczał środek tekstu
      ctx.textBaseline = 'middle';
      ctx.fillText(labelHigh, px + 10, y1);
      ctx.fillText(labelLow,  px + 10, y2);
      ctx.restore();
    }
  }

  // Linie centylowe
  const colors = { 3: '#d32f2f', 10: '#f57c00', 25: '#fbc02d', 50: '#388e3c', 75: '#1976d2', 90: '#7b1fa2', 97: '#c2185b' };
  const labelPos = [];
  for (const p of percentiles) {
    const vals = curves[p];
    ctx.beginPath();
    ctx.strokeStyle = colors[p] || '#000000';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    const pts = [];
    for (let i = 0; i < vals.length; i++) {
      const mVal = minXVal + i;
      const pxVal = px + (mVal - minXVal) * xScale;
      const pyVal = py + ph - (vals[i] - minY) * yScale;
      pts.push({ x: pxVal, y: pyVal });
    }
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 0; i < pts.length - 1; i++) {
      const cpX = pts[i].x, cpY = pts[i].y;
      const midX = (pts[i].x + pts[i + 1].x) / 2;
      const midY = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(cpX, cpY, midX, midY);
    }
    ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
    ctx.stroke();
    const lastPt = pts[pts.length - 1];
    labelPos.push({ centile: p, x: lastPt.x, y: lastPt.y, color: colors[p] });
  }
  // Unikanie nakładania etykiet centyli
  labelPos.sort((a, b) => a.y - b.y);
  const minSpacing = 32;
  for (let i = 1; i < labelPos.length; i++) {
    if (labelPos[i].y - labelPos[i - 1].y < minSpacing) {
      labelPos[i].y = labelPos[i - 1].y + minSpacing;
    }
  }
  const bottom = py + ph;
  const overflow = labelPos[labelPos.length - 1].y - bottom;
  if (overflow > -16) {
    const shift = overflow + 16;
    for (const item of labelPos) {
      item.y -= shift;
    }
  }
  ctx.font = '26px sans-serif';
  ctx.textBaseline = 'middle';
  for (const item of labelPos) {
    ctx.fillStyle = item.color;
    ctx.textAlign = 'left';
    ctx.fillText(String(item.centile), px + pw + 10, item.y);
  }
  // Tytuły osi
  ctx.save();
  ctx.translate(x + 40, y + topMargin + ph / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.fillText(title, 0, 0);
  ctx.restore();
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('Wiek (lata)', px + pw / 2, py + ph + 50);
  // Ostrzeżenie w przypadku rozszerzenia zakresu wagi
  // Jeśli zdefiniowano cutoffVal (np. górną granicę oficjalnej siatki), narysuj grubą linię
  // oraz ostrzeżenie, aby zaznaczyć koniec referencyjnego zakresu.  Umieszczamy
  // go przed rysowaniem punktu użytkownika, aby punkt pozostał na wierzchu.
  if (typeof cutoffVal === 'number' && cutoffVal >= minY && cutoffVal < maxY) {
    const cyWarn = py + ph - (cutoffVal - minY) * yScale;
    ctx.save();
    ctx.strokeStyle = '#c62828';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(px, cyWarn);
    ctx.lineTo(px + pw, cyWarn);
    ctx.stroke();
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Uwaga! koniec oficjalnej siatki centylowej', px + pw / 2, cyWarn - 8);
    ctx.restore();
  }

  // Punkt użytkownika
  if (typeof userVal === 'number' && !isNaN(userVal) && typeof userAgeMonths === 'number' && userAgeMonths >= minXVal && userAgeMonths <= maxXVal) {
    const pxU = px + (userAgeMonths - minXVal) * xScale;
    const pyU = py + ph - (userVal - minY) * yScale;
    ctx.beginPath();
    ctx.fillStyle = '#000000';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.arc(pxU, pyU, 10, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.font = '33px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.textAlign = pxU > px + pw / 2 ? 'right' : 'left';
    ctx.textBaseline = 'bottom';
    const lbl = userVal.toFixed(1) + ' ' + units;
    const labelX = pxU > px + pw / 2 ? pxU - 12 : pxU + 12;
    ctx.fillText(lbl, labelX, pyU - 12);
  }
  ctx.restore();
}
/* Główna funkcja generująca PDF z siatkami centylowymi. */

async function generateCentileChart() {
  // Funkcja pomocnicza: wyznacza, między którymi centylami (indeks w tablicy percentiles)
  // znajduje się wartość użytkownika przy zadanym wieku (mIdx = miesiące - 36).
  function findHighlightBand(userVal, curves, percentiles, mIdx) {
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i = 0; i < vals.length - 1; i++) {
      const lo = Math.min(vals[i], vals[i + 1]);
      const hi = Math.max(vals[i], vals[i + 1]);
      // włączamy górną granicę, aby nie zostawiać "szczeliny"
      if (userVal >= lo && userVal <= hi) return i;
    }
    // Jeżeli wynik znajduje się poniżej najniższego centyla (3 c.) lub powyżej najwyższego (97 c.),
    // nie wyróżniaj żadnego kanału centylowego. Zwrócenie -1 powoduje brak podświetlenia
    // w przypadku wartości < 3. centyla lub > 97. centyla.
    if (userVal < Math.min(vals[0], vals[1])) return -1;
    if (userVal > Math.max(vals[vals.length - 2], vals[vals.length - 1])) return -1;
    return -1;
  }

  const ageEl = document.getElementById('age');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  if (!ageEl || !weightEl || !heightEl || !sexEl) {
    alert('Wprowadź wiek, wagę, wzrost i płeć, aby wygenerować siatkę centylową.');
    return;
  }
  // Odczytaj wiek zarówno w latach, jak i w miesiącach. Pole wieku w latach (#age) jest obowiązkowe,
  // natomiast pole miesięcy (#ageMonths) jest opcjonalne. Jeśli pole miesięcy jest puste lub
  // nie istnieje (w przypadku, gdy skrypt jest używany w kontekście bez miesiąców), przyjmujemy 0.
  const yearsVal  = parseFloat(ageEl.value) || 0;
  const ageMonthsEl = document.getElementById('ageMonths');
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  // Połącz lata i miesiące w bardziej precyzyjny wiek (np. 11 lat 6 miesięcy = 11.5).
  const ageYears = yearsVal + (monthsVal / 12);
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = sexEl.value === 'M' ? 'M' : 'F';
  // Jeżeli którakolwiek z wartości jest nieprawidłowa (NaN), przerwij generowanie wykresu.
  if (isNaN(ageYears) || isNaN(weight) || isNaN(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  // Zamień dokładny wiek (z uwzględnieniem miesięcy) na liczbę pełnych miesięcy do dalszych obliczeń.
  const ageMonths = Math.round(ageYears * 12);
  // Pozwalamy na zakres 0–18 lat (0–216 mies.). Sprawdź, czy wiek mieści się w tym zakresie.
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  // Wyznacz zakres osi X w zależności od wieku użytkownika.  Dla wieku <36 mies. używamy
  // danych Palczewska & Niedźwiecka (0–36 mies.), a dla wieku ≥36 mies. danych OLAF (36–216 mies.).
  let minXVal, maxXVal;
  // Określ, czy należy użyć danych Palczewska (wiek poniżej 3 lat) czy OLAF (wiek ≥ 3 lata).
  const usePalczewska = ageMonths < 36;
  if (usePalczewska) {
    minXVal = 0;
    maxXVal = 36;
  } else {
    minXVal = 36;
    maxXVal = 216;
  }
  const months = [];
  for (let m = minXVal; m <= maxXVal; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n)).sort((a, b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  // Wypełnij krzywe centylowe dla wybranego zakresu miesięcy. Dla wieku <3 lat (0–35 miesięcy)
  // korzystamy z siatek Palczewskiej i Niedźwieckiej (polska populacja).  Dla wieku ≥ 3 lat
  // (36–18 lat) używamy wyłącznie danych OLAF/WHO. Dzięki temu unikamy łączenia dwóch
  // różnych źródeł przy wartościach 36 miesięcy i zapewniamy spójność wykresu.
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        // pobierz wartości z siatki polskiej (Palczewska & Niedźwiecka)
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        // użyj funkcji LMS dla wieku ≥ 3 lat (OLAF/WHO)
        const [Lw, Mw, Sw] = getLMSWeightHybrid(sex, m);
        const [Lh, Mh, Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }

  /*
   * Krótkie wygładzanie krzywych centylowych (optional smoothing)
   * Aby poprawić wizualną jakość wykresów, zastosujmy prosty filtr
   * średniej kroczącej do każdej tablicy wartości wagi i wzrostu.  Używamy
   * okna o szerokości 3 i wykonujemy sześć przebiegów.  Większa liczba
   * przebiegów mocniej wygładza krzywe, redukując ostre załamania
   * wynikające z dyskretnych danych, jednocześnie minimalnie zmieniając
   * wartości referencyjne.
   */
  function smoothCurve(arr, passes = 1) {
    let out = arr.slice();
    const n = arr.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      // dla brzegów nie możemy użyć pełnego okna; pozostawiamy oryginalne wartości
      // można także przyjąć średnią z sąsiada, ale zachowujemy źródłową wartość
      out = tmp;
    }
    return out;
  }
  // Zastosuj wygładzanie do wszystkich krzywych przed obliczeniem zakresów
  for (const p of percentiles) {
    // Zwiększamy liczbę przebiegów do 6, aby osiągnąć jeszcze mocniejsze wygładzenie krzywych.
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  let minW = Infinity, maxW = -Infinity, minH = Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  minW = Math.floor(minW / 5) * 5; maxW = Math.ceil(maxW / 5) * 5;
  minH = Math.floor(minH / 5) * 5; maxH = Math.ceil(maxH / 5) * 5;

  // --- DYNAMICZNE SKALOWANIE osi Y (wzrost + waga, góra i dół) ---
  // 0) Pomocnicze zaokrąglenia do 5, żeby linie siatki były czytelne:
  const roundDown5 = v => Math.floor(v / 5) * 5;
  const roundUp5 = v => Math.ceil(v / 5) * 5;

  // 1) Zbierz skrajne pomiary z bieżących pól i z karty zaawansowanej
  let minMeasuredW = weight, maxMeasuredW = weight;
  let minMeasuredH = height, maxMeasuredH = height;

  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        if (typeof m.weight === 'number') {
          if (m.weight < minMeasuredW) minMeasuredW = m.weight;
          if (m.weight > maxMeasuredW) maxMeasuredW = m.weight;
        }
        if (typeof m.height === 'number') {
          if (m.height < minMeasuredH) minMeasuredH = m.height;
          if (m.height > maxMeasuredH) maxMeasuredH = m.height;
        }
      });
    }
    if (typeof adv.currentWeight === 'number') {
      if (adv.currentWeight < minMeasuredW) minMeasuredW = adv.currentWeight;
      if (adv.currentWeight > maxMeasuredW) maxMeasuredW = adv.currentWeight;
    }
    if (typeof adv.currentHeight === 'number') {
      if (adv.currentHeight < minMeasuredH) minMeasuredH = adv.currentHeight;
      if (adv.currentHeight > maxMeasuredH) maxMeasuredH = adv.currentHeight;
    }
  }

  // 2) Wyznacz dynamiczne granice (zaokrąglone do „piątek”)
  let dynamicMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynamicMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;

  let dynamicMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynamicMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;

  // 3) Zakresy przed/po zmianach (potrzebne do proporcjonowania wysokości wykresów)
  const origWRange = maxW - minW;
  const origHRange = maxH - minH;
  const newWRange = dynamicMaxW - dynamicMinW;
  const newHRange = dynamicMaxH - dynamicMinH;

  // 4) Flagi ułatwiające decyzje dalej
  const scaledW = (dynamicMinW !== minW) || (dynamicMaxW !== maxW);
  const scaledH = (dynamicMinH !== minH) || (dynamicMaxH !== maxH);
  const useDynamicScaling = scaledW || scaledH;
  
  // Indeks miesiąca użytkownika (0..180) i kanały do podświetlenia dla wzrostu i wagi
  // Indeks miesiąca użytkownika wewnątrz tablicy months.  Odejmiemy początek zakresu osi X.
  const mIdx = ageMonths - minXVal;
  const hBandIdx = findHighlightBand(height, heightCurves, percentiles, mIdx);
  const wBandIdx = findHighlightBand(weight, weightCurves, percentiles, mIdx);
const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw;
  canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, pw, ph);
  const header = sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki';
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(header, pw / 2, 60);
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  /*
   * Użytkownik poprosił o obniżenie napisu „Imię i nazwisko” względem nagłówka o 1 rem.
   * Ponieważ płótno jest tworzone w wysokiej rozdzielczości (~300 dpi), 1 rem (16 px w CSS)
   * odpowiada ok. 50 pikselom na płótnie. Dlatego dodajemy 50 pikseli do pozycji Y,
   * aby uzyskać bardziej wyraźny odstęp między nagłówkiem a etykietą imienia i nazwiska.
   */
  // Obniżenie etykiety „Imię i nazwisko” o 1,75 rem względem nagłówka (1,25 rem z poprzedniej wersji + 0,5 rem dodatkowo).
  // --- DYNAMICZNY napis "Imię i nazwisko" (z karty Zaawansowane) ---
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');

  const nameLabel = nameFromState
    ? `Imię i nazwisko: ${nameFromState}`
    : 'Imię i nazwisko: _________________________________';

  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // --- koniec wstawki ---
  const chartW = pw - 200;
  // Oblicz dostępną przestrzeń na siatki dopiero w momencie rysowania, gdy znamy wysokość strony.
  const availH = ph - 300;
  // Margines pomiędzy dwoma wykresami (jak w oryginalnym projekcie).
  const interChartMargin = 100;
  // Przestrzeń dostępna wyłącznie na dwie siatki (wysokość płótna minus margines).
  const chartsAreaH = availH - interChartMargin;
  // Dynamicznie przydziel wysokość dla wzrostu i wagi w zależności od tego,
  // czy zmienił się zakres którejkolwiek osi Y (waga lub wzrost).
  let heightGridH, weightGridH;
  if (useDynamicScaling) {
    // Proporcja przestrzeni ~ proporcji aktualnych zakresów Y
    let tmpHeight = chartsAreaH * (newHRange / (newHRange + newWRange || 1));
    let tmpWeight = chartsAreaH - tmpHeight;
    // Zadbaj o minimalną wysokość górnego wykresu (wzrostu), aby nie był za niski
    const minHeightChartH = chartsAreaH * 0.30;
    if (tmpHeight < minHeightChartH) {
      tmpHeight = minHeightChartH;
      tmpWeight = chartsAreaH - tmpHeight;
    }
    heightGridH = tmpHeight;
    weightGridH = tmpWeight;
  } else {
    // Bez zmian zakresów – po połowie miejsca
    heightGridH = chartsAreaH / 2;
    weightGridH = chartsAreaH / 2;
  }
  // Pozycje Y dla obu wykresów. Górny wykres zaczyna się w ustalonej pozycji, a dolny jest przesunięty
  // o wysokość pierwszego wykresu plus margines minus małe przesunięcie (0,5 rem) kompensujące podpisy osi.
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Pierwszy wykres – wzrost
  drawCentileGrid(ctx, {
    x: 100,
    y: yHeightGrid,
    w: chartW,
    h: heightGridH,
    curves: heightCurves,
    minY: dynamicMinH,
    maxY: dynamicMaxH,
    userVal: height,
    userAgeMonths: ageMonths,
    title: 'Wzrost (cm)',
    units: 'cm',
    percentiles,
    highlightBandIdx: hBandIdx,
    // Przekazujemy początek i koniec osi X, aby rysunek obsługiwał wiek 0–3 lub 3–18 lat.
    minX: minXVal,
    maxX: maxXVal,
    cutoffVal: (dynamicMaxH > maxH) ? maxH : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wzrostu ---
  // Jeżeli użytkownik wprowadził dodatkowe dane (historia pomiarów,
  // potencjał wzrostowy, wiek kostny), wyświetlamy je na siatce
  // centylowej wzrostu. Elementy te rysujemy po narysowaniu
  // standardowych krzywych, aby były widoczne na wierzchu.
  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    // Obliczenia współczynników skalowania odpowiadające tym w
    // drawCentileGrid(). Marginesy muszą być zgodne z tymi użytymi
    // w funkcji rysującej, aby punkty były prawidłowo rozmieszczone.
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yHeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = heightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYh = dynamicMinH;
      const maxYh = dynamicMaxH;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYh - minYh);
      ctx.save();
      // Rysowanie linii łączących historyczne pomiary wzrostu
      if (adv.measurements && adv.measurements.length) {
        // Do listy punktów dodajemy również aktualny pomiar wzrostu, tak aby
        // linia łączyła historię z bieżącym wzrostem dziecka.
        let pts = adv.measurements.filter(m => m.height !== null).slice();
        if (typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
          pts.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Linie łączące kolejne pomiary
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.height - minYh) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Punkty pomiarowe
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.height - minYh) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      // Rysowanie markeru docelowego wzrostu (Target Height).
      // Do etykiety dodajemy przewidywany ostateczny wzrost w centymetrach, np. „TH 166.0 cm”.
      if (typeof adv.targetHeight === 'number' && !isNaN(adv.targetHeight)) {
        const mAgeTH = 216; // 18 lat w miesiącach
        if (mAgeTH >= minX && mAgeTH <= maxX) {
          const cx = pxBase + (mAgeTH - minX) * xScale;
          const cy = pyBase + phBase - (adv.targetHeight - minYh) * yScale;
          ctx.beginPath();
          ctx.fillStyle = '#c62828';
          ctx.moveTo(cx - 8, cy);
          ctx.lineTo(cx, cy - 8);
          ctx.lineTo(cx + 8, cy);
          ctx.lineTo(cx, cy + 8);
          ctx.closePath();
          ctx.fill();
          // Etykieta „TH” wraz z wartością docelowego wzrostu w cm.
          const thLabel = adv.targetHeight.toFixed(1) + ' cm';
          ctx.font = 'bold 28px sans-serif';
          ctx.fillStyle = '#c62828';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText('TH ' + thLabel, cx + 14, cy);
        }
      }
      // Rysowanie markera wieku kostnego (jeśli podano)
      if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths)) {
        const boneXAge = adv.boneAgeMonths;
        // Zaznacz punkt na osi czasu odpowiadający wiekowi kostnemu
        if (boneXAge >= minX && boneXAge <= maxX && typeof adv.currentHeight === 'number') {
          const cxBone = pxBase + (boneXAge - minX) * xScale;
          const cyBone = pyBase + phBase - (adv.currentHeight - minYh) * yScale;
          const cxCurrent = pxBase + (adv.currentAgeMonths - minX) * xScale;
          // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
          ctx.beginPath();
          ctx.strokeStyle = '#00838d';
          ctx.lineWidth = 2;
          ctx.moveTo(cxBone, cyBone);
          ctx.lineTo(cxCurrent, cyBone);
          ctx.stroke();
          // Zaznacz kropkę z pierścieniem
          ctx.beginPath();
          ctx.fillStyle = '#00838d';
          ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
          ctx.strokeStyle = '#00838d';
          ctx.stroke();
        }
      }
      // Rysowanie WSZYSTKICH historycznych wieków kostnych (jak aktualny: kropka z pierścieniem)
      try {
        if (adv && Array.isArray(adv.measurements)) {
          adv.measurements.forEach(m => {
            if (!m) return;
            // Toleruj wartość wieku kostnego przechowywaną jako napis lub liczba
            const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string')
              ? parseFloat(m.boneAgeYears) : NaN;
            const hVal = (typeof m.height === 'number' || typeof m.height === 'string')
              ? parseFloat(m.height) : NaN;
            const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string')
              ? parseFloat(m.ageMonths) : NaN;
            if (!isNaN(bVal) && !isNaN(hVal) && !isNaN(ageM)) {
              const mBoneMonths = Math.round(bVal * 12);
              // Sprawdź czy mieści się w zakresie osi
              if (mBoneMonths >= minX && mBoneMonths <= maxX && hVal >= minYh && hVal <= maxYh) {
                const cxB = pxBase + (mBoneMonths - minX) * xScale;
                const cyB = pyBase + phBase - (hVal - minYh) * yScale;
                const cxCurrentM = pxBase + (ageM - minX) * xScale;
                // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
                ctx.beginPath();
                ctx.strokeStyle = '#00838d';
                ctx.lineWidth = 2;
                ctx.moveTo(cxB, cyB);
                ctx.lineTo(cxCurrentM, cyB);
                ctx.stroke();
                // Zaznacz kropkę z pierścieniem
                ctx.beginPath();
                ctx.fillStyle = '#00838d';
                ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00838d';
                ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
                ctx.stroke();
              }
            }
          });
        }
      } catch(_){}
      ctx.restore();
    })();
  }
  /*
   * Aby uniknąć ucinania dolnych podpisów osi X na wydruku, podnosimy siatkę centylową wagi
   * o 1 rem (ok. 50 pikseli) względem pierwotnej pozycji. Odejmujemy więc 50 pikseli
   * od wartości Y drugiego wykresu.
   */
  // Drugi wykres – waga. Używamy dynamicznie dobranych wymiarów i osi, jeśli zakres wagi został rozszerzony.
  drawCentileGrid(ctx, {
    x: 100,
    y: yWeightGrid,
    w: chartW,
    h: weightGridH,
    curves: weightCurves,
    // Użyj dynamicMaxW jako górnej granicy osi wagi, jeśli rozszerzono zakres.
    minY: dynamicMinW,
    maxY: dynamicMaxW,
    userVal: weight,
    userAgeMonths: ageMonths,
    title: 'Waga (kg)',
    units: 'kg',
    percentiles,
    highlightBandIdx: wBandIdx
    ,
    // Zakres osi X oraz ewentualne ostrzeżenie o końcu oficjalnej siatki wagi.
    minX: minXVal,
    maxX: maxXVal,
    // Przekazujemy oryginalne maksimum jako cutoffVal w przypadku przekroczenia, aby narysować linię ostrzegawczą.
    cutoffVal: (dynamicMaxW > maxW) ? maxW : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wagi ---
  // Po narysowaniu wykresu wagi możemy nanieść historię pomiarów wagi
  // wprowadzone przez użytkownika. Użytkownicy mogą wpisywać
  // dowolną liczbę pomiarów; rysujemy linie łączące kolejne punkty i
  // same punkty. Pozostałe elementy (potencjał wzrostowy, wiek kostny)
  // nie dotyczą wagi i dlatego nie są tu rysowane.
  if (window.advancedGrowthData) {
    const advW = window.advancedGrowthData;
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yWeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = weightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYw = dynamicMinW;
      const maxYwLocal = dynamicMaxW;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYwLocal - minYw);
      ctx.save();
      if (advW.measurements && advW.measurements.length) {
        // Dodaj aktualny pomiar wagi, aby linia łączyła historię z bieżącą wagą dziecka.
        let pts = advW.measurements.filter(m => m.weight !== null).slice();
        if (typeof advW.currentWeight === 'number' && typeof advW.currentAgeMonths === 'number') {
          pts.push({ ageMonths: advW.currentAgeMonths, weight: advW.currentWeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Rysuj linie łączące kolejne pomiary wagi
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.weight - minYw) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Rysuj punkty wagi
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.weight - minYw) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      ctx.restore();
    })();
  }

  // Dodaj informację źródłową w prawym dolnym rogu. Informujemy użytkownika,
  // że dane użyte do wygenerowania siatek centylowych pochodzą z badania OLAF.
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  // Uaktualnij informację o źródle danych: siatki 0–3 lata opierają się na standardach WHO,
  // a dla wieku 3–18 lat na badaniu OLAF. Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Aktualizujemy informację o źródle danych: siatki 0–3 lata oparte są na polskim
  // badaniu Palczewskiej i Niedźwieckiej (Warszawa 1999), natomiast siatki 3–18 lat
  // korzystają z badań OLAF (2007–2012).  Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Obniżamy podpis w dolnej części strony o około 1 rem (~50 px) względem oryginalnej pozycji.
  const footerY = ph - 60 + 50;
  // Tekst po prawej stronie z informacją o źródłach danych
  ctx.fillText('Dane do siatek centylowych: Palczewska & Niedźwiecka (0–3 lata) i OLAF (3–18 lat)', pw - 120, footerY);
  // Tekst po lewej z nazwą kliniki na tej samej wysokości
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
document.addEventListener('DOMContentLoaded', function() {
  const btn = document.getElementById('generateCentileChart');
  if (btn) {
    btn.addEventListener('click', generateCentileChart);
  }
  // Dodaj obsługę przycisku generowania siatki centylowej z karty zaawansowanej
  const btnAdv = document.getElementById('generateCentileChartAdv');
  if (btnAdv) {
    btnAdv.addEventListener('click', generateCentileChart);
  }
  // Obsługa czyszczenia danych karty zaawansowanej
  const advClear = document.getElementById('advClearBtn');
  if (advClear) {
    advClear.addEventListener('click', () => {
      if (typeof clearAdvancedGrowthCard === 'function') {
        clearAdvancedGrowthCard();
      }
    });
  }
  // Obsługa usuwania wszystkich danych – przywraca aplikację do stanu początkowego
  const clearAll = document.getElementById('clearAllDataBtn');
  if (clearAll) {
    clearAll.addEventListener('click', () => {
      location.reload();
    });
  }
});

</script>

<!-- Now override the default growth chart implementation to support infants (0–<3 lata) and older children (3–18 lat).  -->
<script>
/*
 * Poniższy blok zastępuje standardową funkcję generateCentileChart() oraz dodaje szereg funkcji
 * pomocniczych umożliwiających generowanie dwóch oddzielnych wykresów PDF: jeden dla dzieci
 * młodszych niż 3 lata (0–35 miesięcy) w oparciu o siatki Palczewskiej i Niedźwieckiej, oraz
 * drugi dla wieku 3–18 lat (36–216 miesięcy) oparty na projekcie OLAF.  W przypadku gdy
 * przedział wiekowy przekracza 3. rok życia (minAll <36 i maxAll >36), generowane są dwie
 * strony PDF.  Wszystkie funkcje są deklaracjami funkcyjnymi, dzięki czemu nadpisują wcześniejsze
 * deklaracje o tej samej nazwie w pierwszym skrypcie.
 */

// Bezpiecznie znajdź kanał centylowy dla podanej wartości.  Zwraca indeks kanału (0..len-2) lub -1.
function findHighlightBandSafe(userVal, curves, percentiles, mIdx) {
  if (!Number.isFinite(mIdx)) return -1;
  const anyP = percentiles[0];
  if (!curves[anyP]) return -1;
  const n = curves[anyP].length;
  if (mIdx < 0 || mIdx >= n) return -1;
  const vals = percentiles.map(p => curves[p][mIdx]);
  for (let i = 0; i < vals.length - 1; i++) {
    const a = vals[i], b = vals[i + 1];
    if (a == null || b == null) continue;
    const lo = Math.min(a, b), hi = Math.max(a, b);
    if (userVal >= lo && userVal <= hi) return i;
  }
  return -1;
}

// Zbierz wszystkie wieki (miesiące) z danych podstawowych i zaawansowanych.
function collectAllAgesMonths(ageMonths, adv) {
  const ages = [ageMonths];
  if (adv) {
    if (Number.isFinite(adv.currentAgeMonths)) ages.push(adv.currentAgeMonths);
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const am = Number(m.ageMonths);
        if (Number.isFinite(am)) ages.push(am);
      });
    }
  }
  const minAll = Math.min(...ages);
  const maxAll = Math.max(...ages);
  return { ages, minAll, maxAll };
}

// Filtruj i sortuj pomiary mieszczące się w określonym zakresie stron (wieku).
function collectPageMeasurementsInRange(rangeMinX, rangeMaxX, { currentAgeMonths, currentWeight, currentHeight, adv }) {
  const ptsH = [];
  const ptsW = [];
  if (adv && Array.isArray(adv.measurements)) {
    adv.measurements.forEach(m => {
      const am = Number(m.ageMonths);
      if (!Number.isFinite(am) || am < rangeMinX || am > rangeMaxX) return;
      // Nie używaj Number() dla wartości wzrostu i wagi w pomiarach historycznych,
      // ponieważ Number(null) zamienia null na 0, co powoduje błędne rysowanie punktu 0.
      // Zamiast tego, zastosuj parseFloat() i obsłuż null/undefined/puste pola jako NaN.
      const hRaw = m.height;
      const wRaw = m.weight;
      // Użyj parseFloat() do konwersji tylko wtedy, gdy pole nie jest puste
      const h = (hRaw !== null && hRaw !== undefined && hRaw !== '') ? parseFloat(hRaw) : NaN;
      const w = (wRaw !== null && wRaw !== undefined && wRaw !== '') ? parseFloat(wRaw) : NaN;
      // Jeśli wzrost lub waga są NaN lub nie dodatnie, pomiń je. W rzeczywistości 0 oznacza brak danych,
      // dlatego traktujemy 0 lub wartości ujemne jako brakujące i nie rysujemy takich punktów.
      if (Number.isFinite(h) && h > 0) ptsH.push({ ageMonths: am, height: h });
      if (Number.isFinite(w) && w > 0) ptsW.push({ ageMonths: am, weight: w });
    });
  }
  if (Number.isFinite(currentAgeMonths) && currentAgeMonths >= rangeMinX && currentAgeMonths <= rangeMaxX) {
    // Dodaj bieżący pomiar tylko, gdy waga/wzrost są dodatnie
    if (Number.isFinite(currentHeight) && currentHeight > 0) ptsH.push({ ageMonths: currentAgeMonths, height: currentHeight });
    if (Number.isFinite(currentWeight) && currentWeight > 0) ptsW.push({ ageMonths: currentAgeMonths, weight: currentWeight });
  }
  if (adv && Number.isFinite(adv.currentAgeMonths) && adv.currentAgeMonths >= rangeMinX && adv.currentAgeMonths <= rangeMaxX) {
    if (Number.isFinite(adv.currentHeight) && adv.currentHeight > 0) ptsH.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
    if (Number.isFinite(adv.currentWeight) && adv.currentWeight > 0) ptsW.push({ ageMonths: adv.currentAgeMonths, weight: adv.currentWeight });
  }
  ptsH.sort((a,b) => a.ageMonths - b.ageMonths);
  ptsW.sort((a,b) => a.ageMonths - b.ageMonths);
  return { ptsH, ptsW };
}

// Zbuduj jedną stronę (0–35 miesięcy Palczewska lub 36–216 miesięcy OLAF) jako canvas.
function buildCentilePageCanvas({
  rangeMinX, rangeMaxX, sex, userAgeMonths, userWeight, userHeight,
  headerTitle, headerSubtitle, footerText
}) {
  // Przygotuj dane centylowe
  const months = [];
  for (let m = rangeMinX; m <= rangeMaxX; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n,10)).sort((a,b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  const usePalczewska = rangeMaxX <= 35;
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        const [Lw,Mw,Sw] = getLMSWeightHybrid(sex, m);
        const [Lh,Mh,Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }
  // Gładzenie krzywych
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice(); const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) tmp[i] = (out[i-1] + out[i] + out[i+1]) / 3;
      out = tmp;
    }
    return out;
  }
  for (const p of percentiles) {
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  // Ustal pierwotne zakresy Y
  let minW = +Infinity, maxW = -Infinity, minH = +Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  const roundDown5 = v => Math.floor(v/5)*5;
  const roundUp5   = v => Math.ceil(v/5)*5;
  minW = roundDown5(minW); maxW = roundUp5(maxW);
  minH = roundDown5(minH); maxH = roundUp5(maxH);
  // Dynamika – dostosuj zakresy Y do aktualnych pomiarów na tej stronie
  const adv = window.advancedGrowthData || null;
  const { ptsH, ptsW } = collectPageMeasurementsInRange(rangeMinX, rangeMaxX, {
    currentAgeMonths: userAgeMonths,
    currentWeight: userWeight,
    currentHeight: userHeight,
    adv
  });
  // Zainicjuj zakresy pomiarów na podstawie bieżących danych tylko wtedy,
  // gdy waga/wzrost są dodatnie. Zero lub ujemne wartości oznaczają brak danych.
  let minMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : +Infinity;
  let maxMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : -Infinity;
  let minMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : +Infinity;
  let maxMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : -Infinity;
  ptsW.forEach(p => { if (p.weight < minMeasuredW) minMeasuredW = p.weight; if (p.weight > maxMeasuredW) maxMeasuredW = p.weight; });
  ptsH.forEach(p => { if (p.height < minMeasuredH) minMeasuredH = p.height; if (p.height > maxMeasuredH) maxMeasuredH = p.height; });
  let dynMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;
  let dynMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;
  const scaledW = (dynMinW !== minW) || (dynMaxW !== maxW);
  const scaledH = (dynMinH !== minH) || (dynMaxH !== maxH);
  // Tworzenie płótna
  const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw; canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, pw, ph);
  // Nagłówek
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(headerTitle, pw/2, 60);
  if (headerSubtitle) {
    ctx.font = '40px sans-serif';
    ctx.fillStyle = '#444';
    ctx.fillText(headerSubtitle, pw/2, 60 + 72 + 8);
  }
  // Imię i nazwisko
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'left';
  const nameLabel = nameFromState ? `Imię i nazwisko: ${nameFromState}` : 'Imię i nazwisko: _________________________________';
  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // Wymiary wykresów
  const chartW = pw - 200;
  const availH = ph - 300;
  const interChartMargin = 100;
  const chartsAreaH = availH - interChartMargin;
  let heightGridH, weightGridH;
  if (scaledW || scaledH) {
    const hRange = dynMaxH - dynMinH;
    const wRange = dynMaxW - dynMinW;
    let tmpH = chartsAreaH * (hRange / (hRange + wRange || 1));
    let tmpW = chartsAreaH - tmpH;
    const minHFrac = chartsAreaH * 0.30;
    if (tmpH < minHFrac) { tmpH = minHFrac; tmpW = chartsAreaH - tmpH; }
    heightGridH = tmpH; weightGridH = tmpW;
  } else {
    heightGridH = chartsAreaH / 2; weightGridH = chartsAreaH / 2;
  }
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Podświetlenie kanałów
  // Ustal „efektywne” dane do podświetlenia: jeśli użytkownik korzysta
  // z sekcji Zaawansowane, bieżący wiek/wzrost/masa mogą być wprowadzone
  // właśnie tam (np. uzupełniono tylko w formularzu zaawansowanym).
  const advForHighlight = window.advancedGrowthData || {};
  // Weź wiek z sekcji zaawansowanej, jeśli istnieje i jest liczbą
  const effectiveAgeMonths = (typeof advForHighlight.currentAgeMonths === 'number' && !isNaN(advForHighlight.currentAgeMonths))
    ? advForHighlight.currentAgeMonths
    : userAgeMonths;
  const effectiveHeight = (typeof advForHighlight.currentHeight === 'number' && !isNaN(advForHighlight.currentHeight))
    ? advForHighlight.currentHeight
    : userHeight;
  const effectiveWeight = (typeof advForHighlight.currentWeight === 'number' && !isNaN(advForHighlight.currentWeight))
    ? advForHighlight.currentWeight
    : userWeight;
  const mIdxForPage = effectiveAgeMonths - rangeMinX;
  const hBandIdx = findHighlightBandSafe(effectiveHeight, heightCurves, percentiles, mIdxForPage);
  const wBandIdx = findHighlightBandSafe(effectiveWeight, weightCurves, percentiles, mIdxForPage);
  // Rysuj wzrost
  drawCentileGrid(ctx, {
    x: 100, y: yHeightGrid, w: chartW, h: heightGridH,
    curves: heightCurves,
    minY: dynMinH, maxY: dynMaxH,
    // Do rysowania punktu użytkownika korzystaj z efektywnych wartości (z sekcji
    // Zaawansowane, jeśli tam zostały podane), tak aby marker odzwierciedlał
    // aktualne dane niezależnie od formularza głównego.
    userVal: effectiveHeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Wzrost (cm)', units: 'cm',
    percentiles, highlightBandIdx: hBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxH > maxH) ? maxH : undefined
  });
  // Linie i punkty historii wzrostu
  (function drawHeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    if (ptsH.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsH.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsH.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();
  // Rysowanie markerów wieku kostnego (aktualny i historyczne) na wykresie wzrostu
  (function drawBoneAgeMarkers() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    // Skopiuj marginesy i obliczenia skali z rysowania historii wzrostu
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    // Aktualny wiek kostny
    if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths) &&
        typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
      const boneAgeM = adv.boneAgeMonths;
      if (boneAgeM >= rangeMinX && boneAgeM <= rangeMaxX) {
        const cxBone = pxBase + (boneAgeM - rangeMinX) * xScale;
        const cyBone = pyBase + phBase - (adv.currentHeight - dynMinH) * yScale;
        const cxCurrent = pxBase + (adv.currentAgeMonths - rangeMinX) * xScale;
        // pozioma linia
        ctx.beginPath();
        ctx.strokeStyle = '#00838d';
        ctx.lineWidth = 2;
        ctx.moveTo(cxBone, cyBone);
        ctx.lineTo(cxCurrent, cyBone);
        ctx.stroke();
        // kropka z pierścieniem
        ctx.beginPath();
        ctx.fillStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
        ctx.stroke();
      }
    }
    // Historyczne wieki kostne
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const hVal = (typeof m.height === 'number' || typeof m.height === 'string') ? parseFloat(m.height) : NaN;
        const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string') ? parseFloat(m.ageMonths) : NaN;
        const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string') ? parseFloat(m.boneAgeYears) : NaN;
        if (!isNaN(hVal) && !isNaN(ageM) && !isNaN(bVal)) {
          const mBoneMonths = Math.round(bVal * 12);
          if (mBoneMonths >= rangeMinX && mBoneMonths <= rangeMaxX && hVal >= dynMinH && hVal <= dynMaxH) {
            const cxB = pxBase + (mBoneMonths - rangeMinX) * xScale;
            const cyB = pyBase + phBase - (hVal - dynMinH) * yScale;
            const cxCurrM = pxBase + (ageM - rangeMinX) * xScale;
            // linia pozioma
            ctx.beginPath();
            ctx.strokeStyle = '#00838d';
            ctx.lineWidth = 2;
            ctx.moveTo(cxB, cyB);
            ctx.lineTo(cxCurrM, cyB);
            ctx.stroke();
            // kropka z pierścieniem
            ctx.beginPath();
            ctx.fillStyle = '#00838d';
            ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00838d';
            ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
      });
    }
    ctx.restore();
  })();

  // Rysowanie markera docelowego wzrostu (Target Height) na wykresie wzrostu.
  // Marker jest rysowany jako czerwony romb w wieku 18 lat (216 mies.) z etykietą „TH xx,x cm”.
  (function drawTargetHeightMarker() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    const th = adv.targetHeight;
    // Sprawdź, czy docelowy wzrost jest liczbą.
    if (typeof th !== 'number' || isNaN(th)) return;
    // Umieszczamy znacznik w wieku 18 lat (216 mies.).  Rysuj tylko na stronach
    // obejmujących ten wiek (np. 3–18 lat); dla zakresu 0–3 lat znacznik nie jest wyświetlany.
    const mAgeTH = 216;
    if (mAgeTH < rangeMinX || mAgeTH > rangeMaxX) return;
    // Wymiary wykresu wzrostu (ponownie wykorzystujemy marginesy jak w drawHeightHistory).
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    // Oblicz współrzędne rombu.
    const cx = pxBase + (mAgeTH - rangeMinX) * xScale;
    const cy = pyBase + phBase - (th - dynMinH) * yScale;
    // Tylko rysuj, jeśli punkt mieści się w zakresie osi Y.
    if (th < dynMinH || th > dynMaxH) return;
    ctx.save();
    // Rysuj romb w kolorze czerwonym (#c62828)
    ctx.beginPath();
    ctx.fillStyle = '#c62828';
    ctx.moveTo(cx - 10, cy);
    ctx.lineTo(cx, cy - 10);
    ctx.lineTo(cx + 10, cy);
    ctx.lineTo(cx, cy + 10);
    ctx.closePath();
    ctx.fill();
    // Etykieta z wartością docelowego wzrostu (TH)
    const label = 'TH ' + th.toFixed(1) + ' cm';
    ctx.font = 'bold 40px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, cx + 14, cy);
    ctx.restore();
  })();
  // Rysuj wagę
  drawCentileGrid(ctx, {
    x: 100, y: yWeightGrid, w: chartW, h: weightGridH,
    curves: weightCurves,
    minY: dynMinW, maxY: dynMaxW,
    // Analogicznie jak dla wzrostu, dla punktu użytkownika używamy wartości
    // efektywnych (z sekcji zaawansowanej, jeśli podano).
    userVal: effectiveWeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Waga (kg)', units: 'kg',
    percentiles, highlightBandIdx: wBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxW > maxW) ? maxW : undefined
  });
  // Linie i punkty historii wagi
  (function drawWeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yWeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = weightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxW - dynMinW);
    ctx.save();
    if (ptsW.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsW.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsW.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();
  // Stopka (źródło danych)
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  const footerY = ph - 60 + 50;
  ctx.fillText(footerText, pw - 120, footerY);
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  return canvas;
}

// Główna funkcja generująca PDF.  Tworzy jedną lub dwie strony w zależności od tego,
// czy dane przekraczają próg 3 lat.
async function generateCentileChart() {
  const ageEl = document.getElementById('age');
  const ageMonthsEl = document.getElementById('ageMonths');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  const yearsVal = parseFloat(ageEl.value) || 0;
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  const ageYears = yearsVal + monthsVal/12;
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = (sexEl.value === 'M') ? 'M' : 'F';
  if (!Number.isFinite(ageYears) || !Number.isFinite(weight) || !Number.isFinite(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  const ageMonths = Math.round(ageYears * 12);
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  const adv = window.advancedGrowthData || null;
  const { minAll, maxAll } = collectAllAgesMonths(ageMonths, adv);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  function addPage({ minX, maxX, subtitle, footer }) {
    const canvas = buildCentilePageCanvas({
      rangeMinX: minX, rangeMaxX: maxX, sex,
      userAgeMonths: ageMonths, userWeight: weight, userHeight: height,
      headerTitle: (sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki'),
      headerSubtitle: subtitle,
      footerText: footer
    });
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  }
  const spansAcross3yo = (minAll < 36) && (maxAll > 36);
  if (spansAcross3yo) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
    pdf.addPage();
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  } else if (maxAll <= 35) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
  } else {
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  }
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
// === KONIEC NOWEJ IMPLEMENTACJI SIATKI CENTYLOWEJ ===
</script>

<!-- Skrypt generujący siatkę centylową DS (wzrost i waga) w formacie PDF -->
<script>
// === DOWN SYNDROME (DS) GROWTH CHARTS → PDF (0–20 lat) ==================
// Wymaga: ds_lms.js (window.DS), drawCentileGrid(), valueFromLMS(), getLMSFromDataset(),
// CENTILE_ZSCORES oraz biblioteki jsPDF (już są w tej stronie).
(function(){
  const ZS = (typeof CENTILE_ZSCORES === 'object' && CENTILE_ZSCORES) || {3:-1.8808,10:-1.281552,25:-0.67448975,50:0,75:0.67448975,90:1.281552,97:1.8808};
  const hasGetLMS = (typeof getLMSFromDataset === 'function');
  const hasValLMS = (typeof valueFromLMS === 'function');
  function getLMSFromDatasetSafe(dataset, m){
    if (hasGetLMS) return getLMSFromDataset(dataset, m);
    const keys = Object.keys(dataset).map(k=>parseInt(k,10)).sort((a,b)=>a-b);
    if (dataset[m]) return dataset[m];
    let lo = keys[0], hi = keys[keys.length-1];
    for (let i=0;i<keys.length;i++){ if (keys[i] <= m) lo = keys[i]; if (keys[i] >= m){ hi = keys[i]; break; } }
    const vLo = dataset[lo], vHi = dataset[hi];
    if (!vLo || !vHi) return vLo || vHi;
    if (lo === hi) return vLo;
    const t = (m-lo)/(hi-lo);
    return [ vLo[0]+t*(vHi[0]-vLo[0]), vLo[1]+t*(vHi[1]-vLo[1]), vLo[2]+t*(vHi[2]-vLo[2]) ];
  }
  function valueFromLMSSafe(L,M,S,z){
    if (hasValLMS) return valueFromLMS(L,M,S,z);
    return (L !== 0) ? (M * Math.pow(1 + L*S*z, 1/L)) : (M * Math.exp(S*z));
  }
  function yearsToMonthsMap(objYears){
    const out = {};
    Object.keys(objYears || {}).forEach(k=>{
      const m = Math.round(parseFloat(k)*12);
      out[m] = objYears[k];
    });
    return out;
  }
  const DS_DATA = (typeof window !== 'undefined' && window.DS) ? window.DS : null;
  const CHILD_W_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_GIRLS)  : {};
  const CHILD_W_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_BOYS)   : {};
  const CHILD_H_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_GIRLS)  : {};
  const CHILD_H_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_BOYS)   : {};
  function dsGetLMSWeight(sex, m){
    if (!DS_DATA) return null;
    if (m <= 36){
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_WEIGHT_BOYS : DS_DATA.DS_INFANT_WEIGHT_GIRLS, m);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_W_B : CHILD_W_G, m);
    }
  }
  function dsGetLMSHeight(sex, m){
    if (!DS_DATA) return null;
    if (m < 36){
      const mm = Math.max(1, m);
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_LENGTH_BOYS : DS_DATA.DS_INFANT_LENGTH_GIRLS, mm);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_H_B : CHILD_H_G, m);
    }
  }
  const DS_PERCENTILES = [3,10,25,50,75,90,97];
  /*
   * Krótkie wygładzanie krzywych centylowych dla dzieci z zespołem Downa.
   * Zastosowano prosty filtr średniej kroczącej (okno 3, 6 przebiegów),
   * podobnie jak w siatkach centylowych OLAF.  Dzięki temu linie krzywych
   * DS są bardziej płynne i pozbawione ostrych załamań.
   *
   * @param {number[]} arr  Tablica wartości centylowych do wygładzenia
   * @param {number}   passes Liczba przebiegów wygładzania (domyślnie 6)
   * @returns {number[]} Wygładzona tablica
   */
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice();
    const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      out = tmp;
    }
    return out;
  }
  function buildCurves(minX, maxX, sex, lmsGetter){
    const curves = {};
    DS_PERCENTILES.forEach(p=>{
      const z = ZS[p];
      const arr = [];
      for (let m=minX; m<=maxX; m++){
        const lms = lmsGetter(sex, m);
        arr.push(lms ? valueFromLMSSafe(lms[0], lms[1], lms[2], z) : null);
      }
      curves[p] = arr;
    });
    return curves;
  }
  function rangeFromCurves(curves){
    let lo = +Infinity, hi = -Infinity;
    Object.values(curves).forEach(arr=>{
      arr.forEach(v=>{ if (v==null) return; if (v<lo) lo=v; if (v>hi) hi=v; });
    });
    if (!isFinite(lo) || !isFinite(hi)){ lo = 0; hi = 1; }
    const pad = 0.05*(hi-lo);
    lo = Math.floor((lo - pad)/5)*5;
    hi = Math.ceil ((hi + pad)/5)*5;
    return [lo, hi];
  }
  function findHighlightBandLocal(userVal, curves, percentiles, mIdx){
    if (!Number.isFinite(mIdx)) return -1;
    const anyP = percentiles[0];
    if (!curves[anyP]) return -1;
    const n = curves[anyP].length;
    if (mIdx < 0 || mIdx >= n) return -1;
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i=0;i<vals.length-1;i++){
      const a = vals[i], b = vals[i+1];
      if (a==null || b==null) continue;
      const lo = Math.min(a,b), hi = Math.max(a,b);
      if (userVal >= lo && userVal <= hi) return i;
    }
    return -1;
  }
  function findBand(userVal, curves, percentiles, mIdx){
    if (typeof findHighlightBandSafe === 'function'){
      return findHighlightBandSafe(userVal, curves, percentiles, mIdx);
    }
    return findHighlightBandLocal(userVal, curves, percentiles, mIdx);
  }
  function generateDsCentileChart(){
    const ageEl    = document.getElementById('age');
    const ageMEl   = document.getElementById('ageMonths');
    const sexEl    = document.getElementById('sex');
    const weightEl = document.getElementById('weight');
    const heightEl = document.getElementById('height');
    if (!ageEl || !sexEl || !weightEl || !heightEl){
      alert('Wprowadź wiek, płeć, wagę i wzrost.');
      return;
    }
    const years  = parseFloat(ageEl.value)   || 0;
    const months = ageMEl ? (parseFloat(ageMEl.value) || 0) : 0;
    const ageMonths = Math.round(years*12 + months);
    if (!(ageMonths >= 0 && ageMonths <= 240)){
      alert('Siatka DS dostępna dla wieku 0–20 lat.');
      return;
    }
    const sex = (sexEl.value === 'M') ? 'M' : 'F';
    const w   = parseFloat(weightEl.value);
    const h   = parseFloat(heightEl.value);
    const minX = 0, maxX = 240;
    const weightCurves = buildCurves(minX, maxX, sex, dsGetLMSWeight);
    const heightCurves = buildCurves(minX, maxX, sex, dsGetLMSHeight);
    // Wygładź krzywe DS przy użyciu tego samego algorytmu co w siatkach OLAF
    for (const p of DS_PERCENTILES) {
      if (Array.isArray(weightCurves[p])) {
        weightCurves[p] = smoothCurve(weightCurves[p], 6);
      }
      if (Array.isArray(heightCurves[p])) {
        heightCurves[p] = smoothCurve(heightCurves[p], 6);
      }
    }
    const [wMin, wMax] = rangeFromCurves(weightCurves);
    const [hMin, hMax] = rangeFromCurves(heightCurves);
    const canvas = document.createElement('canvas');
    canvas.width  = 2480;
    canvas.height = 3508;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const topBox = { x:80, y:40, w:canvas.width-160, h:Math.floor(canvas.height/2) - 100 };
    const botBox = { x:80, y:Math.floor(canvas.height/2)+60, w:canvas.width-160, h:Math.floor(canvas.height/2) - 120 };
    const hiBandH = (Number.isFinite(h) ? findBand(h, heightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: topBox.x, y: topBox.y, w: topBox.w, h: topBox.h,
      curves: heightCurves,
      minY: hMin, maxY: hMax,
      userVal: Number.isFinite(h) ? h : undefined,
      userAgeMonths: ageMonths,
      title: 'Wzrost (cm)',
      units: 'cm',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandH,
      minX, maxX
    });
    const hiBandW = (Number.isFinite(w) ? findBand(w, weightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: botBox.x, y: botBox.y, w: botBox.w, h: botBox.h,
      curves: weightCurves,
      minY: wMin, maxY: wMax,
      userVal: Number.isFinite(w) ? w : undefined,
      userAgeMonths: ageMonths,
      title: 'Waga (kg)',
      units: 'kg',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandW,
      minX, maxX
    });
    ctx.save();
    ctx.font = '30px sans-serif';
    ctx.fillStyle = '#555555';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    // Przesuń napisy w dolnej części siatki o dodatkową jednostkę (1 rem ≈ 50 px)
    // aby uniknąć nałożenia się na etykietę osi wieku. Dzięki temu tekst źródła
    // („Dane DS: Zemel et al., Pediatrics 2015…”) oraz nazwa kliniki („vildaclinic.pl”)
    // znajdują się niżej o ok. 50 px w stosunku do poprzedniej wersji.
    const dsFooterY = canvas.height - 80 + 50;
    ctx.fillText('Dane DS: Zemel et al., Pediatrics 2015 (0–20 lat)', canvas.width - 120, dsFooterY);
    ctx.textAlign = 'left';
    ctx.fillText('vildaclinic.pl', 120, dsFooterY);
    ctx.restore();
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
    const blob = pdf.output('blob');
    const url  = URL.createObjectURL(blob);
    window.open(url, '_blank');
  }
  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('generateDsCentileChart');
    if (btn) {
      btn.addEventListener('click', generateDsCentileChart);
    }
  });
})();
</script>
<!-- Liquid iOS26 UI script: applies glassmorphism and micro‑interactions. The version query
     string busts the service worker cache so updated code is loaded immediately. -->
<script src="ios26-ui.js?v=2" defer></script>
<!-- Guided tutorial for first‑time users -->
<script src="tutorial.js" defer></script>

<!-- Moduł ciśnienia krwi: oblicza percentyle ciśnienia na podstawie wieku,
     wzrostu, płci oraz wprowadzonych wartości skurczowych i rozkurczowych.
     Skrypt ten powinien być ładowany po głównych plikach app.js i innych
     modułach, aby korzystał z istniejących funkcji pomocniczych (np. getAgeDecimal, getLMSHeightHybrid, applyPulse). -->
<script src="bp_module.js" defer></script>

<!-- Moduł obwodów głowy i klatki piersiowej.  
     Skrypt powinien być ładowany po module ciśnienia krwi, aby mieć dostęp do funkcji pomocniczych jak applyPulse.
     Określenie defer gwarantuje, że skrypt uruchomi się po załadowaniu struktury DOM. -->
<script src="circumference_module.js" defer></script>

<!-- Prosta obsługa przycisku rozwijającego kartę obwodów głowy i klatki piersiowej.
     Po załadowaniu DOM przypinamy zdarzenie click do przycisku toggleCircSection,
     które przełącza widoczność karty #circCard. -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const toggleBtn = document.getElementById('toggleCircSection');
    const circCard = document.getElementById('circCard');
    if (toggleBtn && circCard) {
      toggleBtn.addEventListener('click', function() {
        if (circCard.style.display === 'none' || circCard.style.display === '') {
          circCard.style.display = 'block';
        } else {
          circCard.style.display = 'none';
        }
      });
    }
  });
</script>

<!-- Register the service worker for offline support and updates.
     W trybie debugowania możesz całkowicie wyłączyć rejestrację,
     aby uniknąć problemów z cache – ustaw DEBUG_SW na true/false poniżej. -->
<script>
  (function() {
    const DEBUG_SW = false; // Ustaw na false, aby zarejestrować service worker na serwerze home.pl
    if (!DEBUG_SW && 'serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker-kalorii.js')
          .then(function(registration) {
            console.log('Service worker registered with scope:', registration.scope);
          })
          .catch(function(error) {
            console.error('Service worker registration failed:', error);
          });
      });
    } else {
      console.log('Service worker registration skipped (DEBUG_SW = true)');
    }
  })();
</script>
  <!-- Skrypt obsługujący podsumowanie metaboliczne.  
       Funkcja ta generuje tekstowe podsumowanie wyników obliczeń (centyle, Z‑score)  
       i kopiuje je do schowka.  
       Odczytuje aktualny tryb wyników (standardowy/profesjonalny) z localStorage,
       dzięki czemu zawartość podsumowania reaguje na przełącznik wyników. -->
  <script>
    // Podsumowanie metaboliczne – obsługa przycisku i generowania wyników
    document.addEventListener('DOMContentLoaded', function() {
      const summarySection = document.getElementById('metabolicSummarySection');
      const summaryBtn = document.getElementById('metabolicSummaryBtn');
      // Funkcja kontrolująca widoczność przycisku podsumowania
      function updateMetabolicSummaryVisibility() {
        const ageYears  = parseFloat(document.getElementById('age')?.value) || 0;
        const weightVal = parseFloat(document.getElementById('weight')?.value) || 0;
        const heightVal = parseFloat(document.getElementById('height')?.value) || 0;
        if (summarySection) {
          summarySection.style.display = (ageYears > 0 && weightVal > 0 && heightVal > 0) ? 'block' : 'none';
        }
      }
      ['age','ageMonths','weight','height'].forEach(function(id){
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener('input', updateMetabolicSummaryVisibility);
          el.addEventListener('change', updateMetabolicSummaryVisibility);
        }
      });
      // Ustaw widoczność przy inicjalizacji
      updateMetabolicSummaryVisibility();

      // Funkcja generująca tekst podsumowania. Korzysta z funkcji globalnych app.js i modułów,
      // ale obliczenia są wykonywane niezależnie od interfejsu wyświetlającego wyniki.  
      function generateMetabolicSummary() {
        const lines = [];
        // Odczytaj tryb wyników: 'professional' → tryb profesjonalny (włącz Z‑score)
        // Użyj globalnej zmiennej professionalMode ustawianej w app.js, aby
        // zagwarantować zgodność z aktualnym stanem przełącznika wyników.
        // Jeśli zmienna nie jest dostępna (np. w starszych wersjach), odczytaj z localStorage.
        let professional;
        if (typeof professionalMode !== 'undefined') {
          professional = !!professionalMode;
        } else {
          professional = (localStorage.getItem('resultsMode') === 'professional');
        }
        const yearsInput  = document.getElementById('age');
        const monthsInput = document.getElementById('ageMonths');
        const weightInput = document.getElementById('weight');
        const heightInput = document.getElementById('height');
        const sexInput    = document.getElementById('sex');
        const ageYears  = yearsInput  ? parseFloat(yearsInput.value)   || 0 : 0;
        const ageMonths = monthsInput ? parseFloat(monthsInput.value) || 0 : 0;
        const age       = ageYears + ageMonths / 12;
        const weightVal = weightInput ? parseFloat(weightInput.value) || 0 : 0;
        const heightVal = heightInput ? parseFloat(heightInput.value)|| 0 : 0;
        const sex       = sexInput && sexInput.value ? sexInput.value : 'M';
        // Oblicz centyle wagi i wzrostu (użyj odpowiedniego zestawu danych)
        if (age > 0 && weightVal > 0 && heightVal > 0) {
          // Określ źródło danych BMI z zaznaczonego suwaka (Palczewska, OLAF, WHO)
          const dataSourceEl = document.querySelector('input[name="dataSource"]:checked');
          const dataSource   = dataSourceEl ? dataSourceEl.value : 'OLAF';
          let statsW, statsH;
          // Wybierz Palczewską dla wszystkich wieku, jeśli wybrano Palczewską,
          // lub dla OLAF gdy wiek < 3 lata (brak danych OLAF dla niemowląt)
          const usePal = (dataSource === 'PALCZEWSKA') || (dataSource === 'OLAF' && age < 3);
          if (typeof calcPercentileStatsPal === 'function' && typeof calcPercentileStats === 'function') {
            if (usePal) {
              statsW = calcPercentileStatsPal(weightVal, sex, age, 'WT');
              statsH = calcPercentileStatsPal(heightVal, sex, age, 'HT');
            } else {
              statsW = calcPercentileStats(weightVal, sex, age, 'WT');
              statsH = calcPercentileStats(heightVal, sex, age, 'HT');
            }
          }
          // Oblicz wartości graniczne 3. i 97. centyla dla wagi i wzrostu,
          // które zostaną użyte do wyświetlenia różnicy w podsumowaniu.
          let w3, w97, h3, h97;
          if (statsW && statsH) {
            const monthsWH = Math.round(age * 12);
            if (usePal) {
              // granice z siatek Palczewskiej
              if (typeof getPalCentile === 'function') {
                w3  = getPalCentile(sex, monthsWH, 3, 'WT');
                w97 = getPalCentile(sex, monthsWH, 97, 'WT');
                h3  = getPalCentile(sex, monthsWH, 3, 'HT');
                h97 = getPalCentile(sex, monthsWH, 97, 'HT');
              }
            } else {
              // granice z funkcji LMS (WHO/OLAF)
              if (typeof getChildLMS === 'function') {
                const lmsW = getChildLMS(sex, age, 'WT');
                if (lmsW) {
                  w3 = (lmsW[0] !== 0)
                       ? lmsW[1] * Math.pow(1 + lmsW[0] * lmsW[2] * Z3, 1 / lmsW[0])
                       : lmsW[1] * Math.exp(lmsW[2] * Z3);
                  w97 = (lmsW[0] !== 0)
                        ? lmsW[1] * Math.pow(1 + lmsW[0] * lmsW[2] * Z97, 1 / lmsW[0])
                        : lmsW[1] * Math.exp(lmsW[2] * Z97);
                }
                const lmsH = getChildLMS(sex, age, 'HT');
                if (lmsH) {
                  h3 = (lmsH[0] !== 0)
                       ? lmsH[1] * Math.pow(1 + lmsH[0] * lmsH[2] * Z3, 1 / lmsH[0])
                       : lmsH[1] * Math.exp(lmsH[2] * Z3);
                  h97 = (lmsH[0] !== 0)
                         ? lmsH[1] * Math.pow(1 + lmsH[0] * lmsH[2] * Z97, 1 / lmsH[0])
                         : lmsH[1] * Math.exp(lmsH[2] * Z97);
                }
              }
            }
          }
          // Waga: sformatowany centyl i różnica do 3./97. centyla
          if (statsW && statsW.percentile != null) {
            // Używamy formatCentile() do reprezentacji wartości skrajnych (<1, >99,9)
            let percStrW = (typeof formatCentile === 'function') ? formatCentile(statsW.percentile) : Math.round(statsW.percentile).toString();
            let wordW = (typeof centylWord === 'function') ? centylWord(percStrW) : 'centyl';
            // Dekoduj encje HTML na zwykłe znaki (HTML jest używany w formatCentile)
            let decodedW = percStrW.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
            let line = 'Waga: ' + decodedW + ' ' + wordW;
            if (professional && typeof statsW.sd === 'number' && isFinite(statsW.sd)) {
              line += ' (Z‑score = ' + statsW.sd.toFixed(2) + ')';
            }
            // Jeśli waga jest poniżej 3. centyla (po zaokrągleniu), pokaż różnicę do 3. centyla
            const roundedWeight = Math.round(statsW.percentile);
            if (typeof w3 === 'number' && roundedWeight <= 2) {
              line += ', brakuje ' + (w3 - weightVal).toFixed(1) + '\u202Fkg do 3\u202Fcentyla';
            }
            // Jeśli waga jest ponad 97. centyl, pokaż nadwyżkę
            if (typeof w97 === 'number' && statsW.percentile >= 98) {
              line += ', +' + (weightVal - w97).toFixed(1) + '\u202Fkg ponad 97\u202Fcentyl';
            }
            lines.push(line);
          }
          // Wzrost: sformatowany centyl i różnica do 3./97. centyla
          if (statsH && statsH.percentile != null) {
            let percStrH = (typeof formatCentile === 'function') ? formatCentile(statsH.percentile) : Math.round(statsH.percentile).toString();
            let wordH = (typeof centylWord === 'function') ? centylWord(percStrH) : 'centyl';
            let decodedH = percStrH.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
            let line = 'Wzrost: ' + decodedH + ' ' + wordH;
            if (professional && typeof statsH.sd === 'number' && isFinite(statsH.sd)) {
              line += ' (Z‑score = ' + statsH.sd.toFixed(2) + ')';
            }
            const roundedHeight = Math.round(statsH.percentile);
            if (typeof h3 === 'number' && roundedHeight <= 2) {
              line += ', brakuje ' + (h3 - heightVal).toFixed(1) + '\u202Fcm do 3\u202Fcentyla';
            }
            if (typeof h97 === 'number' && statsH.percentile >= 98) {
              line += ', +' + (heightVal - h97).toFixed(1) + '\u202Fcm ponad 97\u202Fcentyl';
            }
            lines.push(line);
          }
          // BMI: wartość, centyl, z‑score
          if (weightVal > 0 && heightVal > 0) {
            const bmiVal = weightVal / ((heightVal/100) * (heightVal/100));
            const months = Math.round(age * 12);
            let bmiPerc = null;
            let bmiZ   = null;
            if (usePal && typeof calcPercentileStatsPal === 'function') {
              const statsB = calcPercentileStatsPal(bmiVal, sex, age, 'BMI');
              if (statsB) {
                bmiPerc = statsB.percentile;
                bmiZ   = statsB.sd;
              }
            } else {
              if (typeof bmiPercentileChild === 'function') {
                bmiPerc = bmiPercentileChild(bmiVal, sex, months);
              }
              if (typeof bmiZscore === 'function') {
                bmiZ   = bmiZscore(bmiVal, sex, months);
              }
            }
            if (bmiPerc != null && isFinite(bmiPerc)) {
              // Użyj formatCentile do reprezentacji skrajnych percentyli BMI (<1, >99,9)
              let percStrBMI = (typeof formatCentile === 'function') ? formatCentile(bmiPerc) : Math.round(bmiPerc).toString();
              let wordBMI    = (typeof centylWord === 'function') ? centylWord(percStrBMI) : 'centyl';
              let decodedBMI = percStrBMI.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
              let line = 'BMI: ' + bmiVal.toFixed(1) + ' – ' + decodedBMI + ' ' + wordBMI;
              if (professional && bmiZ != null && isFinite(bmiZ)) {
                line += ' (Z‑score = ' + bmiZ.toFixed(2) + ')';
              }
              lines.push(line);
            }
          }
          // Powierzchnia ciała (BSA) – Haycock
          if (weightVal > 0 && heightVal > 0) {
            const bsa = 0.024265 * Math.pow(weightVal, 0.5378) * Math.pow(heightVal, 0.3964);
            lines.push('Pow. ciała: ' + bsa.toFixed(2) + ' m²');
          }
          // Wskaźnik Cole’a (procentowa relacja BMI do mediany BMI)
          if (typeof getLMS === 'function') {
            const monthsL = Math.round(age * 12);
            const lms = getLMS(sex, monthsL);
            if (lms && Array.isArray(lms) && lms.length > 1 && lms[1] > 0) {
              const bmiVal2 = weightVal / ((heightVal/100) * (heightVal/100));
              const cole = (bmiVal2 / lms[1]) * 100;
              lines.push('Wskaźnik Cole’a: ' + cole.toFixed(1) + '%');
            }
          } else if (typeof window !== 'undefined' && window.colePercentValue != null) {
            // Fallback: skorzystaj z obliczonej wartości globalnej, jeśli dostępna
            try {
              lines.push('Wskaźnik Cole’a: ' + window.colePercentValue.toFixed(1) + '%');
            } catch (e) {}
          }
        }
        // Dodaj ciśnienie tętnicze, jeśli wartości globalne są ustawione
        if (typeof window !== 'undefined') {
          if (window.percSbp != null) {
            let sbpLine = 'Ciśnienie skurczowe: ' + Math.round(window.percSbp) + ' centyl';
            if (professional && typeof window.zSbp === 'number' && isFinite(window.zSbp)) {
              sbpLine += ' (Z‑score = ' + window.zSbp.toFixed(2) + ')';
            }
            lines.push(sbpLine);
          }
          if (window.percDbp != null) {
            let dbpLine = 'Ciśnienie rozkurczowe: ' + Math.round(window.percDbp) + ' centyl';
            if (professional && typeof window.zDbp === 'number' && isFinite(window.zDbp)) {
              dbpLine += ' (Z‑score = ' + window.zDbp.toFixed(2) + ')';
            }
            lines.push(dbpLine);
          }
          if (window.headCircPercentile != null) {
            let headLine = 'Obwód głowy: ' + Math.round(window.headCircPercentile) + ' centyl';
            if (professional && typeof window.headCircSD === 'number' && isFinite(window.headCircSD)) {
              headLine += ' (Z‑score = ' + window.headCircSD.toFixed(2) + ')';
            }
            lines.push(headLine);
          }
          if (window.chestCircPercentile != null) {
            let chestLine = 'Obwód klatki piersiowej: ' + Math.round(window.chestCircPercentile) + ' centyl';
            if (professional && typeof window.chestCircSD === 'number' && isFinite(window.chestCircSD)) {
              chestLine += ' (Z‑score = ' + window.chestCircSD.toFixed(2) + ')';
            }
            lines.push(chestLine);
          }
          // Dodaj dane z modułu zaawansowanego wzrostu, jeśli dostępne
          if (window.advancedGrowthData && typeof window.advancedGrowthData === 'object') {
            const ag = window.advancedGrowthData;
            if (typeof ag.currentVelocity === 'number' && isFinite(ag.currentVelocity)) {
              lines.push('Tempo wzrastania: ' + ag.currentVelocity.toFixed(1) + ' cm/rok');
            }
            if (ag.targetHeight) {
              // Upewnij się, że liczba jest sformatowana z jedną cyfrą po przecinku
              const thVal = parseFloat(ag.targetHeight);
              // Zmieniono etykietę na MPH (mid‑parental height)
              let thLine = 'MPH (mid-parental height): ' + (isNaN(thVal) ? ag.targetHeight : thVal.toFixed(1)) + ' cm';
              // Użyj targetStats, jeśli dostępny – zawiera percentile i z‑score
              if (ag.targetStats && typeof ag.targetStats.percentile === 'number') {
                const cent = Math.round(ag.targetStats.percentile);
                if (professional && typeof ag.targetStats.sd === 'number' && isFinite(ag.targetStats.sd)) {
                  thLine += ' – centyl: ' + cent + ', z-score: ' + ag.targetStats.sd.toFixed(2);
                } else {
                  thLine += ' – centyl: ' + cent;
                }
              }
              lines.push(thLine);
              // W trybie profesjonalnym oblicz różnicę pomiędzy Z‑score aktualnego wzrostu (hSDS)
              // a z‑score potencjału wzrostowego (mpSDS). Umożliwia to ocenę, na ile bieżący
              // wzrost dziecka odbiega od przewidywanego na podstawie wzrostu rodziców.
              if (professional && ag.targetStats && typeof ag.targetStats.sd === 'number') {
                // Oblicz Z‑score aktualnego wzrostu używając tego samego źródła danych co w innych częściach
                // podsumowania. Nie odwołuj się do zmiennej usePal z innego zakresu, aby uniknąć błędu.
                let statsHeightDiff = null;
                // Ponownie odczytaj wybrane źródło danych (Palczewska, OLAF, WHO) i ustal, czy użyć Palczewskiej
                const dsEl = document.querySelector('input[name="dataSource"]:checked');
                const dsVal = dsEl ? dsEl.value : 'OLAF';
                const usePalForDiff = (dsVal === 'PALCZEWSKA') || (dsVal === 'OLAF' && age < 3);
                if (typeof calcPercentileStatsPal === 'function' && typeof calcPercentileStats === 'function') {
                  if (usePalForDiff) {
                    statsHeightDiff = calcPercentileStatsPal(heightVal, sex, age, 'HT');
                  } else {
                    statsHeightDiff = calcPercentileStats(heightVal, sex, age, 'HT');
                  }
                }
                if (statsHeightDiff && typeof statsHeightDiff.sd === 'number') {
                  const diffSummary = statsHeightDiff.sd - ag.targetStats.sd;
                  lines.push('hSDS - mpSDS: ' + diffSummary.toFixed(2));
                }
              }
            }
          }
        }
        return lines.join('\n');
      }
      // Funkcja kopiująca tekst do schowka; używa Clipboard API z fallbackiem
      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
        } else {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
          } catch (e) {}
          document.body.removeChild(textarea);
          return Promise.resolve();
        }
      }
      // Pokazuje krótki komunikat na dole ekranu z potwierdzeniem kopiowania
      function showMetabolicToast() {
        const toast = document.createElement('div');
        toast.textContent = 'Dane zostały skopiowane do schowka.';
        toast.style.position = 'fixed';
        toast.style.bottom = '1rem';
        toast.style.left = '50%';
        toast.style.transform = 'translateX(-50%)';
        toast.style.background = '#00838d';
        toast.style.color = 'white';
        toast.style.padding = '0.6rem 1.2rem';
        toast.style.borderRadius = '4px';
        toast.style.fontSize = '1rem';
        toast.style.zIndex = '9999';
        document.body.appendChild(toast);
        setTimeout(() => {
          toast.remove();
        }, 2500);
      }
      if (summaryBtn) {
        summaryBtn.addEventListener('click', function() {
          const text = generateMetabolicSummary();
          copyToClipboard(text).then(() => {
            showMetabolicToast();
          });
        });
      }
    });
  </script>

  <!-- Debug output for currentSummaryCard status (temporary) -->
  <!-- Usunięto paski debugowe -->

  <!-- Profesjonalny overlay wymuszający potwierdzenie uprawnień lekarza.
       Jest domyślnie ukryty i pojawia się po poprawnej weryfikacji numeru PWZ,
       jeśli użytkownik nie potwierdził jeszcze komunikatu lub minęło ponad 30 dni.
       Warstwa przyciemnia cały ekran, a użytkownik musi wybrać jedną z opcji:
       „Potwierdzam” – przechodzi do modułu lekarskiego, „Wychodzę” – wraca na stronę główną. -->
  <div id="professionalOverlay">
    <div class="professional-overlay-inner">
      <h3>Moduł profesjonalny</h3>
      <p>Informacje prezentowane w tym module mają charakter wyłącznie edukacyjny i są przeznaczone dla lekarzy. Nie powinny one stanowić podstawy do podejmowania decyzji diagnostycznych ani terapeutycznych.</p>
      <div class="professional-overlay-buttons">
        <button type="button" id="professionalConfirmBtn" class="professional-confirm-btn">Potwierdzam</button>
        <button type="button" id="professionalExitBtn" class="professional-exit-btn">Wychodzę</button>
      </div>
    </div>
  </div>

  <!-- Overlay pytający o zapamiętanie numeru PWZ.  Styl i rozmiar zgodne z overlayem
       modułu profesjonalnego.  Użytkownik ma dwie możliwości: „Tak” –
       numer zostanie zapisany w localStorage, „Nie” – numer nie zostanie
       zapisany. -->
  <div id="rememberPwzOverlay">
    <div class="remember-overlay-inner">
      <h3>Zapamiętać numer PWZ?</h3>
      <p>Czy zapamiętać podany numer prawa wykonywania zawodu w tej przeglądarce?</p>
      <div class="remember-overlay-buttons">
        <button type="button" id="rememberPwzYesBtn" class="remember-yes-btn">Tak</button>
        <button type="button" id="rememberPwzNoBtn" class="remember-no-btn">Nie</button>
      </div>
    </div>
  </div>

  <!-- Baner cookies / lokalnego przechowywania danych -->
<div id="consent-banner" class="cookie-banner hidden">
  <p>
    Korzystając z aplikacji <strong>Vilda Clinic</strong> zapisujemy niewielkie ilości danych w Twojej przeglądarce:
  </p>
  <ul>
    <li><strong>Pliki niezbędne:</strong> Service Worker zapisuje pliki aplikacji (HTML, CSS, JavaScript, grafiki) w Cache Storage, aby umożliwić działanie offline. Nie zbiera żadnych danych osobowych.</li>
    <li><strong>Pamięć funkcjonalna:</strong> Po weryfikacji numeru PWZ możesz zdecydować, czy zapamiętać go w tej przeglądarce. Numer zostanie zapisany w localStorage wyłącznie w Twoim urządzeniu i nie jest nigdzie wysyłany.</li>
    <li><strong>Analityka:</strong> Google Analytics (GA4) używa własnych plików cookie, aby tworzyć anonimowe statystyki odwiedzin. Nie zapisuje danych wpisywanych w aplikacji. Zgoda na analitykę jest dobrowolna i możesz ją wycofać.</li>
  </ul>
  <div class="cookie-buttons">
    <button id="consent-accept">Akceptuję analitykę</button>
    <button id="consent-decline">Odrzucam analitykę</button>
  </div>
</div>
  <!-- Przycisk "powrót na górę" widoczny w widoku mobilnym. Po kliknięciu
       przenosi użytkownika na szczyt strony. Ikona jest generowana przez
       bibliotekę Lucide. -->
  <button id="scrollTopBtn" aria-label="Powrót na górę strony" type="button" onclick="scrollToTop()">
    <i data-lucide="arrow-up"></i>
  </button>

  <!--
       Własne poprawki: łączenie kart "Podsumowanie wyników" w widoku
       jednokolumnowym oraz wyłączenie automatycznego przewijania przy
       przełączaniu trybu wyników na wąskich ekranach.
       Plik custom-fixes.js implementuje te funkcje poprzez
       obserwację DOM i modyfikację scrollIntoView. -->
  <script src="custom-fixes.js" defer></script>

    <!-- Overlay for Z‑score batch conversion loading animation.  When the user starts
         the batch Z‑score calculation, this overlay is displayed for a short
         time to symbolise processing.  The animation is defined in the
         accompanying JSON file (bad_cat.json) and rendered via the Lottie
         player. -->
    <div id="zscoreLoadingOverlay">
      <!-- The animation is loaded from the original JSON file "Bad Cat.json".
           Spaces are automatically encoded by the browser when fetching the file. -->
      <lottie-player id="zscoreAnimation" src="Bad Cat.json" background="transparent"
                     speed="1" style="width: 200px; height: 200px;" loop autoplay>
      </lottie-player>
    </div>

  <!-- Skrypt aktywujący moduł lekarski na stronie DocPro. Po załadowaniu
       strony automatycznie zaznacza ukryty checkbox #isDoctor i wywołuje
       zdarzenie `change`, aby uruchomić logikę z app.js odpowiedzialną za
       pokazanie pola PWZ oraz pozostałych elementów modułu. -->
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const isDoc = document.getElementById('isDoctor');
      if (isDoc) {
        // Ustaw checkbox jako zaznaczony i wywołaj zdarzenie 'change' w kolejnej
        // pętli zdarzeń. Dzięki setTimeout(… , 0) mamy pewność, że logika
        // zdefiniowana w app.js (nasłuchująca na zmianę checkboxa) została
        // już zainicjowana, a zdarzenie nie zostanie zgubione.
        setTimeout(() => {
          isDoc.checked = true;
          isDoc.dispatchEvent(new Event('change'));
        }, 0);
      }
    });
  </script>

</body>
</html>
