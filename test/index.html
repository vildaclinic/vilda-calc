<!DOCTYPE html>
<html lang="pl">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EZZTNV8W07"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EZZTNV8W07');
</script>
<meta charset="utf-8" />
    <!--
      Poniżej znajdują się zoptymalizowane pod SEO meta tagi dla strony vildaclinic.pl.
      Zmieniono tytuł strony i dodano meta tagi opisowe, słowa kluczowe, Open Graph,
      kanoniczny oraz robots.  Pamiętaj, że atrybut „og:image” powinien wskazywać na
      obraz dostępny pod domeną wagaiwzrost.pl.  W tym projekcie korzystamy z
      przygotowanego pliku wagaiwzrost‑og.jpg umieszczonego w katalogu images.
    -->
    <title>wagaiwzrost.pl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <!-- Zaktualizowany opis: akcentujemy markę Waga i wzrost oraz kluczowe funkcje aplikacji -->
    <meta name="description" content="Waga i wzrost – kompleksowy kalkulator BMI, siatek centylowych, WHR, BMR oraz zapotrzebowania kalorycznego. Zawiera moduł lekarski z testami hormonalnymi i terapią GH/IGF‑1. Darmowe narzędzie edukacyjne Vilda Clinic">
    <meta name="keywords" content="kalkulator BMI, niskorosłość, zespół Downa, siatki centylowe, zdrowie dzieci, wzrost dziecka, niedowaga, nadwaga, otyłość, plan odchudzania, dieta redukcyjna, kalkulator kalorii, analiza WHR, zapotrzebowanie kaloryczne, testy hormonalne, testy endokrynologiczne, hormon wzrostu, terapia hormonem wzrostu, IGF-1">
    <!-- Open Graph tags for social sharing -->
    <meta property="og:title" content="Waga i wzrost">
    <meta property="og:description" content="Waga i wzrost – kompleksowy kalkulator BMI, siatek centylowych, WHR, BMR oraz zapotrzebowania kalorycznego. Zawiera moduł lekarski z testami hormonalnymi i terapią GH/IGF‑1. Darmowe narzędzie edukacyjne Vilda Clinic">
    <meta property="og:url" content="https://wagaiwzrost.pl/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Waga i wzrost">
    <!-- Dodajemy znacznik og:image wraz z rozmiarami. Grafika powinna znajdować się w katalogu images/ -->
    <meta property="og:image" content="images/wagaiwzrost-og.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <!-- Canonical URL ensures search engines treat the root domain as the main page -->
    <link rel="canonical" href="https://wagaiwzrost.pl/">
    <!-- Robots directive instructs crawlers to index and follow links -->
    <meta name="robots" content="index, follow">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet"/>
<!-- Zmieniamy nazwę pliku stylów na style_PWZ.css -->
<link href="ios26-v2.css" rel="stylesheet">
<link href="style.css" rel="stylesheet">
<link href="sidebar.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js" defer></script>

  <!-- Progressive Web App meta tags and manifest -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#00838d">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Waga i wzrost">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="msapplication-TileColor" content="#00838d">
  <meta name="msapplication-TileImage" content="pwa-icons/icon-144x144.png">
  <!-- iOS touch icons -->
  <link rel="apple-touch-icon" sizes="120x120" href="pwa-icons/icon-120x120.png">
  <link rel="apple-touch-icon" sizes="152x152" href="pwa-icons/icon-152x152.png">
  <link rel="apple-touch-icon" sizes="167x167" href="pwa-icons/icon-167x167.png">
  <link rel="apple-touch-icon" sizes="180x180" href="pwa-icons/icon-180x180.png">
  <!-- Place these in your <head> -->
<link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="144x144" href="/favicon-144x144.png">
<link rel="icon" type="image/png" sizes="512x512" href="/favicon-512x512.png">
<link rel="shortcut icon" href="/favicon.ico">
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@graph": [
          {
            "@type": "Organization",
            "@id": "https://wagaiwzrost.pl/#org",
            "name": "Vilda Clinic sp. z o.o.",
            "legalName": "Vilda Clinic sp. z o.o.",
            "url": "https://vildaclinic.pl",
            "logo": {
              "@type": "ImageObject",
              "url": "https://wagaiwzrost.pl/logo_vilda.jpeg"
            },
            "address": {
              "@type": "PostalAddress",
              "streetAddress": "ul. 28 Czerwca 1956 r. 261",
              "postalCode": "61‑485",
              "addressLocality": "Poznań",
              "addressCountry": "PL"
            },
            "contactPoint": [
              { "@type": "ContactPoint", "contactType": "customer support", "telephone": "+48 692 109 156", "email": "biuro@vildaclinic.pl" },
              { "@type": "ContactPoint", "contactType": "customer support", "telephone": "+48 888 555 045" }
            ],
            "identifier": [
              { "@type": "PropertyValue", "propertyID": "PL-NIP", "value": "7831823044" },
              { "@type": "PropertyValue", "propertyID": "REGON", "value": "38684406100000" },
              { "@type": "PropertyValue", "propertyID": "KRS", "value": "0000856633" }
            ],
            "sameAs": ["https://vildaclinic.pl"]
          },
          {
            "@type": "Person",
            "@id": "https://wagaiwzrost.pl/#dr-flader",
            "name": "dr n. med. Maciej Flader",
            "jobTitle": "Autor merytoryczny",
            "affiliation": { "@id": "https://wagaiwzrost.pl/#org" },
            "identifier": {
              "@type": "PropertyValue",
              "propertyID": "PWZ",
              "value": "2315523"
            }
          },
          {
            "@type": "WebSite",
            "@id": "https://wagaiwzrost.pl/#website",
            "name": "Waga i wzrost",
            "url": "https://wagaiwzrost.pl/",
            "publisher": { "@id": "https://wagaiwzrost.pl/#org" },
            "inLanguage": "pl‑PL"
          },
          {
            "@type": "WebPage",
            "@id": "https://wagaiwzrost.pl/#homepage",
            "name": "Waga i wzrost — kalkulatory BMI, siatki centylowe i więcej",
            "url": "https://wagaiwzrost.pl/",
            "isPartOf": { "@id": "https://wagaiwzrost.pl/#website" },
            "publisher": { "@id": "https://wagaiwzrost.pl/#org" },
            "reviewedBy": { "@id": "https://wagaiwzrost.pl/#dr-flader" },
            "inLanguage": "pl‑PL",
            "isAccessibleForFree": true
          }
        ]
      }
      </script>
</head>
<!-- Dodajemy klasę "liquid-ios26" bezpośrednio na element <body>,
     aby motyw Liquid Glass był stosowany od samego początku ładowania strony.
     Dzięki temu unikamy krótkiego błysku podstawowych stylów zanim skrypt
     ios26-ui.js dołączy klasę dynamicznie. -->
<body class="liquid-ios26">

<header>
<div class="container">
  <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">
    <img src="logo_vilda.jpeg" alt="Vilda Clinic – strona główna"
         style="max-width:160px;margin-bottom:10px; border-radius:var(--radius);">
  </a>
  <h1>Waga i wzrost</h1>
</div>
  <!-- Nawigacja ułatwiająca przejście do podstrony opisującej aplikację.
       Dodajemy ją przed zamknięciem nagłówka, aby była dostępna zarówno
       dla użytkowników, jak i robotów wyszukiwarek. -->
  <nav class="main-nav" aria-label="Główna nawigacja">
  <ul>
    <!-- Przycisk hamburgera zastępujący link „Strona główna”.
         Po kliknięciu rozwija dodatkowe menu z sekcjami informacyjnymi.
         Składa się z trzech poziomych linii. -->
    <li class="menu-toggle">
      <!-- Ukryty checkbox sterujący otwieraniem i zamykaniem menu.  
           Po zaznaczeniu rozwija pionową listę z linkami. -->
      <input type="checkbox" id="navToggle" class="nav-toggle">
      <label for="navToggle" aria-label="Otwórz menu">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
      </label>
      <!-- Pionowe menu przeniesione wewnątrz elementu li, aby  
           można było sterować jego widocznością za pomocą checkboxa. -->
      <ul id="verticalMenu" class="vertical-menu">
        <!--
          Dodajemy dwie pierwsze pozycje do menu hamburgera: „Zapisz dane” oraz
          „Wczytaj dane”.  Oba elementy zostały przeniesione z sekcji formularza.
          Przyciski mają atrybut title, który zawiera krótkie wyjaśnienie
          kiedy opcja jest aktywna.  Tekst podpowiedzi pojawia się na
          hover/dotknięcie przycisku, gdy jest on wyłączony.
        -->
        <li>
          <!--
            Używamy elementu <a> z rolą „button” zamiast tradycyjnego <button>,
            ponieważ globalne style motywu Liquid Glass modyfikują wszystkie
            przyciski.  Link zachowuje się jak przycisk dzięki atrybutowi
            role="button" oraz zdarzeniom obsługiwanym w JavaScript.  Atrybut
            title podpowiada, dlaczego opcja jest nieaktywna.  Atrybut disabled
            (niestandardowy dla <a>) służy do oznaczania stanu i jest
            wykorzystywany w skryptach i stylach.
          -->
          <a id="saveDataBtn" role="button" disabled href="#"
             data-tip="Aby zapisać dane, wprowadź imię, wiek, wzrost i wagę.">
            Zapisz dane
          </a>
        </li>
        <li>
          <!--
            Link „Wczytaj dane” działa jak przycisk.  Jest dostępny tylko na
            początku sesji; gdy formularz zawiera już informacje, zostaje
            dezaktywowany w JavaScript.  Atrybut title informuje, kiedy
            opcja staje się nieaktywna.
          -->
          <a id="loadDataBtn" role="button" href="#"
             data-tip="Wczytywanie danych jest możliwe tylko na początku sesji, zanim wprowadzisz nowe dane.">
            Wczytaj dane
          </a>
          <!-- Ukryty input obsługujący wybór pliku do wczytania danych -->
          <input type="file" id="fileInput" accept=".json,application/json" style="display:none;">
        </li>
        <!-- Istniejące pozycje informacyjne pozostają bez zmian -->
        <li><a href="/o-aplikacji.html">O aplikacji</a></li>
        <li><a href="/instrukcja.html">Instrukcja</a></li>
        <li><a href="https://www.vildaclinic.pl/kontakt" target="_blank" rel="noopener noreferrer">Kontakt</a></li>
      </ul>
    </li>
    <!-- Nowy odnośnik do kalkulatora klirensu. Umieszczamy go w głównej nawigacji,
         aby użytkownicy mieli do niego bezpośredni dostęp. -->
    <li><a href="/kalkulator-klirens.html">Klirens</a></li>
    <!-- Dodatkowa sekcja: kalkulator steroidów. Link prowadzi do strony sterydów,
         umieszczamy go pomiędzy klirensem a materiałami edukacyjnymi, aby
         zachować logiczny porządek nawigacji. -->
    <li><a href="/steroidy.html">Steroidy</a></li>
    <!-- Link do nowej podstrony z modułem lekarskim DocPro -->
    <li><a href="/docpro.html">DocPro</a></li>
    <!-- Dotychczasowa zakładka Materiały edukacyjne pozostaje bez zmian -->
    <li><a href="/materialy-edukacyjne.html">Materiały edukacyjne</a></li>
  </ul>
</nav>
</header>
<!--
  Wrap the main content in a two‑column desktop layout.  For desktop screens
  (>=992px) the sidebar on the left will house the navigation menu while
  the right column will contain the calculator form, results and other
  content.  On mobile screens the sidebar remains empty and the
  navigation stays in the header.  See reposition.js for dynamic
  relocation of the nav element.
-->
<div class="desktop-layout">
  <!-- Lewy sidebar – statyczne menu na desktopie -->
  <aside class="sidebar">
    <nav class="sidebar-nav" aria-label="Nawigacja boczna">
      <ul>
        <!-- 1. Zapisz dane -->
        <li>
          <a id="saveDataBtnSidebar" href="#" role="button" data-tip="Aby zapisać dane, wprowadź imię, wiek, wzrost i wagę."
            aria-disabled="true">
            <span class="sidebar-icon" data-lucide="save"></span>
            <span class="sidebar-label">Zapisz dane</span>
          </a>
        </li>
      
        <!-- 2. Wczytaj dane -->
        <li>
          <a id="loadDataBtnSidebar" href="#" role="button"
            data-tip="Wczytywanie danych jest możliwe tylko na początku sesji, zanim wprowadzisz nowe dane.">
            <span class="sidebar-icon" data-lucide="folder-open"></span>
            <span class="sidebar-label">Wczytaj dane</span>
          </a>
          <input type="file" id="fileInputSidebar" accept=".json,application/json" style="display:none;">
        </li>
      
        <!-- 3. Strona główna -->
        <li>
          <a href="/">
            <span class="sidebar-icon" data-lucide="home"></span>
            <span class="sidebar-label">Strona główna</span>
          </a>
        </li>
      
        <!-- 4. DocPro -->
        <li>
          <a href="/docpro.html">
            <span class="sidebar-icon" data-lucide="stethoscope"></span>
            <span class="sidebar-label">DocPro</span>
          </a>
        </li>
      
        <!-- 5. Klirens -->
        <li>
          <a href="/kalkulator-klirens.html">
            <span class="sidebar-icon" data-lucide="droplets"></span>
            <span class="sidebar-label">Klirens</span>
          </a>
        </li>
      
        <!-- 6. Steroidy -->
        <li>
          <a href="/steroidy.html">
            <span class="sidebar-icon" data-lucide="pill"></span>
            <span class="sidebar-label">Steroidy</span>
          </a>
        </li>
      
        <!-- 7. Materiały edukacyjne -->
        <li>
          <a href="/materialy-edukacyjne.html">
            <span class="sidebar-icon" data-lucide="book-open"></span>
            <span class="sidebar-label">Materiały edukacyjne</span>
          </a>
        </li>
      
        <!-- 8. Instrukcja -->
        <li>
          <a href="/instrukcja.html">
            <span class="sidebar-icon" data-lucide="file-text"></span>
            <span class="sidebar-label">Instrukcja</span>
          </a>
        </li>
      
        <!-- 9. O aplikacji -->
        <li>
          <a href="/o-aplikacji.html">
            <span class="sidebar-icon" data-lucide="info"></span>
            <span class="sidebar-label">O aplikacji</span>
          </a>
        </li>
      
        <!-- 10. Kontakt -->
        <li>
          <a href="https://www.vildaclinic.pl/kontakt" target="_blank" rel="noopener noreferrer">
            <span class="sidebar-icon" data-lucide="mail"></span>
            <span class="sidebar-label">Kontakt</span>
          </a>
        </li> </ul>
    </nav>
    </aside>
  <!-- Main content column: retains the original container and page content -->
  <div class="main-content">
<div class="container">
<form id="calcForm" onsubmit="return false;">
  <div class="half">
    <fieldset class="user-card"><legend>Dane użytkownika</legend>
      <!-- Zmodyfikowane pole wieku: lata oraz opcjonalnie miesiące -->
      <!-- Nowe pole imię i nazwisko -->
      <label>Imię i&nbsp;Nazwisko:
        <input type="text" id="name">
      </label>
      <label>Wiek (lata):
        <!-- Pozwalamy podać wiek w latach od 0 do 130; lata są wymagane -->
        <input type="number" id="age" min="0" max="130" oninput="debouncedUpdate()" required></label>
      <!-- Nowe pole na wiek w miesiącach; zakres 1–11, opcjonalne -->
      <label>Wiek (miesiące – opcjonalnie):
        <!--
          Umożliwiamy wpisywanie jedynie wartości od 1 do 11 (pełne miesiące).
          Pole pozostawione puste jest interpretowane jako brak dodatkowych miesięcy.
          Ustawiamy atrybut step="1" aby wymusić podawanie tylko liczb całkowitych.
        -->
        <input type="number" id="ageMonths" min="1" max="11" step="1" oninput="debouncedUpdate()"></label>
      <label>Płeć:
        <select id="sex" onchange="debouncedUpdate()">
          <option value="M">Mężczyzna</option>
          <option value="F">Kobieta</option>
        </select></label>
      <label>Waga (kg):
        <!-- Dostosowujemy zakres do niemowląt: mniejsza waga i możliwość wpisywania wartości z dokładnością do 0.1 kg -->
        <input type="number" id="weight" min="2" max="300" step="0.1" oninput="debouncedUpdate()" required></label>
      <label>Wzrost (cm):
        <!-- Dostosowujemy zakres do niemowląt: niższy wzrost i możliwość wpisywania wartości z dokładnością do 0.1 cm -->
        <input type="number" id="height" min="45" max="250" step="0.1" oninput="debouncedUpdate()" required></label>
        <!-- Komunikat informujący o wczytaniu danych. Jest domyślnie ukryty, a pojawia się dopiero po
             prawidłowym wczytaniu pliku JSON. Umieszczamy go tuż pod polem wzrostu,
             zgodnie z wymaganiami użytkownika, aby znajdował się pomiędzy polem wzrost
             a przyciskiem „Wczytaj dane”. Kolor i pogrubienie odpowiadają palecie motywu. -->
        <div id="loadDataMessage" style="display:none;color:var(--primary);font-weight:600;text-align:center;margin-top:0.5rem;">
          Dane zostały wczytane prawidłowo. Wprowadź nowe dane, aby zobaczyć najnowsze wyniki.
        </div>
        <!-- Przyciski usuwające wszystkie dane użytkownika umieszczamy pod ostatnim polem formularza. -->
        <div style="text-align:center; margin-top:1rem;">
          <!-- Pozostawiamy tylko przycisk czyszczący pola w tej sekcji.  Opcje
               zapisywania i wczytywania danych są przeniesione do menu hamburgera powyżej. -->
          <button type="button" id="clearAllDataBtn">Wyczyść wszystkie pola</button>
        </div>
        <!-- Przełącznik sposobu animacji ostrzeżeń (ciągły vs. jednorazowy puls) -->
        <div class="text-center" style="margin:.25rem 0 .75rem 0; display:none;">
          <label style="font-weight:600;">
            <input type="checkbox" id="pulseOnce"> Jednorazowa animacja ostrzeżeń (2&nbsp;s)
          </label>
        </div>
    </fieldset>
  </div>

  <!-- Pole dla lekarzy: kontrolka wejścia do modułu lekarskiego oraz weryfikacja numeru PWZ -->
  <div class="half">
    <!-- Przeniesione podsumowanie poprzednich pomiarów nad sekcję modułu lekarskiego.
         Karta jest domyślnie ukryta, a jej elementy są uporządkowane tutaj,
         dzięki czemu pojawia się przed przyciskiem „Przejdź do modułu lekarskiego”. -->
    <div id="prevSummaryWrap" aria-live="polite" style="display:none; width:100%;">
      <div id="prevSummaryCard" class="card summary-card" style="display:none;">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <h3 style="margin:0;">Ostatni pomiar</h3>
          <!-- przycisk ukrywania karty pozostaje w DOM, ale jest domyślnie niewidoczny,
               aby karta nie zwijała się automatycznie -->
          <button type="button" id="hidePrevSummary" class="secondary-btn" style="font-size:0.9rem; display:none;">Ukryj tę kartę</button>
        </div>
        <div id="prevSummaryContent" class="summary-grid" style="margin-top:0.6rem;"></div>
        <!-- Komunikat o pomyślnym wczytaniu danych umieszczony wewnątrz karty "Ostatni pomiar".
             Zgodnie z wymaganiami użytkownika tekst ten powinien pojawiać się na dole karty
             po wczytaniu pliku JSON i znikać po wprowadzeniu nowych danych.  Element jest
             domyślnie ukryty i sterowany w skryptach aplikacji. -->
        <div id="prevSummaryMessage" style="display:none;color:var(--primary);font-weight:600;text-align:center;margin-top:0.6rem;"></div>
      </div>
      <!-- Przycisk rozwijający podsumowanie. Ukrywamy go na stałe, ponieważ karta jest zawsze widoczna. -->
      <button type="button" id="togglePrevSummary" class="primary-btn" style="display:none; margin-top:0.5rem; width:100%;">
        Podsumowanie poprzednich pomiarów
      </button>
    </div>

    <!-- Karta „Podsumowanie wyników” – będzie wypełniana dynamicznie w JS.
         W normalnym trybie (gdy nie ma wczytanego poprzedniego pomiaru) karta
         pojawia się w prawej kolumnie obok danych użytkownika. W trybie
         porównawczym (gdy załadowano poprzedni pomiar) karta zostanie
         przeniesiona pod obie kolumny i podzielona na dwie kolumny o równej
         szerokości. -->
    <div id="currentSummaryWrap" style="display:none;">
      <div id="currentSummaryCard" class="card summary-card current-summary-card" style="display:none;">
        <h3 style="margin:0;">Podsumowanie wyników</h3>
        <div id="currentSummaryContent" class="summary-content"></div>
      </div>
    </div>
    <!-- Pojemnik pełnej szerokości na kartę podsumowania – używany tylko,
         gdy widoczna jest karta „Ostatni pomiar”. -->
    <div id="currentSummaryFullWrap" style="display:none;"></div>

    <!-- Dedykowany kontener na część przeznaczoną do przełączenia się w tryb lekarski.
         Używamy oddzielnego identyfikatora, aby w JS można było łatwo przenosić
         tę sekcję między kolumnami i widokiem mobilnym. -->
    <div id="doctorContainer">
      <!-- Moduł lekarski został przeniesiony na osobną podstronę DocPro. -->
    </div>
    <!-- Kontener na pole z numerem PWZ, ukryty do momentu zaznaczenia checkboxa -->
    <div id="pwzContainer" style="display:none; margin-top:0.7rem;">
      <label style="display:block; font-size:0.95rem;">
        Wpisz numer prawa wykonywania zawodu:
        <!--
          Zmieniono placeholder pola numeru PWZ tak, aby nie wyświetlał przykładowego
          numeru „5425740”. Użytkownik wprowadza tu 7‑cyfrowy numer prawa
          wykonywania zawodu, dlatego pozostawiamy pusty placeholder. Jeśli w
          przyszłości chcesz ponownie dodać opis, użyj neutralnego tekstu
          (np. „Wpisz numer PWZ”).
        -->
        <input type="text" id="pwzNumber" placeholder="" maxlength="7" pattern="\d{7}" autocomplete="off" style="margin-top:0.4rem;">
      </label>
      <div id="pwzError" style="color: var(--danger); margin-top:0.5rem; display:none; font-size:0.95rem;">
        Nieprawidłowy numer PWZ
      </div>
    </div>
    <!-- Moduł profesjonalny dostępny po pozytywnej weryfikacji numeru PWZ -->
    <div id="professionalModule" class="card" style="margin-top:1rem; display:none;">
      <h3 style="margin-top:0;">Moduł profesjonalny</h3>
      <!-- W tym akapicie umieszczamy informację dla lekarzy o charakterze edukacyjnym modułu. -->
      <!-- Do komunikatu w module profesjonalnym dodajemy klasę, która pozwala wygodnie sterować stylem z poziomu CSS. -->
      <p class="professional-message">Informacje prezentowane w tym module mają charakter wyłącznie edukacyjny i są przeznaczone dla lekarzy. Nie powinny one stanowić podstawy do podejmowania decyzji diagnostycznych ani terapeutycznych.</p>

      <!-- Sekcja testów stymulacyjnych GH została przeniesiona poza moduł profesjonalny. -->
    </div>
    <!-- Komunikaty po prawej stronie: błąd braku danych oraz instrukcja zapisu/wczytania
         Przenosimy komunikat „Podaj jednocześnie wiek, wagę i wzrost” do prawej kolumny formularza
         oraz umieszczamy pod nim informację o konieczności podania imienia i zapisania danych,
         a także link do materiału wideo z instrukcją (href pozostaw pusty, aby uzupełnić później). -->
    <div id="infoMessages" style="margin-top: 1rem;">
      <div id="errorBox"></div>
      <div id="compareInstruction" class="compare-instruction">
        Uzupełnij wymagane pola&nbsp;(wiek, waga i&nbsp;wzrost) oraz podaj imię, aby móc zapisać dane.
        Po zapisaniu i ponownym wczytaniu pliku w przyszłości w tym miejscu pojawi się porównanie aktualnych danych z&nbsp;poprzednimi.
      </div>
    </div>
  </div>
  <!-- Główne przyciski modułu lekarskiego – pojawiają się po pozytywnej weryfikacji numeru PWZ.
       Przycisk „Testy w endokrynologii” będzie służyć do rozwijania listy testów GH/OGTT/ACTH,
       a przycisk „Leczenie hormonem wzrostu / IGF-1” otworzy listę dodatkowych opcji IGF-1.
       Domyślnie oba przyciski są ukryte. -->
  <!-- Nowy przycisk: Antybiotykoterapia – sekcja kalkulatora dawek antybiotyków.
       Przycisk ten powinien pojawiać się wyłącznie po pozytywnej weryfikacji numeru PWZ
       (użytkownicy z prawem wykonywania zawodu). Sekcja ta zostanie osadzona nad
       przyciskiem „Testy w endokrynologii”.
       Domyślnie przycisk jest ukryty. -->
  <div id="abxButtonWrapper" style="display:none;">
    <button type="button" id="toggleAbxTherapy">Antybiotykoterapia</button>
  </div>
  <div id="endoButtonWrapper" style="display:none;">
    <button type="button" id="toggleEndoTests">Testy w endokrynologii</button>
  </div>
  <!-- Przyciski testów GH/OGTT/ACTH znajdują się poniżej i będą pokazywane po kliknięciu w powyższy przycisk. -->
  <!-- Kontener na przycisk uruchamiający testy stymulacyjne GH. Domyślnie ukryty;
       jest pokazywany dopiero po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ghButtonWrapper" style="display:none;">
    <button type="button" id="toggleGhTests">Testy stymulacyjne oceniające wydzielanie GH</button>
  </div>
  <!-- Dodatkowe kolumny z testami GH. Są ukryte, dopóki użytkownik nie kliknie przycisku. -->
  <div class="half gh-tests-left" id="ghTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z klonidyną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z glukagonem</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half gh-tests-right" id="ghTestsRight">
    <div class="card gh-test-card">
      <strong>Test z insuliną</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z argininą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
    <div class="card gh-test-card">
      <strong>Test z L‑Dopą</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę i wzrost, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- === NOWE TESTY: OGTT / GnRH i ACTH / TRH === -->
  <!-- Kontener na przycisk uruchamiający testy OGTT / GnRH. Domyślnie ukryty;
       pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="ogttButtonWrapper" style="display:none;">
    <button type="button" id="toggleOgttTests">Test OGTT / Test z GnRH/LHRH</button>
  </div>
  <!-- Kolumny dla testów OGTT i GnRH/LHRH -->
  <div class="half ogtt-tests-left" id="ogttTestsLeft">
    <div class="card gh-test-card">
      <strong>Test OGTT</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <div class="half ogtt-tests-right" id="ogttTestsRight">
    <div class="card gh-test-card">
      <strong>Test z GnRH/LHRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Kontener na przycisk uruchamiający testy ACTH / TRH. Domyślnie ukryty
       i pojawia się po pozytywnej weryfikacji numeru PWZ. -->
  <div id="acthButtonWrapper" style="display:none;">
    <button type="button" id="toggleActhTests">Test z dużą dawką ACTH / Test z TRH</button>
  </div>
  <!-- Kolumny dla testów ACTH i TRH -->
  <div class="half acth-tests-left" id="acthTestsLeft">
    <div class="card gh-test-card">
      <strong>Test z dużą dawką ACTH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Podaj wiek i wagę, aby obliczyć dawkę ACTH.</p>
    </div>
  </div>
  <div class="half acth-tests-right" id="acthTestsRight">
    <div class="card gh-test-card">
      <strong>Test z TRH</strong>
      <p style="margin-top:0.3rem; font-size:0.9rem;">Wprowadź wagę, aby obliczyć dawkę.</p>
    </div>
  </div>
  <!-- Przycisk otwierający listę leczenia hormonem wzrostu / IGF-1.  
       Domyślnie ukryty; pojawi się po pozytywnej weryfikacji numeru PWZ i pozostanie pod testami GH/OGTT/ACTH. -->
  <div id="igfButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgfTests" class="igf-btn">Leczenie hormonem wzrostu / IGF-1</button>
  </div>
  <!-- Podprzyciski IGF-1 (domyślnie ukryte; pokazują się po kliknięciu w „Leczenie hormonem wzrostu / IGF-1”). -->
  <div id="snpButtonWrapper" style="display:none;">
    <button type="button" id="toggleSnp" class="igf-btn">SNP</button>
  </div>
  <div id="turnerButtonWrapper" style="display:none;">
    <button type="button" id="toggleTurner" class="igf-btn">Zespół Turnera</button>
  </div>
  <div id="pwsButtonWrapper" style="display:none;">
    <button type="button" id="togglePws" class="igf-btn">Zespół PWS</button>
  </div>
  <div id="sgaButtonWrapper" style="display:none;">
    <button type="button" id="toggleSga" class="igf-btn">SGA</button>
  </div>
  <div id="igf1ButtonWrapper" style="display:none;">
    <button type="button" id="toggleIgf1" class="igf-btn">IGF-1</button>
  </div>
</form>

<!-- Komunikaty przeniesione: pole błędu i instrukcja zapisu/wczytania są teraz umieszczone w prawej kolumnie formularza (w sekcji lekarza) -->
<!-- Kontener na mobilne umiejscowienie przycisku przejścia do modułu lekarskiego.
     Ten element pozostaje pusty w widoku dwukolumnowym i jest używany
     wyłącznie przy wąskim oknie, gdy formularz zajmuje całą szerokość.
     Wówczas sekcja z napisem „Przejdź do modułu lekarskiego” wraz z
     podtytułem i checkboxem zostanie tutaj przeniesiona. -->
<div id="doctorMobileContainer"></div>
    <!-- Kontener dla modułu lekarskiego w widoku desktop – umieszczamy go pod kartami,
         aby sekcja „Przejdź do modułu lekarskiego” i pole numeru PWZ były
         wyśrodkowane poniżej kart.  W trybie mobilnym kontener ten jest
         ukrywany w JS. -->
    <div id="doctorBottom" class="doctor-bottom-container"></div>
  <div id="results" class="grid-two">
    <!-- Lewa kolumna: karta BMI oraz sekcja obliczeń dla dzieci z zespołem Downa
         Opakowujemy kartę BMI i blok DS wspólnym kontenerem, aby w układzie
         dwukolumnowym oba te elementy trafiły do tej samej kolumny. W układzie
         jednokolumnowym zachowana jest kolejność DOM: najpierw karta BMI,
         następnie sekcja DS. -->
    <div id="leftColumnWrap" class="left-column">
      <div class="card" id="bmiCard">
    <h2 style="text-align:center;">Centyle, BMI &amp; Basal Metabolic Rate</h2>
    <!-- Nowy przełącznik trybu wyników: Wyniki standardowe / Wyniki profesjonalne
         Umieszczamy go bezpośrednio pod nagłówkiem karty, aby użytkownik
         mógł łatwo przełączać się między trybem standardowym (domyślnym)
         a profesjonalnym. W trybie standardowym ukrywane są obliczenia
         Z‑score dla wagi, wzrostu i BMI. W trybie profesjonalnym
         wyświetlane są pełne wyniki wraz z wartościami Z‑score. -->
    <div id="resultsModeToggleContainer" class="toggle-wrap">
      <span class="label-left">Wyniki standardowe</span>
      <label class="switch">
        <input type="checkbox" id="resultsModeToggle">
        <span class="slider"></span>
      </label>
      <span class="label-right">Wyniki profesjonalne</span>
    </div>
    <!-- Adnotacja informująca, że dla dzieci <2 lat preferowanym wskaźnikiem jest waga/długość.  
         Umieszczamy ją bezpośrednio pod nagłówkiem karty tak, aby pojawiała się pomiędzy etykietą a wynikami.
         Właściwości wyglądu (kolor i rozmiar) są definiowane w pliku CSS; w stylu pozostawiamy jedynie display.
    -->
    <div id="wflReminderBMI" class="wfl-reminder" style="display:none;"></div>
    <div id="bmrInfo"></div>
    <!-- OLAF / WHO Toggle (poprawiony) -->
    <!-- Nowy trójpozycyjny suwak wyboru źródła danych (Palczewska/OLAF/WHO).
         Zastępuje dotychczasowy dwupozycyjny przełącznik. Umożliwia użytkownikowi
         wybranie jednego z trzech zestawów danych, przy czym OLAF pozostaje
         domyślnym wyborem dla dzieci ≥3 lat, a Palczewska dla niemowląt.
         Każdy segment jest przyciskiem radiowym; zaznaczony segment jest podświetlony.
    -->
    <div id="dataToggleContainer" class="data-source-toggle">
      <label>
        <input type="radio" name="dataSource" id="sourcePalczewska" value="PALCZEWSKA">
        <span>Palczewska</span>
      </label>
      <label>
        <input type="radio" name="dataSource" id="sourceOlaf" value="OLAF" checked>
        <span>OLAF</span>
      </label>
      <label>
        <input type="radio" name="dataSource" id="sourceWho" value="WHO">
        <span>WHO</span>
      </label>
    </div>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMI</strong> (Body Mass Index) to wskaźnik masy ciała obliczany jako
      stosunek masy (kg) do kwadratu wzrostu (m²). Pomaga ocenić, czy Twoja masa
      ciała jest prawidłowa, z niedowagą, nadwagą czy otyłością.
    </p>
    <p style="font-size:0.9rem;margin-top:0.5rem;">
      <strong>BMR</strong> (Basal Metabolic Rate) to ilość energii, jaką Twoje ciało zużywa w spoczynku
      – kalorie niezbędne na podstawowe procesy życiowe (oddychanie, krążenie, termoregulacja).
    </p>

    <!-- Wyśrodkowany przycisk do wygenerowania siatek centylowych wzrostu i wagi.  -->
    <div style="text-align:center;margin-top:1.2rem;">
      <!-- Ukryj przycisk generowania siatki centylowej w karcie "Centyle, BMI & Basal Metabolic Rate" -->
      <button type="button" id="generateCentileChart" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:none;">
        Generuj siatkę centylową
      </button>

      <!-- Nowy przycisk do generowania siatek centylowych opartych w całości na danych Palczewskiej (1–18 lat).
           Przycisk ten jest ukryty domyślnie i może być włączony w przyszłości w miejscu, w którym
           użytkownik wybiera źródło danych.  Stylowanie odpowiada innym przyciskom w aplikacji. -->
      <button type="button" id="generatePalCentileChart" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:none;">
        Generuj siatkę Palczewska
      </button>
    </div>

    <!-- Ukryty kontener na elementy generowane podczas tworzenia siatki centylowej.  
         Canvasy są tworzone dynamicznie w JS, a następnie konwertowane do obrazu.
         Kontener jest ukryty, aby nie wpływać na layout strony. -->
    <div id="centileCanvasContainer" style="display:none;"></div>
  </div>

      <!-- Placeholder usuniętego kontenera zaawansowanych obliczeń wzrostowych – zostanie on wstawiony w innym miejscu. -->
      <!-- Sekcja obliczeń DS: przycisk oraz karta z wynikami. Umieszczamy ją w
           kontenerze lewej kolumny pod kartą BMI. Sekcja jest początkowo
           ukryta; jej widoczność kontroluje JS w zależności od wieku. -->
      <!-- Moduł obliczania ciśnienia tętniczego u dzieci (RR)
           Karta z polami na ciśnienie skurczowe i rozkurczowe oraz wynikiem centylowym.
           Pozycjonujemy ją w lewej kolumnie powyżej sekcji obliczeń dla dzieci z zespołem Downa. -->
      <div id="bpCard" class="card">
        <h2 style="text-align:center;">Ciśnienie tętnicze u&nbsp;dzieci</h2>
        <!-- Przełącznik wyboru normy OLAF/NHBPEP dla ciśnienia. Wyświetlany jest tylko
             dla wieku 7–18 lat. Domyślnie pozycja niezaznaczona oznacza OLAF, zaznaczona – NHBPEP. -->
        <div id="bpToggleContainer" class="toggle-wrap" style="display:none;">
          <span class="label-left">OLAF 2010 Polska</span>
          <label class="switch">
            <input type="checkbox" id="bpDataToggle">
            <span class="slider"></span>
          </label>
          <span class="label-right">NHBPEP 4th Report</span>
        </div>
        <!-- Pola na wprowadzenie ciśnienia skurczowego i rozkurczowego.
             Umieszczamy je obok siebie w układzie elastycznym z niewielkim odstępem. -->
        <div class="bp-inputs" style="display:flex;flex-wrap:wrap;gap:.6rem;justify-content:center;">
          <label>Ciśnienie skurczowe (mm&nbsp;Hg):
            <input type="number" id="bpSystolic" min="40" max="200" step="1">
          </label>
          <label>Ciśnienie rozkurczowe (mm&nbsp;Hg):
            <input type="number" id="bpDiastolic" min="20" max="140" step="1">
          </label>
        </div>
        <!-- Kontener na wynik – wartości centylowe oraz klasyfikację. Początkowo pusty. -->
        <div id="bpResult" class="result-box" style="margin-top:.6rem;"></div>
      </div>

      <!-- Nowy moduł: Obwód głowy i klatki piersiowej.  
           Ta karta umożliwia ocenę centylową obwodu głowy oraz klatki piersiowej na podstawie siatek Instytutu Matki i Dziecka.
           Umieszczamy ją w lewej kolumnie bezpośrednio pod kartą ciśnienia tętniczego,
           ale przed sekcją obliczeń dla dzieci z zespołem Downa.  
           Całość jest ukryta w kartcie, która rozwija się po kliknięciu przycisku. -->
      <div id="circSection" style="margin-top:1rem;">
        <button type="button" id="toggleCircSection"
          style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
          Obwód głowy i klatki piersiowej
        </button>
        <div id="circCard" class="card" style="display:none;margin-top:1rem;">
          <h2 style="text-align:center;">Obwód głowy i klatki piersiowej</h2>
          <!-- Pola do wprowadzenia obwodu głowy i klatki piersiowej.  
               Użytkownik może wpisać jeden lub oba pomiary; wyniki pojawią się odpowiednio poniżej. -->
          <div class="circ-inputs" style="display:flex;flex-wrap:wrap;gap:.6rem;justify-content:center;">
            <label>Obwód głowy (cm):
              <input type="number" id="headCircumference" min="30" max="60" step="0.1">
            </label>
            <label>Obwód klatki piersiowej (cm):
              <input type="number" id="chestCircumference" min="30" max="80" step="0.1">
            </label>
          </div>
          <!-- Wyniki dla obwodu głowy i klatki piersiowej.  
               Elementy są wypełniane dynamicznie przez circumference_module.js. -->
          <div id="circHeadResult" class="result-box"></div>
          <div id="circChestResult" class="result-box"></div>
        </div>
      </div>

      <div id="downSyndromeSection" style="display:none;">
        <button type="button" id="toggleDownSyndrome" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;">
          Obliczenia dla dzieci z zespołem Downa
        </button>
        <div id="downSyndromeCard" class="card" style="display:none; margin-top:1rem;">
          <h2 style="text-align:center;">Obliczenia dla dzieci z&nbsp;zespołem Downa</h2>
          <div id="dsPercentiles" class="result-box"></div>
          <!-- Przyciski generowania siatki DS: umieszczamy go bezpośrednio pod sekcją wyników,
               zanim pojawi się pole obwodu głowy. Przyjemny układ z wyśrodkowaniem oraz
               odstępem górnym spójny z innymi przyciskami w aplikacji. -->
          <div class="text-center" style="margin-top:.6rem;">
            <button type="button" id="generateDsCentileChart">Generuj siatkę DS</button>
          </div>
          <label style="display:block;margin-top:.6rem;">Obwód głowy (cm):
            <input type="number" id="headCircumDS" min="25" max="60" step="0.1">
          </label>
          <div id="headCircumResultDS" class="result-box" style="display:none;margin-top:.5rem;"></div>
        </div>
      </div>
    </div><!-- /#leftColumnWrap -->


  <!-- Kontener grupujący kartę Wskaźnika Cole'a i drogę do normy BMI -->
    <!-- Prawa kolumna: kontener z kartami WFL, Cole'a, WHR, itp. Pozostaje
         niezmieniona. -->
    <div id="normWrapper" class="norm-wrapper">
    <!-- Nowa karta: wskaźnik waga do długości/wzrostu (WFL).  
         W układzie jednokolumnowym pojawia się nad kartą wskaźnika Cole’a,  
         w układzie dwukolumnowym po prawej stronie również nad kartą Cole’a.  
         Elementy w środku są wypełniane dynamicznie w JS. -->
    <div class="card" id="wflCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik waga do długości/wzrostu (WFL)</h2>
      <!-- W tej sekcji JS wstawia obliczony Z‑score oraz krótką informację o wyniku. -->
      <div id="wflInfo" class="result-box"></div>
      <!-- Krótkie wyjaśnienie lub interpretacja wyniku wskaźnika WFL.  
           Używamy tej samej klasy co w przypadku wskaźnika Cole’a, aby zachować spójny wygląd. -->
      <p id="wflExplanation" class="cole-explanation"></p>
      <!-- Tabela norm dla wskaźnika waga/wzrost; wypełniana w JS. -->
      <div id="wflNormTable" style="display:none;"></div>
    </div>

    <!-- Sekcja podsumowania metabolicznego.
         Pojawia się, gdy użytkownik uzupełni minimalny zestaw danych (wiek, waga, wzrost).
         Przycisk zachowuje biały kolor tła i czarną czcionkę, a szerokość jest taka sama jak w przypadku
         przycisku „Zaawansowane obliczenia wzrostowe”. Górny margines sekcji został usunięty,
         aby górna krawędź przycisku była wyrównana do górnej krawędzi karty „Centyle, BMI & Basal Metabolic Rate”. -->
    <div id="metabolicSummarySection" style="display:none;">
      <!-- Zmiana etykiety przycisku na bardziej opisową zgodnie z wymaganiem użytkownika.
           Użytkownik może kliknąć przycisk, aby skopiować podsumowanie wyników do schowka. -->
      <button type="button" id="metabolicSummaryBtn" data-metabolic-summary-btn
        style="background-color:#ffffff;color:#000000;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;width:100%;">
        Podsumowanie wyników - kliknij i skopiuj
      </button>
      <!-- Nowy przycisk: zalecenia dietetyczne. 
           Wyświetlany tylko w trybie profesjonalnym, gdy wyniki BMI/Cole’a/WHR wskazują na nadwagę lub otyłość.
           Po kliknięciu generuje spersonalizowane zalecenia dietetyczne i kopiuje je do schowka. -->
      <button type="button" id="dietRecommendationsBtn"
        style="background-color:#ffffff;color:#000000;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;width:100%;margin-top:0.6rem;">
        Zalecenia dietetyczne
      </button>
      <!-- Kontener na wyświetlane zalecenia dietetyczne. 
           Jest ukryty domyślnie i pojawia się po kliknięciu przycisku „Zalecenia dietetyczne”.
           Zawiera opcje wyboru strategii (redukcja vs stabilizacja), przycisk generowania
           oraz miejsce na wynik.  Współczynnik font-size jest zmniejszony, aby treść była
           lżejsza w odbiorze i zgodna z kartą wyników. -->
      <div id="dietRecommendationsContent" class="result-box" style="display:none;margin-top:0.6rem;text-align:left;font-size:0.875rem;">
        <!-- Opcje wyboru strategii diety i dodatkowych rekomendacji w formie przełączników -->
        <div id="dietStrategyOptions">
          <!-- Informacja dla użytkownika o konieczności ustawienia aktywności i diety w karcie Plan odchudzania -->
          <div class="diet-info-note">
            W karcie <strong>Plan odchudzania</strong> wybierz odpowiedni poziom aktywności i rodzaj diety lub pozostaw rekomendowane ustawienia.
          </div>
          <!-- Dwukolumnowy układ przełączników: lewa kolumna z trzema opcjami, prawa z dwiema -->
          <div class="diet-toggle-columns">
            <div class="col-left">
              <div class="diet-toggle-group">
                <span class="toggle-label">Strategia redukcji masy ciała</span>
                <label class="switch-diet">
                  <input type="checkbox" id="reduceToggle">
                  <span class="slider"></span>
                </label>
              </div>
              <div class="diet-toggle-group" id="stabilizationGroup">
                <span class="toggle-label">Strategia stabilizacji masy ciała</span>
                <label class="switch-diet">
                  <input type="checkbox" id="stabilizationToggle">
                  <span class="slider"></span>
                </label>
              </div>
              <div class="diet-toggle-group">
                <span class="toggle-label">Wzrost zakończony</span>
                <label class="switch-diet">
                  <input type="checkbox" id="growthEndedFlag">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
            <div class="col-right">
              <div class="diet-toggle-group">
                <span class="toggle-label">Suplementacja wit. D</span>
                <label class="switch-diet">
                  <input type="checkbox" id="vitDSuppFlag">
                  <span class="slider"></span>
                </label>
              </div>
              <div class="diet-toggle-group">
                <span class="toggle-label">Nawadnianie</span>
                <label class="switch-diet">
                  <input type="checkbox" id="hydrationFlag">
                  <span class="slider"></span>
                </label>
              </div>
              <!-- Nowa opcja: przykłady z czasem dojścia do prawidłowej wagi -->
              <div class="diet-toggle-group">
                <span class="toggle-label">Przykłady z czasem dojścia do prawidłowej wagi</span>
                <label class="switch-diet">
                  <input type="checkbox" id="journeyFlag">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
          </div>
        </div>
        <!-- Przycisk generujący zalecenia dietetyczne.  Użytkownik musi wybrać strategię i kliknąć, aby zobaczyć zalecenia i skopiować je do schowka. -->
        <button type="button" id="generateDietBtn" style="margin-top:0.6rem; display:block; margin-left:auto; margin-right:auto;">
          Generuj zalecenia dietetyczne
        </button>
        <!-- Miejsce na wygenerowane zalecenia dietetyczne.  Jest puste do czasu kliknięcia przycisku generuj. -->
        <div id="dietRecommendationsResult" style="margin-top:0.6rem;"></div>
      </div>
    </div>
    <!-- Karta Wskaźnika Cole'a – wypełniana dynamicznie w JS -->
    <div class="card" id="coleCard" style="display:none;">
      <!-- Wyśrodkowujemy nagłówek karty wskaźnika Cole'a poprzez style inline -->
      <h2 style="text-align:center;">Wskaźnik Cole'a</h2>
      <!-- Adnotacja Amerykańskiej Akademii Pediatrii; ukryta domyślnie.  
           Umieszczamy ją bezpośrednio pod nagłówkiem, dzięki czemu pojawi się
           pod etykietą karty, a przed właściwymi wynikami. Wygląd jest
           zdefiniowany w klasie .wfl-reminder w CSS; tutaj ograniczamy się
           do controlowania widoczności za pomocą display. -->
      <div id="wflReminderCole" class="wfl-reminder" style="display:none;"></div>
      <div id="coleInfo" class="result-box"></div>
      <p id="coleExplanation" class="cole-explanation"></p>
      <!-- Tabela norm wskaźnika Cole'a; wypełniana i wyświetlana przez JS -->
      <div id="coleNormTable" style="display:none;"></div>
    </div>
    <!-- ===== WHR: Wskaźnik talia-biodra ===== -->
    <div class="card" id="whrCard" style="display:none;">
      <h2 style="text-align:center;">Wskaźnik talia-biodra (WHR)</h2>
    
      <!-- Sugestia kontekstowa (pokazywana, gdy spełnione warunki) -->
      <div id="whrSuggest" class="plan-warning-card notice-orange" style="display:none;">
        Sugerujemy ocenę <strong>WHR</strong>, aby sprawdzić rozmieszczenie tkanki tłuszczowej.</div>
      <div class="flex" style="gap:0.75rem;margin-top:0.5rem;">
        <label style="flex:1 1 160px;">Obwód talii (cm):
          <input type="number" id="waistCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
        <label style="flex:1 1 160px;">Obwód bioder (cm):
          <input type="number" id="hipCm" min="30" max="200" step="0.1" oninput="debouncedUpdate()">
        </label>
      </div>
    
      <div id="whrInfo" class="result-box" style="display:none;"></div>
      <p id="whrInterpret" class="cole-explanation" style="display:none;"></p>
    
      <!-- Krótka tabela centyli talii/bioder (dzieci) -->
      <div id="whrChildTable" class="data-card" style="display:none;margin-top:.6rem;"></div>
    
      <!-- Źródła do modułu WHR (skrócone) -->
      <small class="muted">
        Dorośli: WHO 2008/2011 cut-offs (M&gt;0,90 / K&gt;0,85). Dzieci: polskie siatki talii/bioder OLAF/OLA.
      </small>
    </div>
    <!-- ===== /WHR ===== -->
    <!-- Zaawansowane obliczenia wzrostowe – wstawione między kartę Cole'a a kartę Droga do normy BMI -->
    <div id="advancedGrowthSection" style="margin-top:1rem; display:none;">
      <button type="button" id="toggleAdvancedGrowth" style="background-color:#00838d;color:white;padding:0.6rem 1.2rem;border:none;border-radius:4px;font-size:1rem;font-weight:600;cursor:pointer;display:block;margin:0.6rem auto;width:100%;">
        Zaawansowane obliczenia wzrostowe
      </button>
      <div id="advancedGrowthForm" class="card" style="display:none;margin-top:1rem;">
        <h2 style="text-align:center;">Zaawansowane obliczenia wzrostowe</h2>
        <label>Imię i&nbsp;Nazwisko (opcjonalnie):
          <input type="text" id="advName"></label>
        <label>Wiek kostny (lata):
          <input type="number" id="advBoneAge" min="0" max="18" step="0.1"></label>
        <label>Wzrost Mamy (cm):
          <input type="number" id="advMotherHeight" min="100" max="250"></label>
        <label>Wzrost Taty (cm):
          <input type="number" id="advFatherHeight" min="100" max="250"></label>
        <p style="font-weight:600;margin-top:0.8rem;">Wprowadź poprzednie pomiary</p>
        <div id="advMeasurements"></div>
        <button type="button" id="advAddMeasurementBtn" style="margin-top:0.8rem;display:block;margin-left:auto;margin-right:auto;">Dodaj kolejny pomiar</button>
        <div id="advResults" style="margin-top:1rem;"></div>
        <!-- Dodatkowe przyciski u dołu karty: generowanie siatki centylowej i czyszczenie danych tej karty. -->
        <div id="advButtons" class="adv-buttons">
          <button type="button" id="generateCentileChartAdv">Generuj siatkę centylową</button>
          <button type="button" id="advClearBtn">Wyczyść dane tej karty</button>
        </div>
      </div>
    </div>
    <!-- Karta „Droga do normy BMI” – zachowana oryginalna struktura -->
    <div class="card" id="toNormCard" style="display:none;">
      <h2>Droga do normy BMI</h2>
      <div id="toNormInfo"></div>
      <!-- Kontener na przycisk i wynik idealnej wagi. Pokazywany tylko, gdy BMI jest w normie. -->
      <div id="idealWeightWrap" style="display:none; margin-top:0.5rem; text-align:center;">
        <button type="button" id="idealWeightBtn">
          Chcesz zobaczyć jaka jest idealna waga przy twoim wzroście? Kliknij
        </button>
        <p id="idealWeightInfo" style="display:none; margin-top:0.5rem;"></p>
      </div>
      <!-- Mały napis pokazujący się tylko, gdy BMI nie jest w normie -->
      <small id="toNormNote">
        *Szacunkowa liczba km/metrów i czasu do przejścia/przejechania/przebiegnięcia, by BMI osiągnęło normę.
      </small>
    </div>
  </div>
  <div style="flex:1 1 300px;">
    <fieldset class="food-field">
      <legend>Przekąski</legend>
      <div id="snackList"></div>
      <button type="button" class="add-row" onclick="addSnackRow()">+ dodaj przekąskę</button>
    </fieldset>
    <fieldset class="food-field">
      <legend>Dania obiadowe</legend>
      <div id="mealList"></div>
      <button type="button" class="add-row" onclick="addMealRow()">+ dodaj danie</button>
    </fieldset>
    <!-- Karta sumy kalorii -->
    <div id="totalCard" class="card total-card" style="display:none;">
      <h2>Łączna kaloryczność
        <span class="subhead">(tego co wybrałeś powyżej)</span>
      </h2>
    
      <!-- Całkowite kcal – wypełnia JS -->
      <div id="totalKcal" style="font-size:1.2rem;text-align:center;margin-top:4px;"></div>
    
      <!-- Lista pozycji – wypełnia JS -->
      <div id="totalList"></div>
    </div>
  </div>
  <div class="card" id="timesCard">
    <h2 style="text-align:center;">Spalanie kalorii<span class="subhead">(czyli ile czasu zajmie mi<br>spalenie tego, co wybrałam/em)</span>
</h2>
    <div id="times"></div>
    <small>*Obliczenia oparte na wartościach MET – wyniki orientacyjne.</small>
  </div>
</div>
<!-- ======== Szacowane spożycie energii (toggle + karta) ======== -->
<div class="text-center intake-toggle-wrap">
  <button type="button" id="toggleIntakeCard" class="primary-btn" style="display:none;">
    Szacowane spożycie energii
  </button>
</div>

<section id="intakeCard" class="result-card" style="display:none;">
  <h2 class="intake-title">Szacowane spożycie energii</h2>

  <!-- PAL -->
  <div class="flex">
    <div style="flex:1 1 260px;min-width:240px;">
      <label for="intakePal">Poziom aktywności (PAL)</label>
      <select id="intakePal">
        <option value="1.2">1.2 – bardzo niska</option>
        <option value="1.4" selected>1.4 – niska</option>
        <option value="1.6">1.6 – umiarkowana</option>
        <option value="1.8">1.8 – wysoka</option>
        <option value="2.0">2.0 – bardzo wysoka</option>
      </select>
      <div id="intakePalDesc" class="muted" style="margin-top:.5rem;"></div>
    </div>
  </div>

  <!-- Wiersze pomiarów – styl jak w „Zaawansowanych obliczeniach wzrostowych” -->
  <div id="intakeMeasurements"></div>
  <div class="intake-actions">
    <button type="button" id="intakeAddRow" class="add-row">+ dodaj wiersz</button>
    <span class="muted">Uzupełnij co najmniej dwa wiersze, aby wyliczyć spożycie na podstawie zmiany masy.</span>
  </div>

  <!-- Wyniki (na desktop tabela, na mobile – wariant A: pionowe karty) -->
  <div id="intakeResults" class="result-box" style="margin-top:1rem;"></div>

  <!-- Legenda -->
  <div id="intakeLegend" class="muted" style="margin-top:.75rem;text-align:left;">
    <strong>Legenda:</strong>
    Δ masa – różnica masy (kg) między końcem i początkiem okresu;
    Oczekiwany przyrost – przyrost masy oszacowany na podstawie medianowych (50 c) przyrostów dla wieku oraz rzeczywistego wzrostu dziecka;
    Δ vs norma – różnica między rzeczywistym a oczekiwanym przyrostem;
    Nadmiar/deficyt (kcal/d) – dzienny nadmiar lub deficyt energii względem zapotrzebowania.
  </div>
</section>
<!-- ======== /Szacowane spożycie energii ======== -->
  <!-- 6. Plan odchudzania – formularz i wyniki -->
  <div id="planCard" class="plan-card" style="display:none;">
  <h2 style="text-align:center;">Plan odchudzania</h2>
  <!-- ostrzeżenie dla dzieci <10 lat z nadwagą/otyłością (wyświetlane w planie) -->
  <div id="planWarning" class="plan-warning-card" style="display:none;"></div>
  <!-- WYŚRODKOWANE POLA FORMULARZA -->
  <!--
    Zmieniono strukturę formularza planu odchudzania na dwie wyraźne sekcje.
    Każdy krok (wybór poziomu aktywności i wybór diety) posiada własny nagłówek,
    co ułatwia orientację osobom korzystającym z kalkulatora po raz pierwszy.
    Elementy opisowe (PAL oraz dieta) zostały przeniesione do dedykowanych kontenerów
    wewnątrz sekcji kroków. Dodatkowe style przypisane klasom `.plan-steps`,
    `.plan-step`, `.plan-desc` oraz `.calorie-info` są definiowane w pliku CSS.
  -->
  <div id="planInputs" class="plan-steps" style="margin-bottom:1rem;">
    <!-- Krok pierwszy: wybór poziomu aktywności -->
    <div class="plan-step">
      <h3>Krok 1: Wybierz poziom aktywności&nbsp;(PAL)</h3>
      <select id="palFactor" onchange="debouncedUpdate()">
        <option value="1.2">1.2 – bardzo niska (osoby unieruchomione)</option>
        <option value="1.4" selected>1.4 – niska (praca siedząca, brak ćwiczeń)</option>
        <option value="1.6">
          1.6 – umiarkowana (siedząca praca + 1‑3 treningi/tydz.)
        </option>
        <option value="1.8">1.8 – wysoka (fizyczna praca / sport 4‑5×/tydz.)</option>
        <option value="2.0">2.0 – bardzo wysoka (wyczynowi sportowcy)</option>
      </select>
      <!-- Opis wybranego poziomu aktywności PAL – wypełniany przez JS -->
      <div id="palDesc" class="plan-desc" style="display:none;"></div>
    </div>
    <!-- Krok drugi: wybór diety -->
    <div class="plan-step" id="dietChoiceWrap" style="display:none;">
      <h3>Krok 2: Wybierz rodzaj diety lub pozostaw rekomendowany</h3>
      <select id="dietLevel" onchange="updatePlanFromDiet()">
        <!-- opcje wypełnia JS -->
      </select>
      <!-- Opis wybranej diety – wypełniany przez JS -->
      <div id="dietDesc" class="plan-desc" style="display:none;"></div>
      <!-- Informacja o kaloryczności wybranej diety (zaokrąglona do 100 kcal) -->
      <div id="dietCalorieInfo" class="calorie-info" style="display:none;"></div>
    </div>
  </div>
  <div id="planResults"></div>
</div>
  <!-- karta dla dzieci <5 lat z nadwagą/otyłością – komunikat o konsultacji -->
  <div id="childConsultCard" class="plan-card" style="display:none;"></div>
  <!-- koniec Plan odchudzania -->
  <!--
    Nowy blok źródeł i zastrzeżeń (2025‑07‑24)
    Ten fieldset jest domyślnie ukryty i pojawia się dopiero po wykonaniu obliczeń.
    Umieszczamy go wewnątrz kontenera, aby zachować spójny układ z innymi kartami.
  -->
  <fieldset id="sourceFieldset" style="display:none;">
    <legend>O aplikacji: źródła, metodologia i zastrzeżenia</legend>
    <p>
      <strong>Przeznaczenie i sposób działania</strong><br />
      Aplikacja wykorzystuje algorytmy dopasowujące obliczenia do wieku, wzrostu i masy ciała, aby wyniki były możliwie najlepiej dostosowane do indywidualnych parametrów użytkownika. Ma charakter informacyjny i edukacyjny — nie zastępuje porady lekarskiej ani profesjonalnej diagnostyki. Wyniki nie stanowią rozpoznania, zaleceń terapeutycznych ani planu leczenia. W przypadku wątpliwości należy skonsultować się z odpowiednim specjalistą.
    </p>
    <p>
      <strong>Moduł Profesjonalny</strong><br />
      Moduł Profesjonalny jest przeznaczony wyłącznie dla lekarzy. Zawiera m.in. kalkulatory dawek leków wykorzystywanych w testach farmakologicznych.
    </p>
    <ul style="margin-left:1.25rem;margin-top:0;margin-bottom:0.5rem;">
      <li>Obliczenia mają charakter pomocniczy i wymagają niezależnej weryfikacji klinicznej.</li>
      <li>Przed zastosowaniem należy każdorazowo odnieść się do aktualnej Charakterystyki Produktu Leczniczego (ChPL), obowiązujących wytycznych, maksymalnych dawek, przeciwwskazań oraz stanu klinicznego pacjenta.</li>
      <li>Jednostki i zaokrąglenia dawek należy sprawdzać przed podaniem.</li>
      <li>Odpowiedzialność za decyzje kliniczne spoczywa na użytkowniku profesjonalnym.</li>
    </ul>
    <div style="text-align:center;margin-top:1rem;">
      <!-- Przyciski togglujący widoczność listy źródeł. Dodano aria-expanded dla dostępności -->
      <button type="button" id="toggleSources" aria-expanded="false">Źródła</button>
    </div>
    <ol id="sourceList" style="display:none;padding-left:1.25rem;margin-top:0.5rem;">
      <li>Chen LM, Chen YC, Hsiao HP, Chen BH, Chao MC. Role of thyrotropin‑releasing hormone test in re‑evaluation of congenital hypothyroidism. <em>Kaohsiung J Med Sci.</em> 2014 Aug;30(8):383‑9. doi: 10.1016/j.kjms.2014.04.005. Epub 2014 May 28. PMID: 25002375; PMCID: PMC11916237.</li>
      <li>Fröhlich E, Wahl R. The forgotten effects of thyrotropin‑releasing hormone: Metabolic functions and medical applications. <em>Front Neuroendocrinol.</em> 2019 Jan;52:29‑43. doi: 10.1016/j.yfrne.2018.06.006. Epub 2018 Jun 22. PMID: 29935915.</li>
      <li>PETER J. SNYDER, ROBERT D. UTIGER. Response to Thyrotropin Releasing Hormone (TRH) in Normal Man. <em>The Journal of Clinical Endocrinology &amp; Metabolism.</em> 1972 Feb;34(2):380–385. doi: 10.1210/jcem-34-2-380.</li>
      <li>Özsu E, Şıklar Z, Bilici E, Ceran A, Uyanık R, Çetin T, Aycan Z, Berberoğlu M. Intramuscular Short‑term ACTH Test for the Determination of Adrenal Function in Children: Safe, Effective and Reliable. <em>J Clin Res Pediatr Endocrinol.</em> 2020 Sep 2;12(3):241‑247. doi: 10.4274/jcrpe.galenos.2019.2019.0099. Epub 2019 Dec 17. PMID: 31842523; PMCID: PMC7499132.</li>
      <li>Gutierrez CE, De Beritto T. Relative Adrenal Insufficiency in the Preterm Infant. <em>Neoreviews.</em> 2022 May 1;23(5):e328‑e334. doi: 10.1542/neo.23-5-e328. PMID: 35490186.</li>
      <li>Buonocore F, McGlacken‑Byrne SM, Del Valle I, Achermann JC. Current Insights Into Adrenal Insufficiency in the Newborn and Young Infant. <em>Front Pediatr.</em> 2020 Dec 14;8:619041. doi: 10.3389/fped.2020.619041. PMID: 33381483; PMCID: PMC7767829.</li>
      <li>Pyrżak B, Walczak M, red. <em>Endokrynologia wieku rozwojowego.</em> Wyd. 2. Warszawa: PZWL Wydawnictwo Lekarskie; 2023.</li>
      <li>Dudek A, Niedziela M. Test z insuliną, z glukagonem oraz z argininą/insuliną na wydzielanie hormonu wzrostu – wykonanie testów i ich interpretacja. <em>Endokrynol. Ped.</em> 2009;9(Suppl 1):40–44.</li>
      <li>Ginalska‑Malinowska M, Malinowska A. Test z argininą, z klonidyną oraz z L‑Dopa na wydzielanie hormonu wzrostu (GH) – wykonanie testów i ich interpretacja. <em>Endokrynol. Ped.</em> 2009;9(Suppl 1):23–28.</li>
      <li>Kułaga Z, Litwin M, Tkaczyk M, Palczewska I, Zajączkowska M, Zwolińska D, Krynicki T, Wasilewska A, Moczulska A, Morawiec-Knysak A, Barwicka K, Grajda A, Gurzkowska B, Napieralska E, Pan H. Polish 2010 growth references for school‑aged children and adolescents. <em>Eur J Pediatr.</em> 2011 May;170(5):599‑609. doi: 10.1007/s00431-010-1329-x. Epub 2010 Oct 23. PMID: 20972688; PMCID: PMC3078309.</li>
      <li>WHO Multicentre Growth Reference Study Group. <em>WHO Child Growth Standards based on length/height, weight and age.</em> <em>Acta Paediatr Suppl.</em> 2006 Apr;450:76‑85. doi: 10.1111/j.1651-2227.2006.tb02378.x. PMID: 16817681.</li>
      <li>Kułaga Z, Grajda A, Gurzkowska B, Góźdź M, Wojtyło M, Swiąder A, Różdżyńska‑Świątkowska A, Litwin M. Polish 2012 growth references for preschool children. <em>Eur J Pediatr.</em> 2013 Jun;172(6):753‑61. doi: 10.1007/s00431-013-1954-2. Epub 2013 Feb 1. PMID: 23371392; PMCID: PMC3663205.</li>
      <li>Bloem M. The 2006 WHO child growth standards. <em>BMJ.</em> 2007 Apr 7;334(7596):705‑6. doi: 10.1136/bmj.39155.658843.BE. PMID: 17413142; PMCID: PMC1847861.</li>
      <li>Boguszewski MCS. Growth hormone deficiency and replacement in children. <em>Rev Endocr Metab Disord.</em> 2021 Mar;22(1):101‑108. doi: 10.1007/s11154-020-09604-2. Epub 2020 Oct 8. PMID: 33029711.</li>
    </ol>
    <!-- Skrypt do rozwijania listy źródeł. Funkcja toggluje widoczność listy po kliknięciu przycisku. -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggleButton = document.getElementById('toggleSources');
        const sourceList = document.getElementById('sourceList');
        if (toggleButton && sourceList) {
          toggleButton.addEventListener('click', function() {
            const isHidden = sourceList.style.display === 'none' || sourceList.style.display === '';
            sourceList.style.display = isHidden ? 'block' : 'none';
            // Aktualizuj atrybut aria-expanded dla lepszej dostępności
            toggleButton.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
          });
        }
      });
    </script>
  </fieldset>
</div>
<button id="downloadPDF" style="margin-top:16px;" hidden>Pobierz raport PDF</button>
  </div><!-- /main-content -->
  <!-- Decorative sidebar to visually balance the layout on very wide screens.  This empty
       aside uses the same background colour, border radius and shadow as the left
       navigation sidebar.  It remains hidden on smaller viewports and only appears
       once the viewport is sufficiently wide (see sidebar.css for breakpoints). -->
  <aside class="decor-sidebar"></aside>
</div><!-- /desktop-layout -->
<footer>
  <p><strong>Administrator serwisu:</strong>
    Vilda Clinic sp. z o.o. • 
    <a href="https://vildaclinic.pl" target="_blank" rel="noopener noreferrer">vildaclinic.pl</a>
  </p>
  <p><strong>Konsultacja merytoryczna:</strong>
    dr n. med. Maciej Flader
  </p>
</footer>
<!-- Uruchamiamy update() po pełnym załadowaniu strony -->
<!-- === UI ENHANCEMENT SCRIPT 2025‑06‑29 === -->
<!-- WHO patch merged automatically -->
<!-- === WHO 2006 BMI-for-age (0–60 mies.) tables inserted 2025‑06‑30 === -->
<!-- === BMI 50th percentile info patch – 2025‑06‑30 === -->
<!-- === ENHANCEMENTS: bigger/animated plan time, bold kg reduction, bigger 50th centyl info === -->
<!-- === PATCH 2025‑07‑01 – Small 50 and full time animation === -->

<!-- Load Down syndrome growth tables before app.js; these define DS datasets as global variables -->
<script src="ds_lms.js"></script>
<!-- Palczewska centile data (weight, height, BMI) for 0–18 years. Loaded before app.js so it attaches centileData to window. -->
<script src="centile_data.js"></script>
<script src="app.js" defer></script>

<!-- po app.js -->
<script src="gh_igf_therapy.js" defer></script>
<!-- Skrypt kalkulatora antybiotykoterapii – generuje kartę dawek antybiotyków.
     Ładowany po głównym pliku app.js i module GH/IGF, aby skorzystać z już zainicjowanych
     elementów DOM oraz funkcji (np. pobierania masy ciała). Plik antibiotic_therapy.js
     tworzy kartę kalkulującą dawki najpopularniejszych antybiotyków u dzieci na podstawie
     zaleceń z Rekomendacji 2016 i danych wprowadzonych przez użytkownika w sekcji
     „Dane użytkownika”. -->
<script src="antibiotic_therapy.js" defer></script>

    <!-- Skrypt synchronizujący podstawowe dane użytkownika (imię, wiek, płeć, masa i wzrost) pomiędzy
         stronami aplikacji. Plik userData.js zapisuje dane w localStorage i wczytuje je na
         wszystkich podstronach. -->
    <script src="userData.js" defer></script>



<!-- Skrypt generujący siatki centylowe wagi i wzrostu w formacie PDF.
     Kod ten korzysta z globalnych tablic LMS (zdefiniowanych w app.js) oraz bibliotek jsPDF i Canvas.
     Po kliknięciu przycisku „Generuj siatkę centylową” tworzy dwa wykresy (wzrostu i wagi),
     łączy je na jednej stronie A4 i wyświetla jako PDF w nowym oknie. -->
<script>
/* Definicje z‑score dla wybranych centyli (3., 10., 25., 50., 75., 90., 97.). */
const CENTILE_ZSCORES = { 3: -1.8808, 10: -1.281552, 25: -0.67448975, 50: 0, 75: 0.67448975, 90: 1.281552, 97: 1.8808 };

/* Interpoluje wartości LMS dla dowolnego miesiąca w danych OLAF. */
function getLMSFromDataset(dataset, m) {
  const keys = Object.keys(dataset).map(k => parseInt(k, 10)).sort((a, b) => a - b);
  if (dataset[m]) return dataset[m];
  let lo = keys[0], hi = keys[keys.length - 1];
  for (let i = 0; i < keys.length; i++) {
    if (keys[i] <= m) lo = keys[i];
    if (keys[i] >= m) { hi = keys[i]; break; }
  }
  const vLo = dataset[lo], vHi = dataset[hi];
  if (!vLo || !vHi) return vLo || vHi;
  if (lo === hi) return vLo;
  const t = (m - lo) / (hi - lo);
  const L = vLo[0] + t * (vHi[0] - vLo[0]);
  const M = vLo[1] + t * (vHi[1] - vLo[1]);
  const S = vLo[2] + t * (vHi[2] - vLo[2]);
  return [L, M, S];
}
/* Oblicza wartość z parametrów LMS i z‑score. */
function valueFromLMS(L, M, S, z) {
  if (L !== 0) {
    return M * Math.pow(1 + L * S * z, 1 / L);
  }
  return M * Math.exp(S * z);
}
/* Pobiera LMS dla wagi wg płci. */
function getLMSWeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_WEIGHT_BOYS, m) : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}
/* Pobiera LMS dla wzrostu wg płci. */
function getLMSHeight(sex, m) {
  return sex === 'M' ? getLMSFromDataset(LMS_HEIGHT_BOYS, m) : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}

/* Hybrydowa wersja LMS – dla wieku <36 mies. (0–3 lata) korzysta z danych WHO,
   natomiast dla wieku ≥36 mies. korzysta z badań OLAF (domyślne). */
function getLMSWeightHybrid(sex, m) {
  // m – miesiące (całkowite lub ułamkowe). Dla wartości ułamkowych funkcja
  // getLMSFromDataset wykona interpolację między sąsiednimi miesiącami.
  // Dane WHO obejmują okres od urodzenia do 36 mies. włącznie. Aby uniknąć
  // skoków przy przejściu z WHO do OLAF, korzystamy z WHO tylko dla m < 36 (0–35);
  // dla m ≥ 36 przechodzimy na OLAF.  Takie rozdzielenie zapobiega
  // „zagięciu” krzywych w okolicach trzeciego roku życia.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_WEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_WEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_WEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_WEIGHT_GIRLS, m);
}

function getLMSHeightHybrid(sex, m) {
  // Analogicznie jak w przypadku masy: korzystamy z WHO wyłącznie dla m < 36
  // (okres 0–35 miesięcy), natomiast dla m ≥ 36 przechodzimy na OLAF.  Dzięki temu
  // unikamy gwałtownej zmiany źródła danych dla 36. miesiąca i starszych.
  if (m < 36) {
    return sex === 'M'
      ? getLMSFromDataset(LMS_INFANT_HEIGHT_BOYS, m)
      : getLMSFromDataset(LMS_INFANT_HEIGHT_GIRLS, m);
  }
  return sex === 'M'
    ? getLMSFromDataset(LMS_HEIGHT_BOYS, m)
    : getLMSFromDataset(LMS_HEIGHT_GIRLS, m);
}
/* Rysuje pojedynczy wykres siatki centylowej. */
function drawCentileGrid(ctx, cfg) {
  const { x, y, w, h, curves, minY, maxY, userVal, userAgeMonths, title, units, percentiles, highlightBandIdx, cutoffVal, minX, maxX } = cfg;
  // Determine the horizontal range (in months) for the chart.  If minX/maxX are not
  // provided, default to the historical 3–18 lata range (36–216 mies.).  The variables
  // minXVal and maxXVal ensure we always have defined numeric values for computations.
  const minXVal = (typeof minX === 'number') ? minX : 36;
  const maxXVal = (typeof maxX === 'number') ? maxX : 216;
  const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
  const px = x + leftMargin, py = y + topMargin;
  const pw = w - leftMargin - rightMargin, ph = h - topMargin - bottomMargin;
  // Scale factors.  X‑axis is scaled according to the selected range (maxXVal – minXVal).
  const xScale = pw / (maxXVal - minXVal);
  const yScale = ph / (maxY - minY);
  ctx.save();
  ctx.lineCap = 'butt';
  // Pionowe linie siatki.  Zakres lat (startYear..endYear) zależy od zdefiniowanego zakresu mies. (minXVal..maxXVal).
  const startYear = Math.ceil(minXVal / 12);
  const endYear   = Math.floor(maxXVal / 12);
  for (let age = startYear; age <= endYear; age++) {
    const m = age * 12;
    const cx = px + (m - minXVal) * xScale;
    ctx.beginPath();
    ctx.strokeStyle = '#bbbbbb';
    ctx.lineWidth = 2.5;
    ctx.moveTo(cx, py);
    ctx.lineTo(cx, py + ph);
    ctx.stroke();
    // Połówkowe linie (co 6 mies.)
    if (age < endYear) {
      const halfM = m + 6;
      if (halfM <= maxXVal) {
        const halfX = px + (halfM - minXVal) * xScale;
        ctx.beginPath();
        ctx.strokeStyle = '#dddddd';
        ctx.lineWidth = 1.75;
        ctx.moveTo(halfX, py);
        ctx.lineTo(halfX, py + ph);
        ctx.stroke();
      }
    }
    ctx.font = '35px sans-serif';
    ctx.fillStyle = '#333333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(String(age), cx, py + ph + 8);
  }
  // Poziome linie siatki
  for (let val = minY; val <= maxY; val++) {
    const cy = py + ph - (val - minY) * yScale;
    ctx.beginPath();
    if (val % 5 === 0) {
      ctx.strokeStyle = '#bbbbbb';
      ctx.lineWidth = 2.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#333333';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(val), px - 6, cy);
    } else {
      ctx.strokeStyle = '#eeeeee';
      ctx.lineWidth = 1.5;
      ctx.moveTo(px, cy);
      ctx.lineTo(px + pw, cy);
      ctx.stroke();
    }
  }
  // Osie
  ctx.beginPath();
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 2;
  ctx.moveTo(px, py);
  ctx.lineTo(px, py + ph);
  ctx.moveTo(px, py + ph);
  ctx.lineTo(px + pw, py + ph);
  ctx.stroke();
  
  // Podświetlenie kanału centylowego i dwie poziome linie na poziomach 18 r.ż.
  if (typeof highlightBandIdx === 'number' && highlightBandIdx >= 0 && highlightBandIdx < percentiles.length - 1) {
    const pA = percentiles[highlightBandIdx];
    const pB = percentiles[highlightBandIdx + 1];
    const valsA = curves[pA];
    const valsB = curves[pB];
    const n = valsA.length;

    // Wypełnienie obszaru kanału (delikatny turkus)
    (function shadeBand() {
      const path = new Path2D();
      for (let i = 0; i < n; i++) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yTop = py + ph - (Math.max(valsA[i], valsB[i]) - minY) * yScale;
        if (i === 0) path.moveTo(cx, yTop); else path.lineTo(cx, yTop);
      }
      for (let i = n - 1; i >= 0; i--) {
        const mVal = minXVal + i;
        const cx = px + (mVal - minXVal) * xScale;
        const yBot = py + ph - (Math.min(valsA[i], valsB[i]) - minY) * yScale;
        path.lineTo(cx, yBot);
      }
      path.closePath();
      ctx.save();
      ctx.fillStyle = 'rgba(0,131,141,0.10)';
      ctx.fill(path);
      ctx.restore();
    })();

    // Poziome linie na wartościach 18 r.ż. (216 mies.) – przez całą szerokość siatki.
    // Wyznacz indeks w tablicach wartości, przesuwając o minXVal.  Jeżeli zakres
    // osi X nie obejmuje 18 lat (216 mies.), pomijamy te linie.
    const idx18 = 216 - minXVal;
    if (maxXVal >= 216 && idx18 >= 0 && idx18 < n) {
      const v1 = valsA[idx18];
      const v2 = valsB[idx18];
      const valLow18 = Math.min(v1, v2);
      const valHigh18 = Math.max(v1, v2);
      const yLow18 = py + ph - (valLow18 - minY) * yScale;
      const yHigh18 = py + ph - (valHigh18 - minY) * yScale;

      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = 'rgba(0,131,141,0.85)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(px, yLow18); ctx.lineTo(px + pw, yLow18); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px, yHigh18); ctx.lineTo(px + pw, yHigh18); ctx.stroke();
      ctx.setLineDash([]);

      // Etykiety wartości wewnątrz siatki, tuż przy lewym brzegu (ale nie na zewnątrz).
      // Numeryczne wartości są zaokrąglane do 0,5 jednostki (np. 174,5 cm) i
      // wyświetlane powyżej przerywanych linii, aby linie nie przechodziły przez tekst.
      function fmtToHalf(n) {
        // Zaokrąglij do połowy jednostki i zwróć z przecinkiem jako separator dziesiętny
        const rounded = Math.round(n * 2) / 2;
        return rounded.toFixed(1).replace('.', ',');
      }
      const cLow = Math.min(pA, pB);
      const cHigh = Math.max(pA, pB);
      const labelLow = `${fmtToHalf(valLow18)} ${units} (${cLow} c)`;
      const labelHigh = `${fmtToHalf(valHigh18)} ${units} (${cHigh} c)`;

      // Wyznacz pionowe pozycje dla etykiet. Odsuń je lekko w górę względem linii,
      // aby uniknąć kolizji z kreskowanymi liniami. Jeżeli linie są blisko siebie,
      // dodatkowo zwiększ odstęp.
      let y1 = yHigh18 - 18;
      let y2 = yLow18 - 18;
      // Jeśli odległość między dwoma etykietami jest zbyt mała, rozsuń je
      if (Math.abs(y2 - y1) < 32) {
        const shift = (32 - Math.abs(y2 - y1)) / 2 + 2;
        y1 -= shift;
        y2 += shift;
      }
      ctx.font = '33px sans-serif';
      ctx.fillStyle = '#004f54';
      ctx.textAlign = 'left';
      // Ustaw baseline na 'middle' tak, aby podany y oznaczał środek tekstu
      ctx.textBaseline = 'middle';
      ctx.fillText(labelHigh, px + 10, y1);
      ctx.fillText(labelLow,  px + 10, y2);
      ctx.restore();
    }
  }

  // Linie centylowe
  const colors = { 3: '#d32f2f', 10: '#f57c00', 25: '#fbc02d', 50: '#388e3c', 75: '#1976d2', 90: '#7b1fa2', 97: '#c2185b' };
  const labelPos = [];
  for (const p of percentiles) {
    const vals = curves[p];
    ctx.beginPath();
    ctx.strokeStyle = colors[p] || '#000000';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    const pts = [];
    for (let i = 0; i < vals.length; i++) {
      const mVal = minXVal + i;
      const pxVal = px + (mVal - minXVal) * xScale;
      const pyVal = py + ph - (vals[i] - minY) * yScale;
      pts.push({ x: pxVal, y: pyVal });
    }
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 0; i < pts.length - 1; i++) {
      const cpX = pts[i].x, cpY = pts[i].y;
      const midX = (pts[i].x + pts[i + 1].x) / 2;
      const midY = (pts[i].y + pts[i + 1].y) / 2;
      ctx.quadraticCurveTo(cpX, cpY, midX, midY);
    }
    ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
    ctx.stroke();
    const lastPt = pts[pts.length - 1];
    labelPos.push({ centile: p, x: lastPt.x, y: lastPt.y, color: colors[p] });
  }
  // Unikanie nakładania etykiet centyli
  labelPos.sort((a, b) => a.y - b.y);
  const minSpacing = 32;
  for (let i = 1; i < labelPos.length; i++) {
    if (labelPos[i].y - labelPos[i - 1].y < minSpacing) {
      labelPos[i].y = labelPos[i - 1].y + minSpacing;
    }
  }
  const bottom = py + ph;
  const overflow = labelPos[labelPos.length - 1].y - bottom;
  if (overflow > -16) {
    const shift = overflow + 16;
    for (const item of labelPos) {
      item.y -= shift;
    }
  }
  ctx.font = '26px sans-serif';
  ctx.textBaseline = 'middle';
  for (const item of labelPos) {
    ctx.fillStyle = item.color;
    ctx.textAlign = 'left';
    ctx.fillText(String(item.centile), px + pw + 10, item.y);
  }
  // Tytuły osi
  ctx.save();
  ctx.translate(x + 40, y + topMargin + ph / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.fillText(title, 0, 0);
  ctx.restore();
  ctx.font = '32px sans-serif';
  ctx.fillStyle = '#333333';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('Wiek (lata)', px + pw / 2, py + ph + 50);
  // Ostrzeżenie w przypadku rozszerzenia zakresu wagi
  // Jeśli zdefiniowano cutoffVal (np. górną granicę oficjalnej siatki), narysuj grubą linię
  // oraz ostrzeżenie, aby zaznaczyć koniec referencyjnego zakresu.  Umieszczamy
  // go przed rysowaniem punktu użytkownika, aby punkt pozostał na wierzchu.
  if (typeof cutoffVal === 'number' && cutoffVal >= minY && cutoffVal < maxY) {
    const cyWarn = py + ph - (cutoffVal - minY) * yScale;
    ctx.save();
    ctx.strokeStyle = '#c62828';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(px, cyWarn);
    ctx.lineTo(px + pw, cyWarn);
    ctx.stroke();
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('Uwaga! koniec oficjalnej siatki centylowej', px + pw / 2, cyWarn - 8);
    ctx.restore();
  }

  // Punkt użytkownika
  if (typeof userVal === 'number' && !isNaN(userVal) && typeof userAgeMonths === 'number' && userAgeMonths >= minXVal && userAgeMonths <= maxXVal) {
    const pxU = px + (userAgeMonths - minXVal) * xScale;
    const pyU = py + ph - (userVal - minY) * yScale;
    ctx.beginPath();
    ctx.fillStyle = '#000000';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.arc(pxU, pyU, 10, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.font = '33px sans-serif';
    ctx.fillStyle = '#000000';
    ctx.textAlign = pxU > px + pw / 2 ? 'right' : 'left';
    ctx.textBaseline = 'bottom';
    const lbl = userVal.toFixed(1) + ' ' + units;
    const labelX = pxU > px + pw / 2 ? pxU - 12 : pxU + 12;
    ctx.fillText(lbl, labelX, pyU - 12);
  }
  ctx.restore();
}
/* Główna funkcja generująca PDF z siatkami centylowymi. */

async function generateCentileChart() {
  // Funkcja pomocnicza: wyznacza, między którymi centylami (indeks w tablicy percentiles)
  // znajduje się wartość użytkownika przy zadanym wieku (mIdx = miesiące - 36).
  function findHighlightBand(userVal, curves, percentiles, mIdx) {
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i = 0; i < vals.length - 1; i++) {
      const lo = Math.min(vals[i], vals[i + 1]);
      const hi = Math.max(vals[i], vals[i + 1]);
      // włączamy górną granicę, aby nie zostawiać "szczeliny"
      if (userVal >= lo && userVal <= hi) return i;
    }
    // Jeżeli wynik znajduje się poniżej najniższego centyla (3 c.) lub powyżej najwyższego (97 c.),
    // nie wyróżniaj żadnego kanału centylowego. Zwrócenie -1 powoduje brak podświetlenia
    // w przypadku wartości < 3. centyla lub > 97. centyla.
    if (userVal < Math.min(vals[0], vals[1])) return -1;
    if (userVal > Math.max(vals[vals.length - 2], vals[vals.length - 1])) return -1;
    return -1;
  }

  const ageEl = document.getElementById('age');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  if (!ageEl || !weightEl || !heightEl || !sexEl) {
    alert('Wprowadź wiek, wagę, wzrost i płeć, aby wygenerować siatkę centylową.');
    return;
  }
  // Odczytaj wiek zarówno w latach, jak i w miesiącach. Pole wieku w latach (#age) jest obowiązkowe,
  // natomiast pole miesięcy (#ageMonths) jest opcjonalne. Jeśli pole miesięcy jest puste lub
  // nie istnieje (w przypadku, gdy skrypt jest używany w kontekście bez miesiąców), przyjmujemy 0.
  const yearsVal  = parseFloat(ageEl.value) || 0;
  const ageMonthsEl = document.getElementById('ageMonths');
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  // Połącz lata i miesiące w bardziej precyzyjny wiek (np. 11 lat 6 miesięcy = 11.5).
  const ageYears = yearsVal + (monthsVal / 12);
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = sexEl.value === 'M' ? 'M' : 'F';
  // Jeżeli którakolwiek z wartości jest nieprawidłowa (NaN), przerwij generowanie wykresu.
  if (isNaN(ageYears) || isNaN(weight) || isNaN(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  // Zamień dokładny wiek (z uwzględnieniem miesięcy) na liczbę pełnych miesięcy do dalszych obliczeń.
  const ageMonths = Math.round(ageYears * 12);
  // Pozwalamy na zakres 0–18 lat (0–216 mies.). Sprawdź, czy wiek mieści się w tym zakresie.
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  // Wyznacz zakres osi X w zależności od wieku użytkownika.  Dla wieku <36 mies. używamy
  // danych Palczewska & Niedźwiecka (0–36 mies.), a dla wieku ≥36 mies. danych OLAF (36–216 mies.).
  let minXVal, maxXVal;
  // Określ, czy należy użyć danych Palczewska (wiek poniżej 3 lat) czy OLAF (wiek ≥ 3 lata).
  const usePalczewska = ageMonths < 36;
  if (usePalczewska) {
    minXVal = 0;
    maxXVal = 36;
  } else {
    minXVal = 36;
    maxXVal = 216;
  }
  const months = [];
  for (let m = minXVal; m <= maxXVal; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n)).sort((a, b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  // Wypełnij krzywe centylowe dla wybranego zakresu miesięcy. Dla wieku <3 lat (0–35 miesięcy)
  // korzystamy z siatek Palczewskiej i Niedźwieckiej (polska populacja).  Dla wieku ≥ 3 lat
  // (36–18 lat) używamy wyłącznie danych OLAF/WHO. Dzięki temu unikamy łączenia dwóch
  // różnych źródeł przy wartościach 36 miesięcy i zapewniamy spójność wykresu.
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        // pobierz wartości z siatki polskiej (Palczewska & Niedźwiecka)
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        // użyj funkcji LMS dla wieku ≥ 3 lat (OLAF/WHO)
        const [Lw, Mw, Sw] = getLMSWeightHybrid(sex, m);
        const [Lh, Mh, Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }

  /*
   * Krótkie wygładzanie krzywych centylowych (optional smoothing)
   * Aby poprawić wizualną jakość wykresów, zastosujmy prosty filtr
   * średniej kroczącej do każdej tablicy wartości wagi i wzrostu.  Używamy
   * okna o szerokości 3 i wykonujemy sześć przebiegów.  Większa liczba
   * przebiegów mocniej wygładza krzywe, redukując ostre załamania
   * wynikające z dyskretnych danych, jednocześnie minimalnie zmieniając
   * wartości referencyjne.
   */
  function smoothCurve(arr, passes = 1) {
    let out = arr.slice();
    const n = arr.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      // dla brzegów nie możemy użyć pełnego okna; pozostawiamy oryginalne wartości
      // można także przyjąć średnią z sąsiada, ale zachowujemy źródłową wartość
      out = tmp;
    }
    return out;
  }
  // Zastosuj wygładzanie do wszystkich krzywych przed obliczeniem zakresów
  for (const p of percentiles) {
    // Zwiększamy liczbę przebiegów do 6, aby osiągnąć jeszcze mocniejsze wygładzenie krzywych.
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  let minW = Infinity, maxW = -Infinity, minH = Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  minW = Math.floor(minW / 5) * 5; maxW = Math.ceil(maxW / 5) * 5;
  minH = Math.floor(minH / 5) * 5; maxH = Math.ceil(maxH / 5) * 5;

  // --- DYNAMICZNE SKALOWANIE osi Y (wzrost + waga, góra i dół) ---
  // 0) Pomocnicze zaokrąglenia do 5, żeby linie siatki były czytelne:
  const roundDown5 = v => Math.floor(v / 5) * 5;
  const roundUp5 = v => Math.ceil(v / 5) * 5;

  // 1) Zbierz skrajne pomiary z bieżących pól i z karty zaawansowanej
  let minMeasuredW = weight, maxMeasuredW = weight;
  let minMeasuredH = height, maxMeasuredH = height;

  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        if (typeof m.weight === 'number') {
          if (m.weight < minMeasuredW) minMeasuredW = m.weight;
          if (m.weight > maxMeasuredW) maxMeasuredW = m.weight;
        }
        if (typeof m.height === 'number') {
          if (m.height < minMeasuredH) minMeasuredH = m.height;
          if (m.height > maxMeasuredH) maxMeasuredH = m.height;
        }
      });
    }
    if (typeof adv.currentWeight === 'number') {
      if (adv.currentWeight < minMeasuredW) minMeasuredW = adv.currentWeight;
      if (adv.currentWeight > maxMeasuredW) maxMeasuredW = adv.currentWeight;
    }
    if (typeof adv.currentHeight === 'number') {
      if (adv.currentHeight < minMeasuredH) minMeasuredH = adv.currentHeight;
      if (adv.currentHeight > maxMeasuredH) maxMeasuredH = adv.currentHeight;
    }
  }

  // 2) Wyznacz dynamiczne granice (zaokrąglone do „piątek”)
  let dynamicMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynamicMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;

  let dynamicMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynamicMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;

  // 3) Zakresy przed/po zmianach (potrzebne do proporcjonowania wysokości wykresów)
  const origWRange = maxW - minW;
  const origHRange = maxH - minH;
  const newWRange = dynamicMaxW - dynamicMinW;
  const newHRange = dynamicMaxH - dynamicMinH;

  // 4) Flagi ułatwiające decyzje dalej
  const scaledW = (dynamicMinW !== minW) || (dynamicMaxW !== maxW);
  const scaledH = (dynamicMinH !== minH) || (dynamicMaxH !== maxH);
  const useDynamicScaling = scaledW || scaledH;
  
  // Indeks miesiąca użytkownika (0..180) i kanały do podświetlenia dla wzrostu i wagi
  // Indeks miesiąca użytkownika wewnątrz tablicy months.  Odejmiemy początek zakresu osi X.
  const mIdx = ageMonths - minXVal;
  const hBandIdx = findHighlightBand(height, heightCurves, percentiles, mIdx);
  const wBandIdx = findHighlightBand(weight, weightCurves, percentiles, mIdx);
const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw;
  canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, pw, ph);
  const header = sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki';
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(header, pw / 2, 60);
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  /*
   * Użytkownik poprosił o obniżenie napisu „Imię i nazwisko” względem nagłówka o 1 rem.
   * Ponieważ płótno jest tworzone w wysokiej rozdzielczości (~300 dpi), 1 rem (16 px w CSS)
   * odpowiada ok. 50 pikselom na płótnie. Dlatego dodajemy 50 pikseli do pozycji Y,
   * aby uzyskać bardziej wyraźny odstęp między nagłówkiem a etykietą imienia i nazwiska.
   */
  // Obniżenie etykiety „Imię i nazwisko” o 1,75 rem względem nagłówka (1,25 rem z poprzedniej wersji + 0,5 rem dodatkowo).
  // --- DYNAMICZNY napis "Imię i nazwisko" (z karty Zaawansowane) ---
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');

  const nameLabel = nameFromState
    ? `Imię i nazwisko: ${nameFromState}`
    : 'Imię i nazwisko: _________________________________';

  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // --- koniec wstawki ---
  const chartW = pw - 200;
  // Oblicz dostępną przestrzeń na siatki dopiero w momencie rysowania, gdy znamy wysokość strony.
  const availH = ph - 300;
  // Margines pomiędzy dwoma wykresami (jak w oryginalnym projekcie).
  const interChartMargin = 100;
  // Przestrzeń dostępna wyłącznie na dwie siatki (wysokość płótna minus margines).
  const chartsAreaH = availH - interChartMargin;
  // Dynamicznie przydziel wysokość dla wzrostu i wagi w zależności od tego,
  // czy zmienił się zakres którejkolwiek osi Y (waga lub wzrost).
  let heightGridH, weightGridH;
  if (useDynamicScaling) {
    // Proporcja przestrzeni ~ proporcji aktualnych zakresów Y
    let tmpHeight = chartsAreaH * (newHRange / (newHRange + newWRange || 1));
    let tmpWeight = chartsAreaH - tmpHeight;
    // Zadbaj o minimalną wysokość górnego wykresu (wzrostu), aby nie był za niski
    const minHeightChartH = chartsAreaH * 0.30;
    if (tmpHeight < minHeightChartH) {
      tmpHeight = minHeightChartH;
      tmpWeight = chartsAreaH - tmpHeight;
    }
    heightGridH = tmpHeight;
    weightGridH = tmpWeight;
  } else {
    // Bez zmian zakresów – po połowie miejsca
    heightGridH = chartsAreaH / 2;
    weightGridH = chartsAreaH / 2;
  }
  // Pozycje Y dla obu wykresów. Górny wykres zaczyna się w ustalonej pozycji, a dolny jest przesunięty
  // o wysokość pierwszego wykresu plus margines minus małe przesunięcie (0,5 rem) kompensujące podpisy osi.
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Pierwszy wykres – wzrost
  drawCentileGrid(ctx, {
    x: 100,
    y: yHeightGrid,
    w: chartW,
    h: heightGridH,
    curves: heightCurves,
    minY: dynamicMinH,
    maxY: dynamicMaxH,
    userVal: height,
    userAgeMonths: ageMonths,
    title: 'Wzrost (cm)',
    units: 'cm',
    percentiles,
    highlightBandIdx: hBandIdx,
    // Przekazujemy początek i koniec osi X, aby rysunek obsługiwał wiek 0–3 lub 3–18 lat.
    minX: minXVal,
    maxX: maxXVal,
    cutoffVal: (dynamicMaxH > maxH) ? maxH : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wzrostu ---
  // Jeżeli użytkownik wprowadził dodatkowe dane (historia pomiarów,
  // potencjał wzrostowy, wiek kostny), wyświetlamy je na siatce
  // centylowej wzrostu. Elementy te rysujemy po narysowaniu
  // standardowych krzywych, aby były widoczne na wierzchu.
  if (window.advancedGrowthData) {
    const adv = window.advancedGrowthData;
    // Obliczenia współczynników skalowania odpowiadające tym w
    // drawCentileGrid(). Marginesy muszą być zgodne z tymi użytymi
    // w funkcji rysującej, aby punkty były prawidłowo rozmieszczone.
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yHeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = heightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYh = dynamicMinH;
      const maxYh = dynamicMaxH;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYh - minYh);
      ctx.save();
      // Rysowanie linii łączących historyczne pomiary wzrostu
      if (adv.measurements && adv.measurements.length) {
        // Do listy punktów dodajemy również aktualny pomiar wzrostu, tak aby
        // linia łączyła historię z bieżącym wzrostem dziecka.
        let pts = adv.measurements.filter(m => m.height !== null).slice();
        if (typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
          pts.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Linie łączące kolejne pomiary
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.height - minYh) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Punkty pomiarowe
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.height >= minYh && m.height <= maxYh) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.height - minYh) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      // Rysowanie markeru docelowego wzrostu (Target Height).
      // Do etykiety dodajemy przewidywany ostateczny wzrost w centymetrach, np. „TH 166.0 cm”.
      if (typeof adv.targetHeight === 'number' && !isNaN(adv.targetHeight)) {
        const mAgeTH = 216; // 18 lat w miesiącach
        if (mAgeTH >= minX && mAgeTH <= maxX) {
          const cx = pxBase + (mAgeTH - minX) * xScale;
          const cy = pyBase + phBase - (adv.targetHeight - minYh) * yScale;
          ctx.beginPath();
          ctx.fillStyle = '#c62828';
          ctx.moveTo(cx - 8, cy);
          ctx.lineTo(cx, cy - 8);
          ctx.lineTo(cx + 8, cy);
          ctx.lineTo(cx, cy + 8);
          ctx.closePath();
          ctx.fill();
          // Etykieta „TH” wraz z wartością docelowego wzrostu w cm.
          const thLabel = adv.targetHeight.toFixed(1) + ' cm';
          ctx.font = 'bold 28px sans-serif';
          ctx.fillStyle = '#c62828';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText('TH ' + thLabel, cx + 14, cy);
        }
      }
      // Rysowanie markera wieku kostnego (jeśli podano)
      if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths)) {
        const boneXAge = adv.boneAgeMonths;
        // Zaznacz punkt na osi czasu odpowiadający wiekowi kostnemu
        if (boneXAge >= minX && boneXAge <= maxX && typeof adv.currentHeight === 'number') {
          const cxBone = pxBase + (boneXAge - minX) * xScale;
          const cyBone = pyBase + phBase - (adv.currentHeight - minYh) * yScale;
          const cxCurrent = pxBase + (adv.currentAgeMonths - minX) * xScale;
          // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
          ctx.beginPath();
          ctx.strokeStyle = '#00838d';
          ctx.lineWidth = 2;
          ctx.moveTo(cxBone, cyBone);
          ctx.lineTo(cxCurrent, cyBone);
          ctx.stroke();
          // Zaznacz kropkę z pierścieniem
          ctx.beginPath();
          ctx.fillStyle = '#00838d';
          ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
          ctx.strokeStyle = '#00838d';
          ctx.stroke();
        }
      }
      // Rysowanie WSZYSTKICH historycznych wieków kostnych (jak aktualny: kropka z pierścieniem)
      try {
        if (adv && Array.isArray(adv.measurements)) {
          adv.measurements.forEach(m => {
            if (!m) return;
            // Toleruj wartość wieku kostnego przechowywaną jako napis lub liczba
            const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string')
              ? parseFloat(m.boneAgeYears) : NaN;
            const hVal = (typeof m.height === 'number' || typeof m.height === 'string')
              ? parseFloat(m.height) : NaN;
            const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string')
              ? parseFloat(m.ageMonths) : NaN;
            if (!isNaN(bVal) && !isNaN(hVal) && !isNaN(ageM)) {
              const mBoneMonths = Math.round(bVal * 12);
              // Sprawdź czy mieści się w zakresie osi
              if (mBoneMonths >= minX && mBoneMonths <= maxX && hVal >= minYh && hVal <= maxYh) {
                const cxB = pxBase + (mBoneMonths - minX) * xScale;
                const cyB = pyBase + phBase - (hVal - minYh) * yScale;
                const cxCurrentM = pxBase + (ageM - minX) * xScale;
                // Pozioma linia łącząca marker wieku kostnego z krzywą wzrastania
                ctx.beginPath();
                ctx.strokeStyle = '#00838d';
                ctx.lineWidth = 2;
                ctx.moveTo(cxB, cyB);
                ctx.lineTo(cxCurrentM, cyB);
                ctx.stroke();
                // Zaznacz kropkę z pierścieniem
                ctx.beginPath();
                ctx.fillStyle = '#00838d';
                ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00838d';
                ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
                ctx.stroke();
              }
            }
          });
        }
      } catch(_){}
      ctx.restore();
    })();
  }
  /*
   * Aby uniknąć ucinania dolnych podpisów osi X na wydruku, podnosimy siatkę centylową wagi
   * o 1 rem (ok. 50 pikseli) względem pierwotnej pozycji. Odejmujemy więc 50 pikseli
   * od wartości Y drugiego wykresu.
   */
  // Drugi wykres – waga. Używamy dynamicznie dobranych wymiarów i osi, jeśli zakres wagi został rozszerzony.
  drawCentileGrid(ctx, {
    x: 100,
    y: yWeightGrid,
    w: chartW,
    h: weightGridH,
    curves: weightCurves,
    // Użyj dynamicMaxW jako górnej granicy osi wagi, jeśli rozszerzono zakres.
    minY: dynamicMinW,
    maxY: dynamicMaxW,
    userVal: weight,
    userAgeMonths: ageMonths,
    title: 'Waga (kg)',
    units: 'kg',
    percentiles,
    highlightBandIdx: wBandIdx
    ,
    // Zakres osi X oraz ewentualne ostrzeżenie o końcu oficjalnej siatki wagi.
    minX: minXVal,
    maxX: maxXVal,
    // Przekazujemy oryginalne maksimum jako cutoffVal w przypadku przekroczenia, aby narysować linię ostrzegawczą.
    cutoffVal: (dynamicMaxW > maxW) ? maxW : undefined
  });

  // --- Naniesienie danych zaawansowanych na wykres wagi ---
  // Po narysowaniu wykresu wagi możemy nanieść historię pomiarów wagi
  // wprowadzone przez użytkownika. Użytkownicy mogą wpisywać
  // dowolną liczbę pomiarów; rysujemy linie łączące kolejne punkty i
  // same punkty. Pozostałe elementy (potencjał wzrostowy, wiek kostny)
  // nie dotyczą wagi i dlatego nie są tu rysowane.
  if (window.advancedGrowthData) {
    const advW = window.advancedGrowthData;
    (function() {
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yWeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = weightGridH - topMargin - bottomMargin;
      const minX = minXVal;
      const maxX = maxXVal;
      const minYw = dynamicMinW;
      const maxYwLocal = dynamicMaxW;
      const xScale = pwBase / (maxX - minX);
      const yScale = phBase / (maxYwLocal - minYw);
      ctx.save();
      if (advW.measurements && advW.measurements.length) {
        // Dodaj aktualny pomiar wagi, aby linia łączyła historię z bieżącą wagą dziecka.
        let pts = advW.measurements.filter(m => m.weight !== null).slice();
        if (typeof advW.currentWeight === 'number' && typeof advW.currentAgeMonths === 'number') {
          pts.push({ ageMonths: advW.currentAgeMonths, weight: advW.currentWeight });
        }
        pts.sort((a, b) => a.ageMonths - b.ageMonths);
        // Rysuj linie łączące kolejne pomiary wagi
        if (pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
              const cx = pxBase + (m.ageMonths - minX) * xScale;
              const cy = pyBase + phBase - (m.weight - minYw) * yScale;
              if (!started) {
                ctx.moveTo(cx, cy);
                started = true;
              } else {
                ctx.lineTo(cx, cy);
              }
            }
          });
          ctx.stroke();
        }
        // Rysuj punkty wagi
        pts.forEach(m => {
          if (m.ageMonths >= minX && m.ageMonths <= maxX && m.weight >= minYw && m.weight <= maxYwLocal) {
            const cx = pxBase + (m.ageMonths - minX) * xScale;
            const cy = pyBase + phBase - (m.weight - minYw) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          }
        });
      }
      ctx.restore();
    })();
  }

  // Dodaj informację źródłową w prawym dolnym rogu. Informujemy użytkownika,
  // że dane użyte do wygenerowania siatek centylowych pochodzą z badania OLAF.
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  // Uaktualnij informację o źródle danych: siatki 0–3 lata opierają się na standardach WHO,
  // a dla wieku 3–18 lat na badaniu OLAF. Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Aktualizujemy informację o źródle danych: siatki 0–3 lata oparte są na polskim
  // badaniu Palczewskiej i Niedźwieckiej (Warszawa 1999), natomiast siatki 3–18 lat
  // korzystają z badań OLAF (2007–2012).  Dzięki temu użytkownik wie, że wykres jest hybrydowy.
  // Obniżamy podpis w dolnej części strony o około 1 rem (~50 px) względem oryginalnej pozycji.
  const footerY = ph - 60 + 50;
  // Tekst po prawej stronie z informacją o źródłach danych
  ctx.fillText('Dane do siatek centylowych: Palczewska & Niedźwiecka (0–3 lata) i OLAF (3–18 lat)', pw - 120, footerY);
  // Tekst po lewej z nazwą kliniki na tej samej wysokości
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
document.addEventListener('DOMContentLoaded', function() {
  const btn = document.getElementById('generateCentileChart');
  if (btn) {
    btn.addEventListener('click', generateCentileChart);
  }
  // Dodaj obsługę przycisku generowania siatki centylowej z karty zaawansowanej
  const btnAdv = document.getElementById('generateCentileChartAdv');
  if (btnAdv) {
    btnAdv.addEventListener('click', generateCentileChart);
  }
  // Obsługa czyszczenia danych karty zaawansowanej
  const advClear = document.getElementById('advClearBtn');
  if (advClear) {
    advClear.addEventListener('click', () => {
      if (typeof clearAdvancedGrowthCard === 'function') {
        clearAdvancedGrowthCard();
      }
    });
  }
  // Obsługa usuwania wszystkich danych – przywraca aplikację do stanu początkowego
  const clearAll = document.getElementById('clearAllDataBtn');
  if (clearAll) {
    clearAll.addEventListener('click', () => {
      location.reload();
    });
  }
});

</script>

<!-- Now override the default growth chart implementation to support infants (0–<3 lata) and older children (3–18 lat).  -->
<script>
/*
 * Poniższy blok zastępuje standardową funkcję generateCentileChart() oraz dodaje szereg funkcji
 * pomocniczych umożliwiających generowanie dwóch oddzielnych wykresów PDF: jeden dla dzieci
 * młodszych niż 3 lata (0–35 miesięcy) w oparciu o siatki Palczewskiej i Niedźwieckiej, oraz
 * drugi dla wieku 3–18 lat (36–216 miesięcy) oparty na projekcie OLAF.  W przypadku gdy
 * przedział wiekowy przekracza 3. rok życia (minAll <36 i maxAll >36), generowane są dwie
 * strony PDF.  Wszystkie funkcje są deklaracjami funkcyjnymi, dzięki czemu nadpisują wcześniejsze
 * deklaracje o tej samej nazwie w pierwszym skrypcie.
 */

// Bezpiecznie znajdź kanał centylowy dla podanej wartości.  Zwraca indeks kanału (0..len-2) lub -1.
function findHighlightBandSafe(userVal, curves, percentiles, mIdx) {
  if (!Number.isFinite(mIdx)) return -1;
  const anyP = percentiles[0];
  if (!curves[anyP]) return -1;
  const n = curves[anyP].length;
  if (mIdx < 0 || mIdx >= n) return -1;
  const vals = percentiles.map(p => curves[p][mIdx]);
  for (let i = 0; i < vals.length - 1; i++) {
    const a = vals[i], b = vals[i + 1];
    if (a == null || b == null) continue;
    const lo = Math.min(a, b), hi = Math.max(a, b);
    if (userVal >= lo && userVal <= hi) return i;
  }
  return -1;
}

// Zbierz wszystkie wieki (miesiące) z danych podstawowych i zaawansowanych.
function collectAllAgesMonths(ageMonths, adv) {
  const ages = [ageMonths];
  if (adv) {
    if (Number.isFinite(adv.currentAgeMonths)) ages.push(adv.currentAgeMonths);
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const am = Number(m.ageMonths);
        if (Number.isFinite(am)) ages.push(am);
      });
    }
  }
  const minAll = Math.min(...ages);
  const maxAll = Math.max(...ages);
  return { ages, minAll, maxAll };
}

// Filtruj i sortuj pomiary mieszczące się w określonym zakresie stron (wieku).
function collectPageMeasurementsInRange(rangeMinX, rangeMaxX, { currentAgeMonths, currentWeight, currentHeight, adv }) {
  const ptsH = [];
  const ptsW = [];
  if (adv && Array.isArray(adv.measurements)) {
    adv.measurements.forEach(m => {
      const am = Number(m.ageMonths);
      if (!Number.isFinite(am) || am < rangeMinX || am > rangeMaxX) return;
      // Nie używaj Number() dla wartości wzrostu i wagi w pomiarach historycznych,
      // ponieważ Number(null) zamienia null na 0, co powoduje błędne rysowanie punktu 0.
      // Zamiast tego, zastosuj parseFloat() i obsłuż null/undefined/puste pola jako NaN.
      const hRaw = m.height;
      const wRaw = m.weight;
      // Użyj parseFloat() do konwersji tylko wtedy, gdy pole nie jest puste
      const h = (hRaw !== null && hRaw !== undefined && hRaw !== '') ? parseFloat(hRaw) : NaN;
      const w = (wRaw !== null && wRaw !== undefined && wRaw !== '') ? parseFloat(wRaw) : NaN;
      // Jeśli wzrost lub waga są NaN lub nie dodatnie, pomiń je. W rzeczywistości 0 oznacza brak danych,
      // dlatego traktujemy 0 lub wartości ujemne jako brakujące i nie rysujemy takich punktów.
      if (Number.isFinite(h) && h > 0) ptsH.push({ ageMonths: am, height: h });
      if (Number.isFinite(w) && w > 0) ptsW.push({ ageMonths: am, weight: w });
    });
  }
  if (Number.isFinite(currentAgeMonths) && currentAgeMonths >= rangeMinX && currentAgeMonths <= rangeMaxX) {
    // Dodaj bieżący pomiar tylko, gdy waga/wzrost są dodatnie
    if (Number.isFinite(currentHeight) && currentHeight > 0) ptsH.push({ ageMonths: currentAgeMonths, height: currentHeight });
    if (Number.isFinite(currentWeight) && currentWeight > 0) ptsW.push({ ageMonths: currentAgeMonths, weight: currentWeight });
  }
  if (adv && Number.isFinite(adv.currentAgeMonths) && adv.currentAgeMonths >= rangeMinX && adv.currentAgeMonths <= rangeMaxX) {
    if (Number.isFinite(adv.currentHeight) && adv.currentHeight > 0) ptsH.push({ ageMonths: adv.currentAgeMonths, height: adv.currentHeight });
    if (Number.isFinite(adv.currentWeight) && adv.currentWeight > 0) ptsW.push({ ageMonths: adv.currentAgeMonths, weight: adv.currentWeight });
  }
  ptsH.sort((a,b) => a.ageMonths - b.ageMonths);
  ptsW.sort((a,b) => a.ageMonths - b.ageMonths);
  return { ptsH, ptsW };
}

// Zbuduj jedną stronę (0–35 miesięcy Palczewska lub 36–216 miesięcy OLAF) jako canvas.
function buildCentilePageCanvas({
  rangeMinX, rangeMaxX, sex, userAgeMonths, userWeight, userHeight,
  headerTitle, headerSubtitle, footerText
}) {
  // Przygotuj dane centylowe
  const months = [];
  for (let m = rangeMinX; m <= rangeMaxX; m++) months.push(m);
  const percentiles = Object.keys(CENTILE_ZSCORES).map(n => parseInt(n,10)).sort((a,b) => a - b);
  const weightCurves = {}, heightCurves = {};
  percentiles.forEach(p => { weightCurves[p] = []; heightCurves[p] = []; });
  const usePalczewska = rangeMaxX <= 35;
  for (let m of months) {
    for (const p of percentiles) {
      if (usePalczewska) {
        const wVal = getPLWeightCentile(sex, m, p);
        const hVal = getPLHeightCentile(sex, m, p);
        weightCurves[p].push(wVal);
        heightCurves[p].push(hVal);
      } else {
        const [Lw,Mw,Sw] = getLMSWeightHybrid(sex, m);
        const [Lh,Mh,Sh] = getLMSHeightHybrid(sex, m);
        const z = CENTILE_ZSCORES[p];
        weightCurves[p].push(valueFromLMS(Lw, Mw, Sw, z));
        heightCurves[p].push(valueFromLMS(Lh, Mh, Sh, z));
      }
    }
  }
  // Gładzenie krzywych
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice(); const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) tmp[i] = (out[i-1] + out[i] + out[i+1]) / 3;
      out = tmp;
    }
    return out;
  }
  for (const p of percentiles) {
    weightCurves[p] = smoothCurve(weightCurves[p], 6);
    heightCurves[p] = smoothCurve(heightCurves[p], 6);
  }
  // Ustal pierwotne zakresy Y
  let minW = +Infinity, maxW = -Infinity, minH = +Infinity, maxH = -Infinity;
  for (const p of percentiles) {
    for (const v of weightCurves[p]) { if (v < minW) minW = v; if (v > maxW) maxW = v; }
    for (const v of heightCurves[p]) { if (v < minH) minH = v; if (v > maxH) maxH = v; }
  }
  const roundDown5 = v => Math.floor(v/5)*5;
  const roundUp5   = v => Math.ceil(v/5)*5;
  minW = roundDown5(minW); maxW = roundUp5(maxW);
  minH = roundDown5(minH); maxH = roundUp5(maxH);
  // Dynamika – dostosuj zakresy Y do aktualnych pomiarów na tej stronie
  const adv = window.advancedGrowthData || null;
  const { ptsH, ptsW } = collectPageMeasurementsInRange(rangeMinX, rangeMaxX, {
    currentAgeMonths: userAgeMonths,
    currentWeight: userWeight,
    currentHeight: userHeight,
    adv
  });
  // Zainicjuj zakresy pomiarów na podstawie bieżących danych tylko wtedy,
  // gdy waga/wzrost są dodatnie. Zero lub ujemne wartości oznaczają brak danych.
  let minMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : +Infinity;
  let maxMeasuredW = (Number.isFinite(userWeight) && userWeight > 0) ? userWeight : -Infinity;
  let minMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : +Infinity;
  let maxMeasuredH = (Number.isFinite(userHeight) && userHeight > 0) ? userHeight : -Infinity;
  ptsW.forEach(p => { if (p.weight < minMeasuredW) minMeasuredW = p.weight; if (p.weight > maxMeasuredW) maxMeasuredW = p.weight; });
  ptsH.forEach(p => { if (p.height < minMeasuredH) minMeasuredH = p.height; if (p.height > maxMeasuredH) maxMeasuredH = p.height; });
  let dynMinW = (minMeasuredW < minW) ? Math.max(0, roundDown5(minMeasuredW)) : minW;
  let dynMaxW = (maxMeasuredW > maxW) ? roundUp5(maxMeasuredW) : maxW;
  let dynMinH = (minMeasuredH < minH) ? roundDown5(minMeasuredH) : minH;
  let dynMaxH = (maxMeasuredH > maxH) ? roundUp5(maxMeasuredH) : maxH;
  const scaledW = (dynMinW !== minW) || (dynMaxW !== maxW);
  const scaledH = (dynMinH !== minH) || (dynMaxH !== maxH);
  // Tworzenie płótna
  const pw = 2480, ph = 3508;
  const canvas = document.createElement('canvas');
  canvas.width = pw; canvas.height = ph;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, pw, ph);
  // Nagłówek
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#00838d';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(headerTitle, pw/2, 60);
  if (headerSubtitle) {
    ctx.font = '40px sans-serif';
    ctx.fillStyle = '#444';
    ctx.fillText(headerSubtitle, pw/2, 60 + 72 + 8);
  }
  // Imię i nazwisko
  const nameFromState =
    (window.advancedGrowthData && window.advancedGrowthData.name) ||
    (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');
  ctx.font = '40px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'left';
  const nameLabel = nameFromState ? `Imię i nazwisko: ${nameFromState}` : 'Imię i nazwisko: _________________________________';
  ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
  // Wymiary wykresów
  const chartW = pw - 200;
  const availH = ph - 300;
  const interChartMargin = 100;
  const chartsAreaH = availH - interChartMargin;
  let heightGridH, weightGridH;
  if (scaledW || scaledH) {
    const hRange = dynMaxH - dynMinH;
    const wRange = dynMaxW - dynMinW;
    let tmpH = chartsAreaH * (hRange / (hRange + wRange || 1));
    let tmpW = chartsAreaH - tmpH;
    const minHFrac = chartsAreaH * 0.30;
    if (tmpH < minHFrac) { tmpH = minHFrac; tmpW = chartsAreaH - tmpH; }
    heightGridH = tmpH; weightGridH = tmpW;
  } else {
    heightGridH = chartsAreaH / 2; weightGridH = chartsAreaH / 2;
  }
  const yHeightGrid = 300 - 50;
  const yWeightGrid = yHeightGrid + heightGridH + interChartMargin - (50 * 0.5);
  // Podświetlenie kanałów
  // Ustal „efektywne” dane do podświetlenia: jeśli użytkownik korzysta
  // z sekcji Zaawansowane, bieżący wiek/wzrost/masa mogą być wprowadzone
  // właśnie tam (np. uzupełniono tylko w formularzu zaawansowanym).
  const advForHighlight = window.advancedGrowthData || {};
  // Weź wiek z sekcji zaawansowanej, jeśli istnieje i jest liczbą
  const effectiveAgeMonths = (typeof advForHighlight.currentAgeMonths === 'number' && !isNaN(advForHighlight.currentAgeMonths))
    ? advForHighlight.currentAgeMonths
    : userAgeMonths;
  const effectiveHeight = (typeof advForHighlight.currentHeight === 'number' && !isNaN(advForHighlight.currentHeight))
    ? advForHighlight.currentHeight
    : userHeight;
  const effectiveWeight = (typeof advForHighlight.currentWeight === 'number' && !isNaN(advForHighlight.currentWeight))
    ? advForHighlight.currentWeight
    : userWeight;
  const mIdxForPage = effectiveAgeMonths - rangeMinX;
  const hBandIdx = findHighlightBandSafe(effectiveHeight, heightCurves, percentiles, mIdxForPage);
  const wBandIdx = findHighlightBandSafe(effectiveWeight, weightCurves, percentiles, mIdxForPage);
  // Rysuj wzrost
  drawCentileGrid(ctx, {
    x: 100, y: yHeightGrid, w: chartW, h: heightGridH,
    curves: heightCurves,
    minY: dynMinH, maxY: dynMaxH,
    // Do rysowania punktu użytkownika korzystaj z efektywnych wartości (z sekcji
    // Zaawansowane, jeśli tam zostały podane), tak aby marker odzwierciedlał
    // aktualne dane niezależnie od formularza głównego.
    userVal: effectiveHeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Wzrost (cm)', units: 'cm',
    percentiles, highlightBandIdx: hBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxH > maxH) ? maxH : undefined
  });
  // Linie i punkty historii wzrostu
  (function drawHeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    if (ptsH.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsH.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsH.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.height - dynMinH) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();
  // Rysowanie markerów wieku kostnego (aktualny i historyczne) na wykresie wzrostu
  (function drawBoneAgeMarkers() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    // Skopiuj marginesy i obliczenia skali z rysowania historii wzrostu
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    ctx.save();
    // Aktualny wiek kostny
    if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths) &&
        typeof adv.currentHeight === 'number' && typeof adv.currentAgeMonths === 'number') {
      const boneAgeM = adv.boneAgeMonths;
      if (boneAgeM >= rangeMinX && boneAgeM <= rangeMaxX) {
        const cxBone = pxBase + (boneAgeM - rangeMinX) * xScale;
        const cyBone = pyBase + phBase - (adv.currentHeight - dynMinH) * yScale;
        const cxCurrent = pxBase + (adv.currentAgeMonths - rangeMinX) * xScale;
        // pozioma linia
        ctx.beginPath();
        ctx.strokeStyle = '#00838d';
        ctx.lineWidth = 2;
        ctx.moveTo(cxBone, cyBone);
        ctx.lineTo(cxCurrent, cyBone);
        ctx.stroke();
        // kropka z pierścieniem
        ctx.beginPath();
        ctx.fillStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00838d';
        ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
        ctx.stroke();
      }
    }
    // Historyczne wieki kostne
    if (Array.isArray(adv.measurements)) {
      adv.measurements.forEach(m => {
        const hVal = (typeof m.height === 'number' || typeof m.height === 'string') ? parseFloat(m.height) : NaN;
        const ageM = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string') ? parseFloat(m.ageMonths) : NaN;
        const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string') ? parseFloat(m.boneAgeYears) : NaN;
        if (!isNaN(hVal) && !isNaN(ageM) && !isNaN(bVal)) {
          const mBoneMonths = Math.round(bVal * 12);
          if (mBoneMonths >= rangeMinX && mBoneMonths <= rangeMaxX && hVal >= dynMinH && hVal <= dynMaxH) {
            const cxB = pxBase + (mBoneMonths - rangeMinX) * xScale;
            const cyB = pyBase + phBase - (hVal - dynMinH) * yScale;
            const cxCurrM = pxBase + (ageM - rangeMinX) * xScale;
            // linia pozioma
            ctx.beginPath();
            ctx.strokeStyle = '#00838d';
            ctx.lineWidth = 2;
            ctx.moveTo(cxB, cyB);
            ctx.lineTo(cxCurrM, cyB);
            ctx.stroke();
            // kropka z pierścieniem
            ctx.beginPath();
            ctx.fillStyle = '#00838d';
            ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00838d';
            ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
      });
    }
    ctx.restore();
  })();

  // Rysowanie markera docelowego wzrostu (Target Height) na wykresie wzrostu.
  // Marker jest rysowany jako czerwony romb w wieku 18 lat (216 mies.) z etykietą „TH xx,x cm”.
  (function drawTargetHeightMarker() {
    const adv = window.advancedGrowthData || null;
    if (!adv) return;
    const th = adv.targetHeight;
    // Sprawdź, czy docelowy wzrost jest liczbą.
    if (typeof th !== 'number' || isNaN(th)) return;
    // Umieszczamy znacznik w wieku 18 lat (216 mies.).  Rysuj tylko na stronach
    // obejmujących ten wiek (np. 3–18 lat); dla zakresu 0–3 lat znacznik nie jest wyświetlany.
    const mAgeTH = 216;
    if (mAgeTH < rangeMinX || mAgeTH > rangeMaxX) return;
    // Wymiary wykresu wzrostu (ponownie wykorzystujemy marginesy jak w drawHeightHistory).
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yHeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = heightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxH - dynMinH);
    // Oblicz współrzędne rombu.
    const cx = pxBase + (mAgeTH - rangeMinX) * xScale;
    const cy = pyBase + phBase - (th - dynMinH) * yScale;
    // Tylko rysuj, jeśli punkt mieści się w zakresie osi Y.
    if (th < dynMinH || th > dynMaxH) return;
    ctx.save();
    // Rysuj romb w kolorze czerwonym (#c62828)
    ctx.beginPath();
    ctx.fillStyle = '#c62828';
    ctx.moveTo(cx - 10, cy);
    ctx.lineTo(cx, cy - 10);
    ctx.lineTo(cx + 10, cy);
    ctx.lineTo(cx, cy + 10);
    ctx.closePath();
    ctx.fill();
    // Etykieta z wartością docelowego wzrostu (TH)
    const label = 'TH ' + th.toFixed(1) + ' cm';
    ctx.font = 'bold 40px sans-serif';
    ctx.fillStyle = '#c62828';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, cx + 14, cy);
    ctx.restore();
  })();
  // Rysuj wagę
  drawCentileGrid(ctx, {
    x: 100, y: yWeightGrid, w: chartW, h: weightGridH,
    curves: weightCurves,
    minY: dynMinW, maxY: dynMaxW,
    // Analogicznie jak dla wzrostu, dla punktu użytkownika używamy wartości
    // efektywnych (z sekcji zaawansowanej, jeśli podano).
    userVal: effectiveWeight,
    userAgeMonths: effectiveAgeMonths,
    title: 'Waga (kg)', units: 'kg',
    percentiles, highlightBandIdx: wBandIdx,
    minX: rangeMinX, maxX: rangeMaxX,
    cutoffVal: (dynMaxW > maxW) ? maxW : undefined
  });
  // Linie i punkty historii wagi
  (function drawWeightHistory() {
    const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
    const pxBase = 100 + leftMargin;
    const pyBase = yWeightGrid + topMargin;
    const pwBase = chartW - leftMargin - rightMargin;
    const phBase = weightGridH - topMargin - bottomMargin;
    const xScale = pwBase / (rangeMaxX - rangeMinX);
    const yScale = phBase / (dynMaxW - dynMinW);
    ctx.save();
    if (ptsW.length >= 2) {
      ctx.beginPath(); ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      let started = false;
      ptsW.forEach(m => {
        const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
        const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
        if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
      });
      ctx.stroke();
    }
    ptsW.forEach(m => {
      const cx = pxBase + (m.ageMonths - rangeMinX) * xScale;
      const cy = pyBase + phBase - (m.weight - dynMinW) * yScale;
      ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(cx, cy, 8, 0, 2*Math.PI); ctx.fill();
    });
    ctx.restore();
  })();

  // Dodanie podsumowania wyników na siatce centylowej (w trybie profesjonalnym) dla wykresu wzrostu (strony OLAF 3–18 lat)
  (function drawSummaryOverlay() {
    try {
      // Sprawdź, czy aktywny jest tryb profesjonalny
      let professional = false;
      if (typeof professionalMode !== 'undefined') {
        professional = !!professionalMode;
      } else {
        professional = (localStorage.getItem('resultsMode') === 'professional');
      }
      // Pomiń, jeśli nie w trybie profesjonalnym lub jeśli zakres dotyczy tylko dzieci <3 lat
      if (!professional) return;
      if (rangeMaxX <= 35) return;
      // Pobierz linie podsumowania z karty „Podsumowanie wyników”
      const summaryEl = document.getElementById('currentSummaryContent');
      if (!summaryEl) return;
      let raw = summaryEl.innerText || summaryEl.textContent || '';
      raw = raw.trim();
      if (!raw) return;
      const lines = raw.split(/\n+/).map(l => l.trim()).filter(l => l);
      if (!lines.length) return;
      // Oblicz wymiary siatki wzrostu (jak w drawHeightHistory)
      const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
      const pxBase = 100 + leftMargin;
      const pyBase = yHeightGrid + topMargin;
      const pwBase = chartW - leftMargin - rightMargin;
      const phBase = heightGridH - topMargin - bottomMargin;
      const xScale = pwBase / (rangeMaxX - rangeMinX);
      const yScale = phBase / (dynMaxH - dynMinH);
      // Pozycja ramki względem prawego dolnego rogu: 0,5 roku (6 mies.) w osi X i 5 jednostek wzrostu w osi Y
      const offsetMonths = 6;
      const offsetValue  = 5;
      const anchorX = pxBase + pwBase;
      const anchorY = pyBase + phBase;
      ctx.save();
      // Ustaw parametry tekstu
      ctx.font = '32px sans-serif';
      const lineHeight = 42;
      const padding = 20;
      // Oblicz maksymalną szerokość tekstu
      let maxWidth = 0;
      lines.forEach(l => {
        const w = ctx.measureText(l).width;
        if (w > maxWidth) maxWidth = w;
      });
      const bulletRadius = 6;
      const bulletSpacing = 20;
      const boxWidth  = padding * 2 + bulletRadius * 2 + bulletSpacing + maxWidth;
      const boxHeight = padding * 2 + lines.length * lineHeight;
      const dx = offsetMonths * xScale;
      const dy = offsetValue  * yScale;
      const boxX = anchorX - dx - boxWidth;
      const boxY = anchorY - dy - boxHeight;
      // Rysuj tło i obramowanie
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.rect(boxX, boxY, boxWidth, boxHeight);
      ctx.fill();
      ctx.stroke();
      // Ustaw kolor i wyrównanie tekstu
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      // Rysuj punkty i tekst
      lines.forEach((text, idx) => {
        const y = boxY + padding + lineHeight * idx + lineHeight / 2;
        const bx = boxX + padding + bulletRadius;
        // Punktor
        ctx.beginPath();
        ctx.arc(bx, y, bulletRadius, 0, 2 * Math.PI);
        ctx.fill();
        // Tekst
        const tx = bx + bulletRadius + bulletSpacing;
        ctx.fillText(text, tx, y);
      });
      ctx.restore();
    } catch (_) {
      // ignoruj ewentualne błędy rysowania podsumowania
    }
  })();
  // Stopka (źródło danych)
  ctx.save();
  ctx.font = '30px sans-serif';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  const footerY = ph - 60 + 50;
  ctx.fillText(footerText, pw - 120, footerY);
  ctx.textAlign = 'left';
  ctx.fillText('vildaclinic.pl', 120, footerY);
  ctx.restore();
  return canvas;
}

// Główna funkcja generująca PDF.  Tworzy jedną lub dwie strony w zależności od tego,
// czy dane przekraczają próg 3 lat.
async function generateCentileChart() {
  const ageEl = document.getElementById('age');
  const ageMonthsEl = document.getElementById('ageMonths');
  const weightEl = document.getElementById('weight');
  const heightEl = document.getElementById('height');
  const sexEl = document.getElementById('sex');
  const yearsVal = parseFloat(ageEl.value) || 0;
  const monthsVal = ageMonthsEl ? (parseFloat(ageMonthsEl.value) || 0) : 0;
  const ageYears = yearsVal + monthsVal/12;
  const weight = parseFloat(weightEl.value);
  const height = parseFloat(heightEl.value);
  const sex = (sexEl.value === 'M') ? 'M' : 'F';
  if (!Number.isFinite(ageYears) || !Number.isFinite(weight) || !Number.isFinite(height)) {
    alert('Wprowadź poprawne dane liczbowe.');
    return;
  }
  const ageMonths = Math.round(ageYears * 12);
  if (ageMonths < 0 || ageMonths > 216) {
    alert('Siatka centylowa dostępna jest dla wieku od 0 do 18 lat.');
    return;
  }
  const adv = window.advancedGrowthData || null;
  const { minAll, maxAll } = collectAllAgesMonths(ageMonths, adv);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  function addPage({ minX, maxX, subtitle, footer }) {
    const canvas = buildCentilePageCanvas({
      rangeMinX: minX, rangeMaxX: maxX, sex,
      userAgeMonths: ageMonths, userWeight: weight, userHeight: height,
      headerTitle: (sex === 'M' ? 'Siatka centylowa chłopcy' : 'Siatka centylowa dziewczynki'),
      headerSubtitle: subtitle,
      footerText: footer
    });
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
  }
  const spansAcross3yo = (minAll < 36) && (maxAll > 36);
  if (spansAcross3yo) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
    pdf.addPage();
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  } else if (maxAll <= 35) {
    addPage({ minX: 0, maxX: 35, subtitle: 'Zakres: 0–<3 lata', footer: 'Dane do siatek: Palczewska & Niedźwiecka (0–<3 lata)' });
  } else {
    addPage({ minX: 36, maxX: 216, subtitle: 'Zakres: 3–18 lat', footer: 'Dane do siatek: OLAF (3–18 lat)' });
  }
  const blob = pdf.output('blob');
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
}
// === KONIEC NOWEJ IMPLEMENTACJI SIATKI CENTYLOWEJ ===
</script>

<!-- Skrypt generujący siatkę centylową DS (wzrost i waga) w formacie PDF -->
<script>
// === DOWN SYNDROME (DS) GROWTH CHARTS → PDF (0–20 lat) ==================
// Wymaga: ds_lms.js (window.DS), drawCentileGrid(), valueFromLMS(), getLMSFromDataset(),
// CENTILE_ZSCORES oraz biblioteki jsPDF (już są w tej stronie).
(function(){
  const ZS = (typeof CENTILE_ZSCORES === 'object' && CENTILE_ZSCORES) || {3:-1.8808,10:-1.281552,25:-0.67448975,50:0,75:0.67448975,90:1.281552,97:1.8808};
  const hasGetLMS = (typeof getLMSFromDataset === 'function');
  const hasValLMS = (typeof valueFromLMS === 'function');
  function getLMSFromDatasetSafe(dataset, m){
    if (hasGetLMS) return getLMSFromDataset(dataset, m);
    const keys = Object.keys(dataset).map(k=>parseInt(k,10)).sort((a,b)=>a-b);
    if (dataset[m]) return dataset[m];
    let lo = keys[0], hi = keys[keys.length-1];
    for (let i=0;i<keys.length;i++){ if (keys[i] <= m) lo = keys[i]; if (keys[i] >= m){ hi = keys[i]; break; } }
    const vLo = dataset[lo], vHi = dataset[hi];
    if (!vLo || !vHi) return vLo || vHi;
    if (lo === hi) return vLo;
    const t = (m-lo)/(hi-lo);
    return [ vLo[0]+t*(vHi[0]-vLo[0]), vLo[1]+t*(vHi[1]-vLo[1]), vLo[2]+t*(vHi[2]-vLo[2]) ];
  }
  function valueFromLMSSafe(L,M,S,z){
    if (hasValLMS) return valueFromLMS(L,M,S,z);
    return (L !== 0) ? (M * Math.pow(1 + L*S*z, 1/L)) : (M * Math.exp(S*z));
  }
  function yearsToMonthsMap(objYears){
    const out = {};
    Object.keys(objYears || {}).forEach(k=>{
      const m = Math.round(parseFloat(k)*12);
      out[m] = objYears[k];
    });
    return out;
  }
  const DS_DATA = (typeof window !== 'undefined' && window.DS) ? window.DS : null;
  const CHILD_W_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_GIRLS)  : {};
  const CHILD_W_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_WEIGHT_BOYS)   : {};
  const CHILD_H_G  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_GIRLS)  : {};
  const CHILD_H_B  = DS_DATA ? yearsToMonthsMap(DS_DATA.DS_CHILD_HEIGHT_BOYS)   : {};
  function dsGetLMSWeight(sex, m){
    if (!DS_DATA) return null;
    if (m <= 36){
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_WEIGHT_BOYS : DS_DATA.DS_INFANT_WEIGHT_GIRLS, m);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_W_B : CHILD_W_G, m);
    }
  }
  function dsGetLMSHeight(sex, m){
    if (!DS_DATA) return null;
    if (m < 36){
      const mm = Math.max(1, m);
      return getLMSFromDatasetSafe(sex==='M' ? DS_DATA.DS_INFANT_LENGTH_BOYS : DS_DATA.DS_INFANT_LENGTH_GIRLS, mm);
    } else {
      return getLMSFromDatasetSafe(sex==='M' ? CHILD_H_B : CHILD_H_G, m);
    }
  }
  const DS_PERCENTILES = [3,10,25,50,75,90,97];
  /*
   * Krótkie wygładzanie krzywych centylowych dla dzieci z zespołem Downa.
   * Zastosowano prosty filtr średniej kroczącej (okno 3, 6 przebiegów),
   * podobnie jak w siatkach centylowych OLAF.  Dzięki temu linie krzywych
   * DS są bardziej płynne i pozbawione ostrych załamań.
   *
   * @param {number[]} arr  Tablica wartości centylowych do wygładzenia
   * @param {number}   passes Liczba przebiegów wygładzania (domyślnie 6)
   * @returns {number[]} Wygładzona tablica
   */
  function smoothCurve(arr, passes = 6) {
    let out = arr.slice();
    const n = out.length;
    for (let pass = 0; pass < passes; pass++) {
      const tmp = out.slice();
      for (let i = 1; i < n - 1; i++) {
        tmp[i] = (out[i - 1] + out[i] + out[i + 1]) / 3;
      }
      out = tmp;
    }
    return out;
  }
  function buildCurves(minX, maxX, sex, lmsGetter){
    const curves = {};
    DS_PERCENTILES.forEach(p=>{
      const z = ZS[p];
      const arr = [];
      for (let m=minX; m<=maxX; m++){
        const lms = lmsGetter(sex, m);
        arr.push(lms ? valueFromLMSSafe(lms[0], lms[1], lms[2], z) : null);
      }
      curves[p] = arr;
    });
    return curves;
  }
  function rangeFromCurves(curves){
    let lo = +Infinity, hi = -Infinity;
    Object.values(curves).forEach(arr=>{
      arr.forEach(v=>{ if (v==null) return; if (v<lo) lo=v; if (v>hi) hi=v; });
    });
    if (!isFinite(lo) || !isFinite(hi)){ lo = 0; hi = 1; }
    const pad = 0.05*(hi-lo);
    lo = Math.floor((lo - pad)/5)*5;
    hi = Math.ceil ((hi + pad)/5)*5;
    return [lo, hi];
  }
  function findHighlightBandLocal(userVal, curves, percentiles, mIdx){
    if (!Number.isFinite(mIdx)) return -1;
    const anyP = percentiles[0];
    if (!curves[anyP]) return -1;
    const n = curves[anyP].length;
    if (mIdx < 0 || mIdx >= n) return -1;
    const vals = percentiles.map(p => curves[p][mIdx]);
    for (let i=0;i<vals.length-1;i++){
      const a = vals[i], b = vals[i+1];
      if (a==null || b==null) continue;
      const lo = Math.min(a,b), hi = Math.max(a,b);
      if (userVal >= lo && userVal <= hi) return i;
    }
    return -1;
  }
  function findBand(userVal, curves, percentiles, mIdx){
    if (typeof findHighlightBandSafe === 'function'){
      return findHighlightBandSafe(userVal, curves, percentiles, mIdx);
    }
    return findHighlightBandLocal(userVal, curves, percentiles, mIdx);
  }
  function generateDsCentileChart(){
    const ageEl    = document.getElementById('age');
    const ageMEl   = document.getElementById('ageMonths');
    const sexEl    = document.getElementById('sex');
    const weightEl = document.getElementById('weight');
    const heightEl = document.getElementById('height');
    if (!ageEl || !sexEl || !weightEl || !heightEl){
      alert('Wprowadź wiek, płeć, wagę i wzrost.');
      return;
    }
    const years  = parseFloat(ageEl.value)   || 0;
    const months = ageMEl ? (parseFloat(ageMEl.value) || 0) : 0;
    const ageMonths = Math.round(years*12 + months);
    if (!(ageMonths >= 0 && ageMonths <= 240)){
      alert('Siatka DS dostępna dla wieku 0–20 lat.');
      return;
    }
    const sex = (sexEl.value === 'M') ? 'M' : 'F';
    const w   = parseFloat(weightEl.value);
    const h   = parseFloat(heightEl.value);
    const minX = 0, maxX = 240;
    const weightCurves = buildCurves(minX, maxX, sex, dsGetLMSWeight);
    const heightCurves = buildCurves(minX, maxX, sex, dsGetLMSHeight);
    // Wygładź krzywe DS przy użyciu tego samego algorytmu co w siatkach OLAF
    for (const p of DS_PERCENTILES) {
      if (Array.isArray(weightCurves[p])) {
        weightCurves[p] = smoothCurve(weightCurves[p], 6);
      }
      if (Array.isArray(heightCurves[p])) {
        heightCurves[p] = smoothCurve(heightCurves[p], 6);
      }
    }
    const [wMin, wMax] = rangeFromCurves(weightCurves);
    const [hMin, hMax] = rangeFromCurves(heightCurves);
    const canvas = document.createElement('canvas');
    canvas.width  = 2480;
    canvas.height = 3508;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const topBox = { x:80, y:40, w:canvas.width-160, h:Math.floor(canvas.height/2) - 100 };
    const botBox = { x:80, y:Math.floor(canvas.height/2)+60, w:canvas.width-160, h:Math.floor(canvas.height/2) - 120 };
    const hiBandH = (Number.isFinite(h) ? findBand(h, heightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: topBox.x, y: topBox.y, w: topBox.w, h: topBox.h,
      curves: heightCurves,
      minY: hMin, maxY: hMax,
      userVal: Number.isFinite(h) ? h : undefined,
      userAgeMonths: ageMonths,
      title: 'Wzrost (cm)',
      units: 'cm',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandH,
      minX, maxX
    });
    const hiBandW = (Number.isFinite(w) ? findBand(w, weightCurves, DS_PERCENTILES, ageMonths - minX) : -1);
    drawCentileGrid(ctx, {
      x: botBox.x, y: botBox.y, w: botBox.w, h: botBox.h,
      curves: weightCurves,
      minY: wMin, maxY: wMax,
      userVal: Number.isFinite(w) ? w : undefined,
      userAgeMonths: ageMonths,
      title: 'Waga (kg)',
      units: 'kg',
      percentiles: DS_PERCENTILES,
      highlightBandIdx: hiBandW,
      minX, maxX
    });
    ctx.save();
    ctx.font = '30px sans-serif';
    ctx.fillStyle = '#555555';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    // Przesuń napisy w dolnej części siatki o dodatkową jednostkę (1 rem ≈ 50 px)
    // aby uniknąć nałożenia się na etykietę osi wieku. Dzięki temu tekst źródła
    // („Dane DS: Zemel et al., Pediatrics 2015…”) oraz nazwa kliniki („vildaclinic.pl”)
    // znajdują się niżej o ok. 50 px w stosunku do poprzedniej wersji.
    const dsFooterY = canvas.height - 80 + 50;
    ctx.fillText('Dane DS: Zemel et al., Pediatrics 2015 (0–20 lat)', canvas.width - 120, dsFooterY);
    ctx.textAlign = 'left';
    ctx.fillText('vildaclinic.pl', 120, dsFooterY);
    ctx.restore();
    const dataUrl = canvas.toDataURL('image/jpeg', 1.0);
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    pdf.addImage(dataUrl, 'JPEG', 0, 0, 210, 297);
    const blob = pdf.output('blob');
    const url  = URL.createObjectURL(blob);
    window.open(url, '_blank');
  }
  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('generateDsCentileChart');
    if (btn) {
      btn.addEventListener('click', generateDsCentileChart);
    }
  });
})();
</script>
<!-- Liquid iOS26 UI script: applies glassmorphism and micro‑interactions. The version query
     string busts the service worker cache so updated code is loaded immediately. -->
<script src="ios26-ui.js?v=2" defer></script>
<!-- Guided tutorial for first‑time users -->
<script src="tutorial.js" defer></script>

<!-- Moduł ciśnienia krwi: oblicza percentyle ciśnienia na podstawie wieku,
     wzrostu, płci oraz wprowadzonych wartości skurczowych i rozkurczowych.
     Skrypt ten powinien być ładowany po głównych plikach app.js i innych
     modułach, aby korzystał z istniejących funkcji pomocniczych (np. getAgeDecimal, getLMSHeightHybrid, applyPulse). -->
<script src="bp_module.js" defer></script>

<!-- Moduł obwodów głowy i klatki piersiowej.  
     Skrypt powinien być ładowany po module ciśnienia krwi, aby mieć dostęp do funkcji pomocniczych jak applyPulse.
     Określenie defer gwarantuje, że skrypt uruchomi się po załadowaniu struktury DOM. -->
<script src="circumference_module.js" defer></script>

<!-- Prosta obsługa przycisku rozwijającego kartę obwodów głowy i klatki piersiowej.
     Po załadowaniu DOM przypinamy zdarzenie click do przycisku toggleCircSection,
     które przełącza widoczność karty #circCard. -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const toggleBtn = document.getElementById('toggleCircSection');
    const circCard = document.getElementById('circCard');
    if (toggleBtn && circCard) {
      toggleBtn.addEventListener('click', function() {
        if (circCard.style.display === 'none' || circCard.style.display === '') {
          circCard.style.display = 'block';
        } else {
          circCard.style.display = 'none';
        }
      });
    }
  });
</script>

<!-- Register the service worker for offline support and updates.
     W trybie debugowania możesz całkowicie wyłączyć rejestrację,
     aby uniknąć problemów z cache – ustaw DEBUG_SW na true/false poniżej. -->
<script>
  (function() {
    const DEBUG_SW = false; // Ustaw na false, aby zarejestrować service worker na serwerze home.pl
    if (!DEBUG_SW && 'serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker-kalorii.js')
          .then(function(registration) {
            console.log('Service worker registered with scope:', registration.scope);
          })
          .catch(function(error) {
            console.error('Service worker registration failed:', error);
          });
      });
    } else {
      console.log('Service worker registration skipped (DEBUG_SW = true)');
    }
  })();
</script>
  <!-- Skrypt obsługujący podsumowanie metaboliczne.  
       Funkcja ta generuje tekstowe podsumowanie wyników obliczeń (centyle, Z‑score)  
       i kopiuje je do schowka.  
       Odczytuje aktualny tryb wyników (standardowy/profesjonalny) z localStorage,
       dzięki czemu zawartość podsumowania reaguje na przełącznik wyników. -->
  <script>
    // Podsumowanie metaboliczne – obsługa przycisku i generowania wyników
    document.addEventListener('DOMContentLoaded', function() {
      const summarySection = document.getElementById('metabolicSummarySection');
      const summaryBtn = document.getElementById('metabolicSummaryBtn');
      // Funkcja kontrolująca widoczność przycisku podsumowania
      function updateMetabolicSummaryVisibility() {
        const ageYears  = parseFloat(document.getElementById('age')?.value) || 0;
        const weightVal = parseFloat(document.getElementById('weight')?.value) || 0;
        const heightVal = parseFloat(document.getElementById('height')?.value) || 0;
        if (summarySection) {
          summarySection.style.display = (ageYears > 0 && weightVal > 0 && heightVal > 0) ? 'block' : 'none';
        }
      }
      ['age','ageMonths','weight','height'].forEach(function(id){
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener('input', updateMetabolicSummaryVisibility);
          el.addEventListener('change', updateMetabolicSummaryVisibility);
        }
      });
      // Ustaw widoczność przy inicjalizacji
      updateMetabolicSummaryVisibility();

      // Funkcja generująca tekst podsumowania. Korzysta z funkcji globalnych app.js i modułów,
      // ale obliczenia są wykonywane niezależnie od interfejsu wyświetlającego wyniki.  
      function generateMetabolicSummary() {
        const lines = [];
        // Odczytaj tryb wyników: 'professional' → tryb profesjonalny (włącz Z‑score)
        // Użyj globalnej zmiennej professionalMode ustawianej w app.js, aby
        // zagwarantować zgodność z aktualnym stanem przełącznika wyników.
        // Jeśli zmienna nie jest dostępna (np. w starszych wersjach), odczytaj z localStorage.
        let professional;
        if (typeof professionalMode !== 'undefined') {
          professional = !!professionalMode;
        } else {
          professional = (localStorage.getItem('resultsMode') === 'professional');
        }
        const yearsInput  = document.getElementById('age');
        const monthsInput = document.getElementById('ageMonths');
        const weightInput = document.getElementById('weight');
        const heightInput = document.getElementById('height');
        const sexInput    = document.getElementById('sex');
        const ageYears  = yearsInput  ? parseFloat(yearsInput.value)   || 0 : 0;
        const ageMonths = monthsInput ? parseFloat(monthsInput.value) || 0 : 0;
        const age       = ageYears + ageMonths / 12;
        const weightVal = weightInput ? parseFloat(weightInput.value) || 0 : 0;
        const heightVal = heightInput ? parseFloat(heightInput.value)|| 0 : 0;
        const sex       = sexInput && sexInput.value ? sexInput.value : 'M';
        // Oblicz centyle wagi i wzrostu (użyj odpowiedniego zestawu danych)
        if (age > 0 && weightVal > 0 && heightVal > 0) {
          // Określ źródło danych BMI z zaznaczonego suwaka (Palczewska, OLAF, WHO)
          const dataSourceEl = document.querySelector('input[name="dataSource"]:checked');
          const dataSource   = dataSourceEl ? dataSourceEl.value : 'OLAF';
          let statsW, statsH;
          // Wybierz Palczewską dla wszystkich wieku, jeśli wybrano Palczewską,
          // lub dla OLAF gdy wiek < 3 lata (brak danych OLAF dla niemowląt)
          const usePal = (dataSource === 'PALCZEWSKA') || (dataSource === 'OLAF' && age < 3);
          if (typeof calcPercentileStatsPal === 'function' && typeof calcPercentileStats === 'function') {
            if (usePal) {
              statsW = calcPercentileStatsPal(weightVal, sex, age, 'WT');
              statsH = calcPercentileStatsPal(heightVal, sex, age, 'HT');
            } else {
              statsW = calcPercentileStats(weightVal, sex, age, 'WT');
              statsH = calcPercentileStats(heightVal, sex, age, 'HT');
            }
          }
          // Oblicz wartości graniczne 3. i 97. centyla dla wagi i wzrostu,
          // które zostaną użyte do wyświetlenia różnicy w podsumowaniu.
          let w3, w97, h3, h97;
          if (statsW && statsH) {
            const monthsWH = Math.round(age * 12);
            if (usePal) {
              // granice z siatek Palczewskiej
              if (typeof getPalCentile === 'function') {
                w3  = getPalCentile(sex, monthsWH, 3, 'WT');
                w97 = getPalCentile(sex, monthsWH, 97, 'WT');
                h3  = getPalCentile(sex, monthsWH, 3, 'HT');
                h97 = getPalCentile(sex, monthsWH, 97, 'HT');
              }
            } else {
              // granice z funkcji LMS (WHO/OLAF)
              if (typeof getChildLMS === 'function') {
                const lmsW = getChildLMS(sex, age, 'WT');
                if (lmsW) {
                  w3 = (lmsW[0] !== 0)
                       ? lmsW[1] * Math.pow(1 + lmsW[0] * lmsW[2] * Z3, 1 / lmsW[0])
                       : lmsW[1] * Math.exp(lmsW[2] * Z3);
                  w97 = (lmsW[0] !== 0)
                        ? lmsW[1] * Math.pow(1 + lmsW[0] * lmsW[2] * Z97, 1 / lmsW[0])
                        : lmsW[1] * Math.exp(lmsW[2] * Z97);
                }
                const lmsH = getChildLMS(sex, age, 'HT');
                if (lmsH) {
                  h3 = (lmsH[0] !== 0)
                       ? lmsH[1] * Math.pow(1 + lmsH[0] * lmsH[2] * Z3, 1 / lmsH[0])
                       : lmsH[1] * Math.exp(lmsH[2] * Z3);
                  h97 = (lmsH[0] !== 0)
                         ? lmsH[1] * Math.pow(1 + lmsH[0] * lmsH[2] * Z97, 1 / lmsH[0])
                         : lmsH[1] * Math.exp(lmsH[2] * Z97);
                }
              }
            }
          }
          // Waga: sformatowany centyl i różnica do 3./97. centyla
          if (statsW && statsW.percentile != null) {
            // Używamy formatCentile() do reprezentacji wartości skrajnych (<1, >99,9)
            let percStrW = (typeof formatCentile === 'function') ? formatCentile(statsW.percentile) : Math.round(statsW.percentile).toString();
            let wordW = (typeof centylWord === 'function') ? centylWord(percStrW) : 'centyl';
            // Dekoduj encje HTML na zwykłe znaki (HTML jest używany w formatCentile)
            let decodedW = percStrW.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
            let line = 'Waga: ' + decodedW + ' ' + wordW;
            if (professional && typeof statsW.sd === 'number' && isFinite(statsW.sd)) {
              line += ' (Z‑score = ' + statsW.sd.toFixed(2) + ')';
            }
            // Jeśli waga jest poniżej 3. centyla (po zaokrągleniu), pokaż różnicę do 3. centyla
            const roundedWeight = Math.round(statsW.percentile);
            if (typeof w3 === 'number' && roundedWeight <= 2) {
              line += ', brakuje ' + (w3 - weightVal).toFixed(1) + '\u202Fkg do 3\u202Fcentyla';
            }
            // Jeśli waga jest ponad 97. centyl, pokaż nadwyżkę
            if (typeof w97 === 'number' && statsW.percentile >= 98) {
              line += ', +' + (weightVal - w97).toFixed(1) + '\u202Fkg ponad 97\u202Fcentyl';
            }
            lines.push(line);
          }
          // Wzrost: sformatowany centyl i różnica do 3./97. centyla
          if (statsH && statsH.percentile != null) {
            let percStrH = (typeof formatCentile === 'function') ? formatCentile(statsH.percentile) : Math.round(statsH.percentile).toString();
            let wordH = (typeof centylWord === 'function') ? centylWord(percStrH) : 'centyl';
            let decodedH = percStrH.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
            let line = 'Wzrost: ' + decodedH + ' ' + wordH;
            if (professional && typeof statsH.sd === 'number' && isFinite(statsH.sd)) {
              line += ' (Z‑score = ' + statsH.sd.toFixed(2) + ')';
            }
            const roundedHeight = Math.round(statsH.percentile);
            if (typeof h3 === 'number' && roundedHeight <= 2) {
              line += ', brakuje ' + (h3 - heightVal).toFixed(1) + '\u202Fcm do 3\u202Fcentyla';
            }
            if (typeof h97 === 'number' && statsH.percentile >= 98) {
              line += ', +' + (heightVal - h97).toFixed(1) + '\u202Fcm ponad 97\u202Fcentyl';
            }
            lines.push(line);
          }
          // BMI: wartość, centyl, z‑score
          if (weightVal > 0 && heightVal > 0) {
            const bmiVal = weightVal / ((heightVal/100) * (heightVal/100));
            const months = Math.round(age * 12);
            let bmiPerc = null;
            let bmiZ   = null;
            if (usePal && typeof calcPercentileStatsPal === 'function') {
              const statsB = calcPercentileStatsPal(bmiVal, sex, age, 'BMI');
              if (statsB) {
                bmiPerc = statsB.percentile;
                bmiZ   = statsB.sd;
              }
            } else {
              if (typeof bmiPercentileChild === 'function') {
                bmiPerc = bmiPercentileChild(bmiVal, sex, months);
              }
              if (typeof bmiZscore === 'function') {
                bmiZ   = bmiZscore(bmiVal, sex, months);
              }
            }
            if (bmiPerc != null && isFinite(bmiPerc)) {
              // Użyj formatCentile do reprezentacji skrajnych percentyli BMI (<1, >99,9)
              let percStrBMI = (typeof formatCentile === 'function') ? formatCentile(bmiPerc) : Math.round(bmiPerc).toString();
              let wordBMI    = (typeof centylWord === 'function') ? centylWord(percStrBMI) : 'centyl';
              let decodedBMI = percStrBMI.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
              let line = 'BMI: ' + bmiVal.toFixed(1) + ' – ' + decodedBMI + ' ' + wordBMI;
              if (professional && bmiZ != null && isFinite(bmiZ)) {
                line += ' (Z‑score = ' + bmiZ.toFixed(2) + ')';
              }
              lines.push(line);
            }
          }
          // Powierzchnia ciała (BSA) – Haycock
          if (weightVal > 0 && heightVal > 0) {
            const bsa = 0.024265 * Math.pow(weightVal, 0.5378) * Math.pow(heightVal, 0.3964);
            lines.push('Pow. ciała: ' + bsa.toFixed(2) + ' m²');
          }
          // Wskaźnik Cole’a (procentowa relacja BMI do mediany BMI)
          if (typeof getLMS === 'function') {
            const monthsL = Math.round(age * 12);
            const lms = getLMS(sex, monthsL);
            if (lms && Array.isArray(lms) && lms.length > 1 && lms[1] > 0) {
              const bmiVal2 = weightVal / ((heightVal/100) * (heightVal/100));
              const cole = (bmiVal2 / lms[1]) * 100;
              lines.push('Wskaźnik Cole’a: ' + cole.toFixed(1) + '%');
            }
          } else if (typeof window !== 'undefined' && window.colePercentValue != null) {
            // Fallback: skorzystaj z obliczonej wartości globalnej, jeśli dostępna
            try {
              lines.push('Wskaźnik Cole’a: ' + window.colePercentValue.toFixed(1) + '%');
            } catch (e) {}
          }
        }
        // Dodaj ciśnienie tętnicze, jeśli wartości globalne są ustawione
        if (typeof window !== 'undefined') {
          if (window.percSbp != null) {
            let sbpLine = 'Ciśnienie skurczowe: ' + Math.round(window.percSbp) + ' centyl';
            if (professional && typeof window.zSbp === 'number' && isFinite(window.zSbp)) {
              sbpLine += ' (Z‑score = ' + window.zSbp.toFixed(2) + ')';
            }
            lines.push(sbpLine);
          }
          if (window.percDbp != null) {
            let dbpLine = 'Ciśnienie rozkurczowe: ' + Math.round(window.percDbp) + ' centyl';
            if (professional && typeof window.zDbp === 'number' && isFinite(window.zDbp)) {
              dbpLine += ' (Z‑score = ' + window.zDbp.toFixed(2) + ')';
            }
            lines.push(dbpLine);
          }
          if (window.headCircPercentile != null) {
            let headLine = 'Obwód głowy: ' + Math.round(window.headCircPercentile) + ' centyl';
            if (professional && typeof window.headCircSD === 'number' && isFinite(window.headCircSD)) {
              headLine += ' (Z‑score = ' + window.headCircSD.toFixed(2) + ')';
            }
            lines.push(headLine);
          }
          if (window.chestCircPercentile != null) {
            let chestLine = 'Obwód klatki piersiowej: ' + Math.round(window.chestCircPercentile) + ' centyl';
            if (professional && typeof window.chestCircSD === 'number' && isFinite(window.chestCircSD)) {
              chestLine += ' (Z‑score = ' + window.chestCircSD.toFixed(2) + ')';
            }
            lines.push(chestLine);
          }
          // Dodaj dane z modułu zaawansowanego wzrostu, jeśli dostępne
          if (window.advancedGrowthData && typeof window.advancedGrowthData === 'object') {
            const ag = window.advancedGrowthData;
            if (typeof ag.currentVelocity === 'number' && isFinite(ag.currentVelocity)) {
              lines.push('Tempo wzrastania: ' + ag.currentVelocity.toFixed(1) + ' cm/rok');
            }
            if (ag.targetHeight) {
              // Upewnij się, że liczba jest sformatowana z jedną cyfrą po przecinku
              const thVal = parseFloat(ag.targetHeight);
              // Zmieniono etykietę na MPH (mid‑parental height)
              let thLine = 'MPH (mid-parental height): ' + (isNaN(thVal) ? ag.targetHeight : thVal.toFixed(1)) + ' cm';
              // Użyj targetStats, jeśli dostępny – zawiera percentile i z‑score
              if (ag.targetStats && typeof ag.targetStats.percentile === 'number') {
                const cent = Math.round(ag.targetStats.percentile);
                if (professional && typeof ag.targetStats.sd === 'number' && isFinite(ag.targetStats.sd)) {
                  thLine += ' – centyl: ' + cent + ', z-score: ' + ag.targetStats.sd.toFixed(2);
                } else {
                  thLine += ' – centyl: ' + cent;
                }
              }
              lines.push(thLine);
              // W trybie profesjonalnym oblicz różnicę pomiędzy Z‑score aktualnego wzrostu (hSDS)
              // a z‑score potencjału wzrostowego (mpSDS). Umożliwia to ocenę, na ile bieżący
              // wzrost dziecka odbiega od przewidywanego na podstawie wzrostu rodziców.
              if (professional && ag.targetStats && typeof ag.targetStats.sd === 'number') {
                // Oblicz Z‑score aktualnego wzrostu używając tego samego źródła danych co w innych częściach
                // podsumowania. Nie odwołuj się do zmiennej usePal z innego zakresu, aby uniknąć błędu.
                let statsHeightDiff = null;
                // Ponownie odczytaj wybrane źródło danych (Palczewska, OLAF, WHO) i ustal, czy użyć Palczewskiej
                const dsEl = document.querySelector('input[name="dataSource"]:checked');
                const dsVal = dsEl ? dsEl.value : 'OLAF';
                const usePalForDiff = (dsVal === 'PALCZEWSKA') || (dsVal === 'OLAF' && age < 3);
                if (typeof calcPercentileStatsPal === 'function' && typeof calcPercentileStats === 'function') {
                  if (usePalForDiff) {
                    statsHeightDiff = calcPercentileStatsPal(heightVal, sex, age, 'HT');
                  } else {
                    statsHeightDiff = calcPercentileStats(heightVal, sex, age, 'HT');
                  }
                }
                if (statsHeightDiff && typeof statsHeightDiff.sd === 'number') {
                  const diffSummary = statsHeightDiff.sd - ag.targetStats.sd;
                  lines.push('hSDS - mpSDS: ' + diffSummary.toFixed(2));
                }
              }
            }
          }
        }
        return lines.join('\n');
      }
      // Funkcja kopiująca tekst do schowka; używa Clipboard API z fallbackiem
      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
        } else {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
          } catch (e) {}
          document.body.removeChild(textarea);
          return Promise.resolve();
        }
      }
      // Pokazuje krótki komunikat na dole ekranu z potwierdzeniem kopiowania
      function showMetabolicToast() {
        const toast = document.createElement('div');
        toast.textContent = 'Dane zostały skopiowane do schowka.';
        toast.style.position = 'fixed';
        toast.style.bottom = '1rem';
        toast.style.left = '50%';
        toast.style.transform = 'translateX(-50%)';
        toast.style.background = '#00838d';
        toast.style.color = 'white';
        toast.style.padding = '0.6rem 1.2rem';
        toast.style.borderRadius = '4px';
        toast.style.fontSize = '1rem';
        toast.style.zIndex = '9999';
        document.body.appendChild(toast);
        setTimeout(() => {
          toast.remove();
        }, 2500);
      }
      if (summaryBtn) {
        summaryBtn.addEventListener('click', function() {
          const text = generateMetabolicSummary();
          copyToClipboard(text).then(() => {
            showMetabolicToast();
          });
        });
      }
    });
  </script>

  <!-- Baner cookies / lokalnego przechowywania danych -->
<div id="consent-banner" class="cookie-banner hidden">
  <p>
    Korzystając z aplikacji <strong>Vilda Clinic</strong> zapisujemy niewielkie ilości danych w Twojej przeglądarce:
  </p>
  <ul>
    <li><strong>Pliki niezbędne:</strong> Service Worker zapisuje pliki aplikacji (HTML, CSS, JavaScript, grafiki) w Cache Storage, aby umożliwić działanie offline. Nie zbiera żadnych danych osobowych.</li>
    <li><strong>Pamięć funkcjonalna:</strong> Po weryfikacji numeru PWZ możesz zdecydować, czy zapamiętać go w tej przeglądarce. Numer zostanie zapisany w localStorage wyłącznie w Twoim urządzeniu i nie jest nigdzie wysyłany.</li>
    <li><strong>Analityka:</strong> Google Analytics (GA4) używa własnych plików cookie, aby tworzyć anonimowe statystyki odwiedzin. Nie zapisuje danych wpisywanych w aplikacji. Zgoda na analitykę jest dobrowolna i możesz ją wycofać.</li>
  </ul>
  <div class="cookie-buttons">
    <button id="consent-accept">Akceptuję analitykę</button>
    <button id="consent-decline">Odrzucam analitykę</button>
  </div>
</div>
  <!-- Przycisk "powrót na górę" widoczny w widoku mobilnym. Po kliknięciu
       przenosi użytkownika na szczyt strony. Ikona jest generowana przez
       bibliotekę Lucide. -->
  <button id="scrollTopBtn" aria-label="Powrót na górę strony" type="button" onclick="scrollToTop()">
    <i data-lucide="arrow-up"></i>
  </button>

  <!--
       Własne poprawki: łączenie kart "Podsumowanie wyników" w widoku
       jednokolumnowym oraz wyłączenie automatycznego przewijania przy
       przełączaniu trybu wyników na wąskich ekranach.
       Plik custom-fixes.js implementuje te funkcje poprzez
       obserwację DOM i modyfikację scrollIntoView. -->
  <script src="custom-fixes.js" defer></script>

  <!-- Dynamic repositioning of Cole and Advanced Growth cards on mobile/desktop
       views.  This script adjusts the DOM order of these elements only in
       the single‑column layout.  It is loaded after all other scripts to
       ensure that the elements exist in the DOM before repositioning. -->
  <script src="reposition.js" defer></script>

  <!-- Debug output for currentSummaryCard status (temporary) -->
  <!-- Usunięto paski debugowe -->

  <!-- ============================================================= -->
  <!--  Nowe funkcje generowania siatek centylowych Palczewskiej      -->
  <!--  Funkcje te umożliwiają utworzenie dwóch oddzielnych stron     -->
  <!--  PDF (wzrost i waga) na podstawie pełnych danych Palczewskiej. -->
  <!--  Zastosowano lekkie wygładzanie krzywych (filtr trójkątny) i    -->
  <!--  dynamiczne rozszerzanie zakresów osi Y w zależności od         -->
  <!--  wprowadzonych pomiarów.  Przycisk generujący jest ukryty na    -->
  <!--  stronie i może zostać włączony w późniejszej aktualizacji UI.  -->
  <script>
  (function(){
    // Konwersja płci z inputu ('M'/'F') na klucz w centileData
    function sexKey(sex) {
      return (sex === 'M') ? 'boys' : 'girls';
    }
    // Zwraca wartość centylową wagi dla danego miesiąca m (12–216) i centyla p.
    // Stosuje interpolację liniową pomiędzy punktami z tablicy centileData.
    function getPalWeightCentile(sex, m, p) {
      if (typeof m !== 'number' || m < 12 || m > 216) return undefined;
      const key = 'p' + p;
      const dataset = (centileData[sexKey(sex)] && centileData[sexKey(sex)].weight) || [];
      // Znajdź dwa sąsiednie wpisy otaczające m
      let prev = null;
      let next = null;
      for (let i = 0; i < dataset.length; i++) {
        const entry = dataset[i];
        if (entry.months === m) {
          // dokładne trafienie – zwróć bez interpolacji
          return entry[key];
        }
        if (entry.months < m) prev = entry;
        if (entry.months > m) {
          next = entry;
          break;
        }
      }
      if (!prev || !next) {
        // jeżeli nie ma obu sąsiadów, zwróć undefined
        return undefined;
      }
      const t = (m - prev.months) / (next.months - prev.months);
      const v1 = prev[key];
      const v2 = next[key];
      // Jeśli któryś z punktów jest null/undefined, zwróć drugi lub undefined
      if (v1 == null && v2 == null) return undefined;
      if (v1 == null) return v2;
      if (v2 == null) return v1;
      return v1 + t * (v2 - v1);
    }
    // Zwraca wartość centylową wzrostu dla danego miesiąca m i centyla p (12–216).
    function getPalHeightCentile(sex, m, p) {
      if (typeof m !== 'number' || m < 12 || m > 216) return undefined;
      const key = 'p' + p;
      const dataset = (centileData[sexKey(sex)] && centileData[sexKey(sex)].height) || [];
      let prev = null;
      let next = null;
      for (let i = 0; i < dataset.length; i++) {
        const entry = dataset[i];
        if (entry.months === m) {
          return entry[key];
        }
        if (entry.months < m) prev = entry;
        if (entry.months > m) {
          next = entry;
          break;
        }
      }
      if (!prev || !next) return undefined;
      const t = (m - prev.months) / (next.months - prev.months);
      const v1 = prev[key];
      const v2 = next[key];
      if (v1 == null && v2 == null) return undefined;
      if (v1 == null) return v2;
      if (v2 == null) return v1;
      return v1 + t * (v2 - v1);
    }
    // Filtr trójkątny (Bartlett) wygładzający krzywe centylowe.  Przyjmujemy
    // okno o szerokości 5 (wagi 1–2–3–2–1) i wykonujemy kilka przebiegów,
    // aby uzyskać łagodniejsze krzywe niż zwykła średnia krocząca.
    function triangularSmooth(arr, passes = 3) {
      let out = arr.slice();
      const n = out.length;
      for (let pass = 0; pass < passes; pass++) {
        const tmp = out.slice();
        for (let i = 2; i < n - 2; i++) {
          const a0 = out[i - 2], a1 = out[i - 1], a2 = out[i], a3 = out[i + 1], a4 = out[i + 2];
          // Suma wag = 9 (1+2+3+2+1)
          tmp[i] = (a0 + 2 * a1 + 3 * a2 + 2 * a3 + a4) / 9;
        }
        out = tmp;
      }
      return out;
    }
    // Ustal minimalną i maksymalną wartość w tablicy krzywych centylowych
    function getRangeFromCurves(curves) {
      let minV = +Infinity;
      let maxV = -Infinity;
      for (const p in curves) {
        const arr = curves[p];
        if (!Array.isArray(arr)) continue;
        arr.forEach(v => {
          if (v == null) return;
          if (v < minV) minV = v;
          if (v > maxV) maxV = v;
        });
      }
      return [minV, maxV];
    }
    // Zaokrąglanie do najbliższej piątki w dół/górę
    const roundDown5 = v => Math.floor(v / 5) * 5;
    const roundUp5   = v => Math.ceil(v / 5) * 5;
    // Budowanie pojedynczej strony A4 z siatką Palczewskiej (dla wzrostu lub wagi)
    function buildPalczewskaPageCanvas({ chartType, sex, userAgeMonths, userWeight, userHeight }) {
      const rangeMinX = 12;
      const rangeMaxX = 216;
      const months = [];
      for (let m = rangeMinX; m <= rangeMaxX; m++) months.push(m);
      const percentiles = [3,10,25,50,75,90,97];
      const curves = {};
      percentiles.forEach(p => { curves[p] = []; });
      // Wypełnienie krzywych
      for (let m of months) {
        for (const p of percentiles) {
          let v;
          if (chartType === 'height') {
            v = getPalHeightCentile(sex, m, p);
          } else {
            v = getPalWeightCentile(sex, m, p);
          }
          curves[p].push(v);
        }
      }
      // Wygładź krzywe za pomocą filtru trójkątnego. Liczba przebiegów
      // została dobrana eksperymentalnie (3) – można ją zwiększyć lub
      // zmniejszyć w zależności od preferowanego poziomu gładkości.
      for (const p of percentiles) {
        curves[p] = triangularSmooth(curves[p], 6);
      }
      // Zakresy pierwotne
      const [minV, maxV] = getRangeFromCurves(curves);
      let minY = roundDown5(minV);
      let maxY = roundUp5(maxV);
      // Zbierz wszystkie pomiary z sekcji Zaawansowane w podanym zakresie
      const adv = window.advancedGrowthData || null;
      // Funkcja collectPageMeasurementsInRange jest zdefiniowana w innym skrypcie
      // i zwraca tablice ptsH (height) i ptsW (weight) dla zadanego zakresu
      let pts = [];
      if (typeof collectPageMeasurementsInRange === 'function') {
        const { ptsH, ptsW } = collectPageMeasurementsInRange(rangeMinX, rangeMaxX, {
          currentAgeMonths: userAgeMonths,
          currentWeight: userWeight,
          currentHeight: userHeight,
          adv
        });
        pts = (chartType === 'height') ? ptsH : ptsW;
      }
      // Dodaj bieżący pomiar, jeśli nie został uwzględniony (collectPageMeasurementsInRange robi to)
      // Oblicz minimalny i maksymalny pomiar
      let minMeasured = +Infinity;
      let maxMeasured = -Infinity;
      // Pomiary z historii
      pts.forEach(m => {
        const val = (chartType === 'height') ? m.height : m.weight;
        if (val == null) return;
        if (val < minMeasured) minMeasured = val;
        if (val > maxMeasured) maxMeasured = val;
      });
      // Bieżący pomiar (z formularza lub sekcji zaawansowanej)
      const effectiveVal = (chartType === 'height') ? userHeight : userWeight;
      if (Number.isFinite(effectiveVal) && effectiveVal > 0) {
        if (effectiveVal < minMeasured) minMeasured = effectiveVal;
        if (effectiveVal > maxMeasured) maxMeasured = effectiveVal;
      }
      // Rozszerz zakres Y w dół i w górę, jeśli pomiary wychodzą poza oryginalny zakres
      let dynMinY = minY;
      let dynMaxY = maxY;
      if (minMeasured < minY) {
        dynMinY = Math.max(0, roundDown5(minMeasured));
      }
      if (maxMeasured > maxY) {
        dynMaxY = roundUp5(maxMeasured);
      }
      // Oblicz indeks miesiąca do podświetlenia kanału centylowego
      const mIdx = userAgeMonths - rangeMinX;
      // Efektywna wartość do podświetlenia (użyj danych z sekcji zaawansowanej, jeśli podano)
      const advState = window.advancedGrowthData || {};
      const effAge  = (typeof advState.currentAgeMonths === 'number' && !isNaN(advState.currentAgeMonths)) ? advState.currentAgeMonths : userAgeMonths;
      const effVal  = (chartType === 'height')
        ? ((typeof advState.currentHeight === 'number' && !isNaN(advState.currentHeight)) ? advState.currentHeight : userHeight)
        : ((typeof advState.currentWeight === 'number' && !isNaN(advState.currentWeight)) ? advState.currentWeight : userWeight);
      const mIdxEff = effAge - rangeMinX;
      // Funkcja findHighlightBandSafe jest zdefiniowana w innym skrypcie
      let bandIdx = -1;
      if (typeof findHighlightBandSafe === 'function') {
        bandIdx = findHighlightBandSafe(effVal, curves, percentiles, mIdxEff);
      } else {
        // Prosta implementacja: znajdź przedział między sąsiadującymi centylami
        const vals = percentiles.map(p => curves[p][mIdxEff]);
        for (let i = 0; i < vals.length - 1; i++) {
          const lo = Math.min(vals[i], vals[i + 1]);
          const hi = Math.max(vals[i], vals[i + 1]);
          if (effVal >= lo && effVal <= hi) { bandIdx = i; break; }
        }
      }
      // Utwórz płótno A4
      const pw = 2480;
      const ph = 3508;
      const canvas = document.createElement('canvas');
      canvas.width = pw; canvas.height = ph;
      const ctx = canvas.getContext('2d');
      // Tło
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, pw, ph);
      // Nagłówek z nazwą siatki – zawiera płeć i rodzaj
      ctx.font = 'bold 72px sans-serif';
      ctx.fillStyle = '#00838d';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const sexLabel = (sex === 'M') ? 'chłopcy' : 'dziewczynki';
      const chartLabel = (chartType === 'height') ? 'wzrostu' : 'wagi';
      const headerLine1 = `Siatka centylowa ${chartLabel} – ${sexLabel}`;
      ctx.fillText(headerLine1, pw / 2, 60);
      ctx.font = '40px sans-serif';
      ctx.fillStyle = '#444444';
      ctx.fillText('Badanie Palczewskiej i Niedźwieckiej (1–18 lat)', pw / 2, 60 + 72 + 8);
      // Imię i nazwisko
      ctx.font = '40px sans-serif';
      ctx.fillStyle = '#555555';
      ctx.textAlign = 'left';
      const nameFromState = (window.advancedGrowthData && window.advancedGrowthData.name) ||
        (document.getElementById('advName') ? document.getElementById('advName').value.trim() : '');
      const nameLabel = nameFromState ? `Imię i nazwisko: ${nameFromState}` : 'Imię i nazwisko: _________________________________';
      ctx.fillText(nameLabel, 150, 150 + 50 * 1.75);
      // Parametry wykresu
      const chartX = 100;
      const chartY = 300 - 50; // lekko podnieś, aby podpisy nie kolidowały z nagłówkiem
      const chartW = pw - 200;
      const chartH = ph - chartY - 200;
      // Narysuj siatkę centylową
      drawCentileGrid(ctx, {
        x: chartX,
        y: chartY,
        w: chartW,
        h: chartH,
        curves: curves,
        minY: dynMinY,
        maxY: dynMaxY,
        userVal: effVal,
        userAgeMonths: effAge,
        title: (chartType === 'height') ? 'Wzrost (cm)' : 'Waga (kg)',
        units: (chartType === 'height') ? 'cm' : 'kg',
        percentiles: percentiles,
        highlightBandIdx: bandIdx,
        minX: rangeMinX,
        maxX: rangeMaxX,
        cutoffVal: (dynMaxY > maxY) ? maxY : undefined
      });
      // Rysowanie historii (linie + punkty)
      (function drawHistory() {
        const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
        const pxBase = chartX + leftMargin;
        const pyBase = chartY + topMargin;
        const pwBase = chartW - leftMargin - rightMargin;
        const phBase = chartH - topMargin - bottomMargin;
        const xScale = pwBase / (rangeMaxX - rangeMinX);
        const yScale = phBase / (dynMaxY - dynMinY);
        ctx.save();
        // Linie łączące kolejne pomiary
        if (pts && pts.length >= 2) {
          ctx.beginPath();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          let started = false;
          pts.forEach(m => {
            const ageM = m.ageMonths;
            const val  = (chartType === 'height') ? m.height : m.weight;
            if (ageM == null || val == null) return;
            const cx = pxBase + (ageM - rangeMinX) * xScale;
            const cy = pyBase + phBase - (val - dynMinY) * yScale;
            if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
          });
          ctx.stroke();
        }
        // Punkty pojedyncze
        if (pts) {
          pts.forEach(m => {
            const ageM = m.ageMonths;
            const val  = (chartType === 'height') ? m.height : m.weight;
            if (ageM == null || val == null) return;
            const cx = pxBase + (ageM - rangeMinX) * xScale;
            const cy = pyBase + phBase - (val - dynMinY) * yScale;
            ctx.beginPath();
            ctx.fillStyle = '#000000';
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();
          });
        }
        ctx.restore();
      })();
      // Marker wieku kostnego tylko na wykresie wzrostu
      if (chartType === 'height') {
        (function drawBoneAgeMarkers() {
          const adv = window.advancedGrowthData || null;
          if (!adv) return;
          const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
          const pxBase = chartX + leftMargin;
          const pyBase = chartY + topMargin;
          const pwBase = chartW - leftMargin - rightMargin;
          const phBase = chartH - topMargin - bottomMargin;
          const xScale = pwBase / (rangeMaxX - rangeMinX);
          const yScale = phBase / (dynMaxY - dynMinY);
          ctx.save();
          // Aktualny wiek kostny i wzrost
          if (typeof adv.boneAgeMonths === 'number' && !isNaN(adv.boneAgeMonths)) {
            const boneXAge = adv.boneAgeMonths;
            // Wykres wzrostu dotyczy aktualnej wysokości (effVal)
            if (boneXAge >= rangeMinX && boneXAge <= rangeMaxX && Number.isFinite(effVal)) {
              const cxBone = pxBase + (boneXAge - rangeMinX) * xScale;
              const cyBone = pyBase + phBase - (effVal - dynMinY) * yScale;
              const cxCurrent = pxBase + (effAge - rangeMinX) * xScale;
              ctx.beginPath();
              ctx.strokeStyle = '#00838d';
              ctx.lineWidth = 2;
              ctx.moveTo(cxBone, cyBone);
              ctx.lineTo(cxCurrent, cyBone);
              ctx.stroke();
              ctx.beginPath();
              ctx.fillStyle = '#00838d';
              ctx.arc(cxBone, cyBone, 12, 0, 2 * Math.PI);
              ctx.fill();
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.strokeStyle = '#00838d';
              ctx.arc(cxBone, cyBone, 24, 0, 2 * Math.PI);
              ctx.stroke();
            }
          }
          // Historyczne wieki kostne – każdy zapisany w measurements ma boneAgeYears
          if (adv && Array.isArray(adv.measurements)) {
            adv.measurements.forEach(m => {
              const bVal = (typeof m.boneAgeYears === 'number' || typeof m.boneAgeYears === 'string') ? parseFloat(m.boneAgeYears) : NaN;
              const hVal = (typeof m.height === 'number' || typeof m.height === 'string') ? parseFloat(m.height) : NaN;
              const aVal = (typeof m.ageMonths === 'number' || typeof m.ageMonths === 'string') ? parseFloat(m.ageMonths) : NaN;
              if (!isNaN(bVal) && !isNaN(hVal) && !isNaN(aVal)) {
                const boneM = Math.round(bVal * 12);
                if (boneM >= rangeMinX && boneM <= rangeMaxX && hVal >= dynMinY && hVal <= dynMaxY) {
                  const cxB = pxBase + (boneM - rangeMinX) * xScale;
                  const cyB = pyBase + phBase - (hVal - dynMinY) * yScale;
                  const cxCM = pxBase + (aVal - rangeMinX) * xScale;
                  ctx.beginPath();
                  ctx.strokeStyle = '#00838d';
                  ctx.lineWidth = 2;
                  ctx.moveTo(cxB, cyB);
                  ctx.lineTo(cxCM, cyB);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.fillStyle = '#00838d';
                  ctx.arc(cxB, cyB, 12, 0, 2 * Math.PI);
                  ctx.fill();
                  ctx.beginPath();
                  ctx.lineWidth = 2;
                  ctx.strokeStyle = '#00838d';
                  ctx.arc(cxB, cyB, 24, 0, 2 * Math.PI);
                  ctx.stroke();
                }
              }
            });
          }
          ctx.restore();
        })();
        // Dodanie podsumowania wyników na siatce Palczewskiej (1–18 lat) w trybie profesjonalnym
        (function drawSummaryOverlay() {
          try {
            let professional = false;
            if (typeof professionalMode !== 'undefined') {
              professional = !!professionalMode;
            } else {
              professional = (localStorage.getItem('resultsMode') === 'professional');
            }
            // Pomiń w trybie standardowym
            if (!professional) return;
            // Podsumowanie rysujemy tylko na wykresie wzrostu
            if (chartType !== 'height') return;
            const summaryEl = document.getElementById('currentSummaryContent');
            if (!summaryEl) return;
            let raw = summaryEl.innerText || summaryEl.textContent || '';
            raw = raw.trim();
            if (!raw) return;
            const lines = raw.split(/\n+/).map(l => l.trim()).filter(l => l);
            if (!lines.length) return;
            const leftMargin = 120, rightMargin = 100, topMargin = 80, bottomMargin = 80;
            const pxBase = chartX + leftMargin;
            const pyBase = chartY + topMargin;
            const pwBase = chartW - leftMargin - rightMargin;
            const phBase = chartH - topMargin - bottomMargin;
            const xScale = pwBase / (rangeMaxX - rangeMinX);
            const yScale = phBase / (dynMaxY - dynMinY);
            // W Palczewskiej odsuwamy o 1 rok (12 mies.) i 5 jednostek wzrostu
            const offsetMonths = 12;
            const offsetValue  = 5;
            const anchorX = pxBase + pwBase;
            const anchorY = pyBase + phBase;
            ctx.save();
            ctx.font = '32px sans-serif';
            const lineHeight = 42;
            const padding = 20;
            let maxWidth = 0;
            lines.forEach(l => {
              const w = ctx.measureText(l).width;
              if (w > maxWidth) maxWidth = w;
            });
            const bulletRadius = 6;
            const bulletSpacing = 20;
            const boxWidth  = padding * 2 + bulletRadius * 2 + bulletSpacing + maxWidth;
            const boxHeight = padding * 2 + lines.length * lineHeight;
            const dx = offsetMonths * xScale;
            const dy = offsetValue  * yScale;
            const boxX = anchorX - dx - boxWidth;
            const boxY = anchorY - dy - boxHeight;
            // Biała ramka z czarnym obramowaniem
            ctx.beginPath();
            ctx.lineWidth = 6;
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.rect(boxX, boxY, boxWidth, boxHeight);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            lines.forEach((text, idx) => {
              const y = boxY + padding + lineHeight * idx + lineHeight / 2;
              const bx = boxX + padding + bulletRadius;
              ctx.beginPath();
              ctx.arc(bx, y, bulletRadius, 0, 2 * Math.PI);
              ctx.fill();
              const tx = bx + bulletRadius + bulletSpacing;
              ctx.fillText(text, tx, y);
            });
            ctx.restore();
          } catch (_) {
            /* ignoruj błędy rysowania podsumowania */
          }
        })();
      }
      // Stopka
      ctx.save();
      ctx.font = '30px sans-serif';
      ctx.fillStyle = '#555555';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      const footerY = ph - 60 + 50;
      ctx.fillText('Dane do siatek centylowych: Palczewska & Niedźwiecka (1–18 lat)', pw - 120, footerY);
      ctx.textAlign = 'left';
      ctx.fillText('vildaclinic.pl', 120, footerY);
      ctx.restore();
      return canvas;
    }
    // Główna funkcja generująca dwustronny PDF z siatkami Palczewskiej (wzrost i waga)
    async function generatePalczewskaCentileCharts() {
      const ageEl    = document.getElementById('age');
      const ageMEl   = document.getElementById('ageMonths');
      const sexEl    = document.getElementById('sex');
      const weightEl = document.getElementById('weight');
      const heightEl = document.getElementById('height');
      if (!ageEl || !sexEl || !weightEl || !heightEl) {
        alert('Wprowadź wiek, płeć, wagę i wzrost, aby wygenerować siatkę.');
        return;
      }
      const years  = parseFloat(ageEl.value) || 0;
      const months = ageMEl ? (parseFloat(ageMEl.value) || 0) : 0;
      const ageMonths = Math.round(years * 12 + months);
      // Zakres Palczewskiej obejmuje 12–216 mies. (1–18 lat)
      if (ageMonths < 12 || ageMonths > 216) {
        alert('Siatki Palczewskiej dostępne są dla dzieci od 1 do 18 lat.');
        return;
      }
      const sex   = (sexEl.value === 'M') ? 'M' : 'F';
      const weight = parseFloat(weightEl.value);
      const height = parseFloat(heightEl.value);
      const heightCanvas = buildPalczewskaPageCanvas({ chartType: 'height', sex, userAgeMonths: ageMonths, userWeight: weight, userHeight: height });
      const weightCanvas = buildPalczewskaPageCanvas({ chartType: 'weight', sex, userAgeMonths: ageMonths, userWeight: weight, userHeight: height });
      // Konwersja canvasów do obrazów i dodanie do PDF
      const dataUrl1 = heightCanvas.toDataURL('image/jpeg', 1.0);
      const dataUrl2 = weightCanvas.toDataURL('image/jpeg', 1.0);
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
      pdf.addImage(dataUrl1, 'JPEG', 0, 0, 210, 297);
      pdf.addPage();
      pdf.addImage(dataUrl2, 'JPEG', 0, 0, 210, 297);
      const blob = pdf.output('blob');
      const url  = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }
    // Zarejestruj obsługę przycisku
    document.addEventListener('DOMContentLoaded', function() {
      const palBtn  = document.getElementById('generatePalCentileChart');
      const olafBtn = document.getElementById('generateCentileChart');
      // Kliknięcie przycisku generowania siatki Palczewska
      if (palBtn) {
        palBtn.addEventListener('click', generatePalczewskaCentileCharts);
      }
      // Funkcja aktualizująca widoczność przycisków w zależności od wybranego źródła danych
      function updateCentileButtons() {
        const selected = document.querySelector('input[name="dataSource"]:checked');
        const val = selected ? selected.value : 'OLAF';
        if (val === 'PALCZEWSKA') {
          // Pokaż przycisk Palczewska, ukryj standardowy
          if (palBtn)  palBtn.style.display  = '';
          if (olafBtn) olafBtn.style.display = 'none';
        } else {
          // Dla OLAF lub WHO używaj domyślnego przycisku
          if (palBtn)  palBtn.style.display  = 'none';
          if (olafBtn) olafBtn.style.display = '';
        }
      }
      // Reakcja na zmianę suwaka źródła danych
      const sources = document.querySelectorAll('input[name="dataSource"]');
      sources.forEach((r) => {
        r.addEventListener('change', updateCentileButtons);
      });
      // Ustaw początkowy stan przycisków
      updateCentileButtons();
    });
    // Udostępnij funkcję globalnie, aby można było ją wywołać z konsoli
    window.generatePalczewskaCentileCharts = generatePalczewskaCentileCharts;
  })();
  </script>

</body>
</html>
